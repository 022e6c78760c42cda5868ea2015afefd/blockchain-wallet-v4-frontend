/**
 * This client was automatically generated by Segment Typewriter. ** Do Not Edit **
 */

/**
 * Ajv is a peer dependency for development builds. It's used to apply run-time validation
 * to message payloads before passing them on to the underlying analytics instance.
 *
 * Note that the production bundle does not depend on Ajv.
 *
 * You can install it with: `npm install --save-dev ajv`.
 */
import Ajv from 'ajv'
import * as Segment from './segment'

export interface AccountPasswordChanged {
	/**
	 * What account we are talking about : USERKEY account : the Private Key (non custodial) wallet. CUSTODIAL : the custodial account allowing user to access their Trading, Savings, and/or Exchange wallets
	 */
	account_type: string
	/**
	 * Device type from where the event was triggered.
	 */
	device?: string
	/**
	 * From what platform the user is managing Security events

	 */
	platform: string
}
export interface Exchange {
	/**
	 * Whether the exchange account has 2FA set up
	 */
	two_fa_mode?: boolean
	/**
	 * Exchange user credentials ID
	 */
	user_id?: string
}
export interface Exchange1 {
	/**
	 * Whether the exchange account has 2FA set up
	 */
	two_fa_mode?: Record<string, any>
	/**
	 * Exchange user credentials ID
	 */
	user_id?: Record<string, any>
}
export interface Nabu {
	/**
	 * Whether the nabu user is eligible for recovery. Usually if account has value (> $300 or 1 payment method linked)
	 */
	recovery_eligible?: boolean
	/**
	 * The Nabu User ID. This is from the users table in nabu gateway
	 */
	user_id?: Record<string, any>
}
export interface Wallet {
	/**
	 * The wallet 2FA type that is enforced.
	 */
	auth_type?: string
	/**
	 * Parameters about the exchange account
	 */
	exchange?: Exchange1
	/**
	 * The first four characters of the wallet.guid field
	 */
	guid_first_four?: string
	/**
	 * Whether the wallet has cloud backups
	 */
	has_cloud_backup?: boolean
	/**
	 * Whether the wallet has a mobile client set up
	 */
	is_mobile_setup?: boolean
	/**
	 * The last time, in unix timestamp, in which a wallet has their mnemonic backup verified
	 */
	last_mnemonic_backup?: number
	/**
	 * The type of device being verified
	 */
	mobile_device_type?: string
	/**
	 * Parameter about the nabu account
	 */
	nabu?: Nabu
}
export interface AccountPasswordReset {
	/**
	 * What account we are talking about : USERKEY account : the Private Key (non custodial) wallet. CUSTODIAL : the custodial account allowing user to access their Trading, Savings, and/or Exchange wallets
	 */
	account_type: string
	/**
	 * Device type from where the event was triggered.
	 */
	device?: string
	/**
	 * Parameters about the exchange account
	 */
	exchange?: Exchange
	/**
	 * Indicates if possible to merge two unlinked accounts
	 */
	mergeable?: boolean
	/**
	 * what platform the account is for
	 */
	platform: string
	/**
	 * In reset : Whether the user is being redirected to the exchange or wallet
	 */
	site_redirect: string
	/**
	 * Indicates if possible to upgrade to a new unified Blockchain.com Account
	 */
	upgradeable?: boolean
	/**
	 * Parameters about the wallet account
	 */
	wallet?: Wallet
	/**
	 * Whether the resetting the password was after successfully providing the recovery phrase (True). If Not, (False) it is the reset flow without recovery phrase after acknowledging there could be loss of funds
	 */
	with_recovery_phrase: boolean
}
export interface Exchange2 {
	/**
	 * Whether the exchange account has 2FA set up
	 */
	two_fa_mode?: boolean
	/**
	 * Exchange user credentials ID
	 */
	user_id?: string
}
export interface Exchange3 {
	/**
	 * Whether the exchange account has 2FA set up
	 */
	two_fa_mode?: Record<string, any>
	/**
	 * Exchange user credentials ID
	 */
	user_id?: Record<string, any>
}
export interface Nabu1 {
	/**
	 * Whether the nabu user is eligible for recovery. Usually if account has value (> $300 or 1 payment method linked)
	 */
	recovery_eligible?: boolean
	/**
	 * The Nabu User ID. This is from the users table in nabu gateway
	 */
	user_id?: Record<string, any>
}
export interface Wallet1 {
	/**
	 * The wallet 2FA type that is enforced.
	 */
	auth_type?: string
	/**
	 * Parameters about the exchange account
	 */
	exchange?: Exchange3
	/**
	 * The first four characters of the wallet.guid field
	 */
	guid_first_four?: string
	/**
	 * Whether the wallet has cloud backups
	 */
	has_cloud_backup?: boolean
	/**
	 * Whether the wallet has a mobile client set up
	 */
	is_mobile_setup?: boolean
	/**
	 * The last time, in unix timestamp, in which a wallet has their mnemonic backup verified
	 */
	last_mnemonic_backup?: number
	/**
	 * The type of device being verified
	 */
	mobile_device_type?: string
	/**
	 * Parameter about the nabu account
	 */
	nabu?: Nabu1
}
export interface AccountRecoveryFailed {
	/**
	 * What account we are talking about : USERKEY account : the Private Key (non custodial) wallet. CUSTODIAL : the custodial account allowing user to access their Trading, Savings, and/or Exchange wallets
	 */
	account_type: string
	/**
	 * Device type from where the event was triggered.
	 */
	device?: string
	/**
	 * Parameters about the exchange account
	 */
	exchange?: Exchange2
	/**
	 * Indicates if possible to merge two unlinked accounts
	 */
	mergeable?: boolean
	/**
	 * what platform the account is for
	 */
	platform: string
	/**
	 * In reset : Whether the user is being redirected to the exchange or wallet
	 */
	site_redirect: string
	/**
	 * Indicates if possible to upgrade to a new unified Blockchain.com Account
	 */
	upgradeable?: boolean
	/**
	 * Parameters about the wallet account
	 */
	wallet?: Wallet1
}
export interface AddMobileNumberClicked {
	/**
	 * Device type from where the event was triggered.
	 */
	device: string
	/**
	 * From what platform the user is using the Settings
	 */
	platform: string
}
export interface AddressImported {
	currency: string
	/**
	 * Device type from where the event was triggered.
	 */
	device?: string
	/**
	 * True if user transferred funds from the imported address to an existing wallet.
	 */
	funds_transferred: boolean
	/**
	 * True if the user added a label when importing address
	 */
	label_added: boolean
	/**
	 * From what platform the user is using the Settings
	 */
	platform: string
}
export interface AddressInformationEntered {
	/**
	 * Device type from where the event was triggered.
	 */
	device: string
	/**
	 * What platform the user is entering PII from
	 */
	platform: string
}
export interface AddressLabelEdited {
	currency: string
	/**
	 * Device type from where the event was triggered.
	 */
	device?: string
	/**
	 * From what platform the user is using the Settings
	 */
	platform: string
	/**
	 * Segwit format or Legacy format
	 */
	transaction_format: string
}
export interface AddressMessageVerified {
	currency: string
	/**
	 * Device type from where the event was triggered.
	 */
	device?: string
	/**
	 * From what platform the user is using the Settings
	 */
	platform: string
}
export interface AddressVerifyMessageClicked {
	/**
	 * Device type from where the event was triggered.
	 */
	device: string
	/**
	 * From what platform the user is using the Settings
	 */
	platform: string
}
export interface AddressesRevealed {
	currency: string
	/**
	 * Device type from where the event was triggered.
	 */
	device?: string
	/**
	 * From what platform the user is using the Settings
	 */
	platform: string
	/**
	 * Segwit format or Legacy format
	 */
	transaction_format: string
}
export interface AmountSwitched {
	/**
	 * Device type from where the event was triggered.
	 */
	device: string
	/**
	 * What platform the amount form is from.
	 */
	platform: string
	/**
	 * for what product the user has switched the amount. BUY: buy crypto with Simplebuy product. SAVINGS : interest savings account product SELL: sell crypto with Simplebuy product. SEND : send product to send or move crypto.  SIMPLEBUY: either buy or sell transaction (prefer BUY or SELL if known). SWAP : swap product
	 */
	product: string
	/**
	 * whether the amount switches to FIAT or Crypto. If the users sees $100 and wants to enter amount in BTC, it will click on the button and trigger this event with switch_to = CRYPTO
	 */
	switch_to: string
}
export interface ApiAccessLinkClicked {
	/**
	 * Device type from where the event was triggered.
	 */
	device: string
	/**
	 * From what platform the user is managing Security events

	 */
	platform: string
}
export interface ApplicationBackgrounded {
	/**
	 * Device type from where the event was triggered.
	 */
	device: string
	/**
	 * From Which platform (WALLET or EXCHANGE)

	 */
	platfrom: string
}
export interface ApplicationCrashed {
	/**
	 * Device type from where the event was triggered.
	 */
	device: string
	/**
	 * From Which platform (WALLET or EXCHANGE)

	 */
	platfrom: string
}
export interface ApplicationInstalled {
	/**
	 * The build number of the installed app.

	 */
	build: string
	/**
	 * Device type from where the event was triggered.
	 */
	device: string
	/**
	 * the google play store advertising identifier
	 */
	gps_adid?: string
	/**
	 * The timestamp in seconds when the install started
	 */
	install_begin_timestamp_server_seconds?: number
	/**
	 * The referrer from the google play store referrer api
	 */
	install_referrer?: string
	/**
	 * From Which platform (WALLET or EXCHANGE)

	 */
	platform: string
	/**
	 * The version installed.
	 */
	version: string
}
export interface ApplicationOpened {
	/**
	 * The build number of the installed app.

	 */
	build: string
	/**
	 * Device type from where the event was triggered.
	 */
	device: string
	/**
	 * If application transitioned from “Background” to “Inactive” state prior to foregrounding (as opposed to from “Not Running” state).
	 */
	from_background: boolean
	/**
	 * From Which platform (WALLET or EXCHANGE)

	 */
	platform: string
	/**
	 * The value of UIApplicationLaunchOptionsSourceApplicationKey from launchOptions. Automatically collected on iOS only.
	 */
	referring_application?: string
	/**
	 * The value of UIApplicationLaunchOptionsURLKey from launchOptions. Collected on iOS only.
	 */
	url?: string
	/**
	 * The version installed.
	 */
	version: string
}
export interface ApplicationUninstalled {
	/**
	 * Device type from where the event was triggered.
	 */
	device: string
	/**
	 * From Which platform (WALLET or EXCHANGE)

	 */
	platform: string
}
export interface ApplicationUpdated {
	/**
	 * The build number of the installed app.

	 */
	build: string
	/**
	 * Device type from where the event was triggered.
	 */
	device: string
	/**
	 * Which version was installed the first time.
	 */
	installed_version?: string
	/**
	 * From Which platform (WALLET or EXCHANGE)

	 */
	platfrom: string
	/**
	 * The previously recorded build.
	 */
	previous_build?: string
	/**
	 * The previously recorded version.
	 */
	previous_version?: string
	/**
	 * The version installed.
	 */
	version: string
}
export interface AutoLogoutPeriodSet {
	/**
	 * Device type from where the event was triggered.
	 */
	device?: string
	/**
	 * minutes set for the max inactivity time period
	 */
	minutes: number
	/**
	 * From what platform the user is using the Settings
	 */
	platform: string
}
export interface BankAccountStateTriggered {
	/**
	 * What is the bank name. Found in extra_attributes -> 'bankName'. For example, BARCLAYS BANK PLC. Could be empty
	 */
	bank_name?: string
	/**
	 * What fiat currency the bank account is for
	 */
	currency: string
	/**
	 * Payment Entity. Found in distinct(extra_attributes -> 'entity') and could be empty (optional). For example, Fintecture(EU) or "Safeconnect(UK)"
	 */
	entity?: string
	institution_name?: string
	/**
	 * What is the bank partner. Found in partner column. Should be all upper case like in the table
	 */
	partner: string
	/**
	 * Whether this is ACH, OPEN_BANK. This does not apply for bank accounts, so set value to BANK_ACCOUNT in that case. You could know this by looking at account_ref which is either "ach_account" -> ACH or "open_banking" -> OPEN_BANKING
	 */
	service?: string
	/**
	 * The updated state of the bank account
	 */
	state: string
	/**
	 * What type of account it is. BANK_TRANSFER_ACCOUNT is renamed into BANK_TRANSFER and is for open banking and ach
	 */
	type: string
}
export interface BeneficiaryUpdated {
	currency: string
	institution_name?: string
	partner: string
	state: string
	type: string
}
export interface BiometricsUpdated {
	/**
	 * Device type from where the event was triggered.
	 */
	device: string
	/**
	 * Face Id was enabled or disabled.
	 */
	is_enabled: boolean
	/**
	 * From what platform the user is managing Security events
	 */
	platform: string
}
export interface BuyAmountEntered {
	/**
	 * Device type from where the event was triggered.
	 */
	device: string
	/**
	 * What is the recurring frequency of the buy. Set it as ONE_TIME if it is not a recurring buy
	 */
	frequency?: string
	/**
	 * The amount for the input currency
	 */
	input_amount: number
	/**
	 * Currency symbol for the currency being paid in exchange for some crypto. For example USD
	 */
	input_currency: string
	/**
	 * What is the maximum amount (in input_currency) being allowed for the Card order. Should be empty for other payment types. Amount usually recorded as a float. If 500 EUR, record 500.
	 */
	max_card_limit?: number
	/**
	 * Currency symbol for the currency being received. For example BTC
	 */
	output_currency: string
	/**
	 * The payment method used for the order
	 */
	payment_method?: string
	/**
	 * What platform the user wants to buy from
	 */
	platform: string
}
export interface BuyAmountHelperClicked {
	/**
	 * What amount in amount_currency the user clicks on
	 */
	amount: number
	/**
	 * What currency  for the amount selected
	 */
	amount_currency: string
	/**
	 * Device type from where the event was triggered.
	 */
	device: string
	/**
	 * Currency symbol for the currency being paid in exchange for some crypto. For example USD
	 */
	input_currency: string
	/**
	 * Currency symbol for the currency being received. For example BTC
	 */
	output_currency: string
	/**
	 * From what platform the amount is triggered
	 */
	platform: string
}
export interface BuyAmountMaxClicked {
	/**
	 * If the button explicitly displays the amount in a specific currency, what is the currency being clicked on for the max amount
	 */
	amount_currency?: string
	/**
	 * Device type from where the event was triggered.
	 */
	device: string
	/**
	 * Currency symbol for the currency being paid in exchange for some crypto. For example USD
	 */
	input_currency: string
	/**
	 * What is the maximum amount (in input_currency) being allowed for the Card order. Should be empty for other payment types. Amount usually recorded as a float. If 500 EUR, record 500.
	 */
	max_card_limit?: number
	/**
	 * Currency symbol for the currency being received. For example BTC
	 */
	output_currency: string
	/**
	 * What platform the user wants to buy from
	 */
	platform: string
}
export interface BuyAmountMinClicked {
	/**
	 * If the button explicitly displays the amount in a specific currency, what is the currency being clicked on for the min amount
	 */
	amount_currency?: string
	/**
	 * Device type from where the event was triggered.
	 */
	device: string
	/**
	 * Currency symbol for the currency being paid in exchange for some crypto. For example USD
	 */
	input_currency: string
	/**
	 * Currency symbol for the currency being received. For example BTC
	 */
	output_currency: string
	/**
	 * What platform the user wants to buy from
	 */
	platform: string
}
export interface BuyCancelled {
	/**
	 * Device the payment was made from
	 */
	device?: string
	/**
	 * Fee (in "currency") being charged for the payment.
	 */
	fee_amount?: number
	/**
	 * Amount in USD payed by the user.
	 */
	fee_amount_usd?: number
	/**
	 * The amount for the input currency, usually as a float. For USD, it should be for example 1.23, meaning 1.23 USD
	 */
	input_amount?: number
	/**
	 * The amount paid by the user in USD, usually as a float. it should be for example 10.23, meaning 10.23 USD
	 */
	input_amount_usd?: number
	/**
	 * Currency symbol for the currency being paid by the user in exchange for some crypto. For example USD

	 */
	input_currency: string
	/**
	 * Whether the buy order was created automatically by a recurring buy order. It is when no "recurringBuyId" is found in input_attributes
	 */
	is_recurring_buy?: boolean
	/**
	 * The amount for the output currency, usually as a float. For BTC, it should be for example 1.23, meaning 1.23 BTC

	 */
	output_amount?: number
	/**
	 * Currency symbol for the currency being received by the user. For example BTC

	 */
	output_currency: string
	/**
	 * id of the payment (id of the transaction from nabu payments)
	 */
	payment_id?: string
	/**
	 * The payment method used for the buy order. (the paymentType in simple_transactions input_attributes)
	 */
	payment_method: string
	/**
	 * What platform the event was started from. (WALLET if product=SIMPLEBUY and EXCHANGE if product=MERCURY

	 */
	platform: string
	/**
	 * The Product for which the buy order is (the product columns of the simple_transactions table)
	 */
	product: string
	/**
	 * The id used for the new pricing fee model (WALLET)
	 */
	quote_id?: string
	/**
	 * If the buy order was generated from a recurring buy, what is that recurringBuyId. Null otherwise
	 */
	recurring_buy_id?: string | null
	/**
	 * The id of the transaction for the buy order (the id of the simple_transactions table in nabu gateway)
	 */
	transaction_id?: string
}
export interface BuyCompleted {
	/**
	 * Device the payment was made from
	 */
	device?: string
	/**
	 * Fee (in "currency") being charged for the payment.
	 */
	fee_amount?: number
	/**
	 * Amount in USD payed by the user.
	 */
	fee_amount_usd?: number
	/**
	 * The amount for the input currency, usually as a float. For BTC, it should be for example 1.23, meaning 1.23 BTC
	 */
	input_amount: number
	/**
	 * The amount paid by the user in USD, usually as a float. it should be for example 10.23, meaning 10.23 USD
	 */
	input_amount_usd: number
	/**
	 * Currency symbol for the currency being paid by the user in exchange for some crypto. For example USD

	 */
	input_currency: string
	/**
	 * Whether the buy order was created automatically by a recurring buy order. It is when no "recurringBuyId" is found in input_attributes
	 */
	is_recurring_buy?: boolean
	/**
	 * The amount for the output currency, usually as a float. For BTC, it should be for example 1.23, meaning 1.23 BTC

	 */
	output_amount?: number
	/**
	 * Currency symbol for the currency being received by the user. For example BTC

	 */
	output_currency: string
	/**
	 * id of the payment (id of the transaction from nabu payments)
	 */
	payment_id?: string
	/**
	 * The payment method used for the buy order. (the paymentType in simple_transactions input_attributes)
	 */
	payment_method: string
	/**
	 * What platform the event was started from. (WALLET if product=SIMPLEBUY and EXCHANGE if product=MERCURY

	 */
	platform?: string
	/**
	 * The Product for which the buy order is (the product columns of the simple_transactions table)
	 */
	product: string
	/**
	 * The id used for the new pricing fee model (WALLET)
	 */
	quote_id?: string
	/**
	 * If the buy order was generated from a recurring buy, what is that recurringBuyId. Null otherwise
	 */
	recurring_buy_id?: string | null
	/**
	 * Spread percentage applied to the exchange rate
	 */
	spread_percentage: number
	/**
	 * The id of the transaction for the buy order (the id of the simple_transactions table in nabu gateway)
	 */
	transaction_id?: string
}
export interface BuyCreated {
	/**
	 * Device the payment was made from
	 */
	device?: string
	/**
	 * Fee (in "currency") being charged for the payment.
	 */
	fee_amount?: number
	/**
	 * Amount in USD payed by the user.
	 */
	fee_amount_usd?: number
	/**
	 * The expected amount for the input currency, usually as a float. For BTC, it should be for example 1.23, meaning 1.23 BTC. Exact amount is only in Buy Completed
	 */
	input_amount?: number
	/**
	 * The amount paid by the user in USD, usually as a float. it should be for example 10.23, meaning 10.23 USD
	 */
	input_amount_usd?: number
	/**
	 * Currency symbol for the currency being paid by the user in exchange for some crypto. For example USD

	 */
	input_currency: string
	/**
	 * Whether the buy order was created automatically by a recurring buy order. It is when no "recurringBuyId" is found in input_attributes
	 */
	is_recurring_buy?: boolean
	/**
	 * The expected amount for the output currency, usually as a float. For BTC, it should be for example 1.23, meaning 1.23 BTC. Exact amount is only in Buy Completed
	 */
	output_amount?: number
	/**
	 * Currency symbol for the currency being received by the user. For example BTC

	 */
	output_currency: string
	/**
	 * id of the payment (id of the transaction from nabu payments)
	 */
	payment_id?: string
	/**
	 * The payment method used for the buy order. (the paymentType in simple_transactions input_attributes)
	 */
	payment_method: string
	/**
	 * What platform the event was started from. (WALLET if product=SIMPLEBUY and EXCHANGE if product=MERCURY

	 */
	platform: string
	/**
	 * The Product for which the buy order is (the product columns of the simple_transactions table)
	 */
	product: string
	/**
	 * The id used for the new pricing fee model (WALLET)
	 */
	quote_id?: string
	/**
	 * If the buy order was generated from a recurring buy, what is that recurringBuyId. Null otherwise
	 */
	recurring_buy_id?: string | null
	/**
	 * The id of the transaction for the buy order (the id of the simple_transactions table in nabu gateway)
	 */
	transaction_id?: string
}
export interface BuyExpired {
	/**
	 * Device the payment was made from
	 */
	device?: string
	/**
	 * Fee (in "currency") being charged for the payment.
	 */
	fee_amount?: number
	/**
	 * Amount in USD payed by the user.
	 */
	fee_amount_usd?: number
	/**
	 * The amount for the input currency, usually as a float. For BTC, it should be for example 1.23, meaning 1.23 BTC
	 */
	input_amount?: number
	/**
	 * The amount paid by the user in USD, usually as a float. it should be for example 10.23, meaning 10.23 USD
	 */
	input_amount_usd?: number
	/**
	 * Currency symbol for the currency being paid by the user in exchange for some crypto. For example USD

	 */
	input_currency: string
	/**
	 * Whether the buy order was created automatically by a recurring buy order. It is when no "recurringBuyId" is found in input_attributes
	 */
	is_recurring_buy?: boolean
	/**
	 * The amount for the output currency, usually as a float. For BTC, it should be for example 1.23, meaning 1.23 BTC

	 */
	output_amount?: number
	/**
	 * Currency symbol for the currency being received by the user. For example BTC

	 */
	output_currency: string
	/**
	 * id of the payment (id of the transaction from nabu payments)
	 */
	payment_id?: string
	/**
	 * The payment method used for the buy order. (the paymentType in simple_transactions input_attributes)
	 */
	payment_method: string
	/**
	 * What platform the event was started from. (WALLET if product=SIMPLEBUY and EXCHANGE if product=MERCURY

	 */
	platform: string
	/**
	 * The Product for which the buy order is (the product columns of the simple_transactions table)
	 */
	product: string
	/**
	 * The id used for the new pricing fee model (WALLET)
	 */
	quote_id?: string
	/**
	 * If the buy order was generated from a recurring buy, what is that recurringBuyId. Null otherwise
	 */
	recurring_buy_id?: string | null
	/**
	 * The id of the transaction for the buy order (the id of the simple_transactions table in nabu gateway)
	 */
	transaction_id?: string
}
export interface BuyFailed {
	/**
	 * Device the payment was made from
	 */
	device?: string
	/**
	 * Fee (in "currency") being charged for the payment.
	 */
	fee_amount?: number
	/**
	 * Amount in USD payed by the user.
	 */
	fee_amount_usd?: number
	/**
	 * The amount for the input currency, usually as a float. For BTC, it should be for example 1.23, meaning 1.23 BTC
	 */
	input_amount?: number
	/**
	 * The amount paid by the user in USD, usually as a float. it should be for example 10.23, meaning 10.23 USD
	 */
	input_amount_usd?: number
	/**
	 * Currency symbol for the currency being paid by the user in exchange for some crypto. For example USD

	 */
	input_currency: string
	/**
	 * Whether the buy order was created automatically by a recurring buy order. It is when no "recurringBuyId" is found in input_attributes
	 */
	is_recurring_buy?: boolean
	/**
	 * The amount for the output currency, usually as a float. For BTC, it should be for example 1.23, meaning 1.23 BTC

	 */
	output_amount?: number
	/**
	 * Currency symbol for the currency being received by the user. For example BTC

	 */
	output_currency: string
	/**
	 * id of the payment (id of the transaction from nabu payments)
	 */
	payment_id?: string
	/**
	 * The payment method used for the buy order. (the paymentType in simple_transactions input_attributes)
	 */
	payment_method: string
	/**
	 * What platform the event was started from. (WALLET if product=SIMPLEBUY and EXCHANGE if product=MERCURY

	 */
	platform: string
	/**
	 * The Product for which the buy order is (the product columns of the simple_transactions table)
	 */
	product: string
	/**
	 * The id used for the new pricing fee model (WALLET)
	 */
	quote_id?: string
	/**
	 * If the buy order was generated from a recurring buy, what is that recurringBuyId. Null otherwise
	 */
	recurring_buy_id?: string | null
	/**
	 * The id of the transaction for the buy order (the id of the simple_transactions table in nabu gateway)
	 */
	transaction_id?: string
}
export interface BuyFrequencySelected {
	/**
	 * Device type from where the event was triggered.
	 */
	device: string
	/**
	 * What is the recurring frequency of the buy. Set it as ONE_TIME if it is not a recurring buy
	 */
	frequency: string
	/**
	 * What platform the user wants to buy from
	 */
	platform: string
}
export interface BuyLearnMoreClicked {
	/**
	 * Device type from where the event was triggered.
	 */
	device: string
	/**
	 * What platform the user wants to buy from
	 */
	platform?: string
	/**
	 * What does the user want to learn more about ? WITHDRAWAL_LOCK
	 */
	type: string
}
export interface BuyPaymentMethodSelected {
	/**
	 * Device type from where the event was triggered.
	 */
	device: string
	/**
	 * What payment type is selected : 
BANK_ACCOUNT: funds sent from a bank account. 
BANK_TRANSFER : Funds sent from Linked account via Open Banking or ACH. 
FUNDS: Funds taken from available funds in fiat wallet. 
PAYMENT_CARD:  by debit or credit card
	 */
	payment_type: string
	/**
	 * What platform the user wants to buy from
	 */
	platform: string
}
export interface BuyRejected {
	/**
	 * Device the payment was made from
	 */
	device?: string
	/**
	 * Error message related to the rejection. This is more detailed than the rejection_reason
	 */
	error_reason?: string
	/**
	 * Fee (in "currency") being charged for the payment.
	 */
	fee_amount?: number
	/**
	 * Amount in USD payed by the user.
	 */
	fee_amount_usd?: number
	/**
	 * The expected amount for the input currency, usually as a float. For BTC, it should be for example 1.23, meaning 1.23 BTC. The exact amount might not be known.
	 */
	input_amount?: number
	/**
	 * The amount paid by the user in USD, usually as a float. it should be for example 10.23, meaning 10.23 USD
	 */
	input_amount_usd?: number
	/**
	 * Currency symbol for the currency being paid by the user in exchange for some crypto. For example USD

	 */
	input_currency: string
	/**
	 * Whether the buy order was created automatically by a recurring buy order. It is when no "recurringBuyId" is found in input_attributes
	 */
	is_recurring_buy?: boolean
	/**
	 * The amount for the output currency, usually as a float. For BTC, it should be for example 1.23, meaning 1.23 BTC. The exact amount might not be known.

	 */
	output_amount?: number
	/**
	 * Currency symbol for the currency being received by the user. For example BTC

	 */
	output_currency: string
	/**
	 * id of the payment (id of the transaction from nabu payments)
	 */
	payment_id?: string
	/**
	 * The payment method used for the buy order. (the paymentType in simple_transactions input_attributes)
	 */
	payment_method: string
	/**
	 * What platform the event was started from. (WALLET if product=SIMPLEBUY and EXCHANGE if product=MERCURY

	 */
	platform: string
	/**
	 * The Product for which the buy order is (the product columns of the simple_transactions table)
	 */
	product: string
	/**
	 * The id used for the new pricing fee model (WALLET)
	 */
	quote_id?: string
	/**
	 * If the buy order was generated from a recurring buy, what is that recurringBuyId. Null otherwise
	 */
	recurring_buy_id?: string | null
	/**
	 * More details about the rejection, if more context would be useful to know
	 */
	rejection_details?: string
	/**
	 * The main reason why creating the buy order was rejected.
	 */
	rejection_reason: string
}
export interface BuySellClicked {
	/**
	 * Device type from where the event was triggered.
	 */
	device: string
	/**
	 * What button we are referring to. 
BUY_WIDGET: buy widget from Explorer. 
CURRENCY_PAGE : cta or menu on the coin page next to balance. 
DASHBOARD_PROMO : announcement card or promo on dashboard. 
DCA_EXPLAINER : from the DCA (Dollar Cost Averaging)) Info Viewed.
DEEP_LINK : any deep link other than BUY_WIDGET
NAVIGATION : navigation bar.
PENDING_ORDER : user looks up details about pending order.
PRICE_CHART (web only). 
SAVINGS (web only) : comes from interest savings product. 
SAVINGS_CONFIRMATION : from the confirmation screen of an interest savings deposit.
SEND: comes from Send product. 
SELL (web only) : from sell product. 
SIMPLETRADE: from simple trade general product page 
TRANSACTION_DETAILS : from historical transaction details. 
TRANSACTION_LIST : from the historical transaction list
WELCOME : from the onboarding flow. 
	 */
	origin: string
	/**
	 * What platform the user is clicking from
	 */
	platform: string
	/**
	 * Whether this is a BUY or SELL click. Sometimes it is the same button (e.g. Buy/Sell in navigation bar), in that case leave empty. Otherwise add whether it is Buy or Sell.
	 */
	type?: string
}
export interface BuySellViewed {
	''?: Record<string, any>
	/**
	 * Device type from where the event was triggered.

	 */
	device: string
	/**
	 * Path portion of the URL of the page. Equivalent to canonical path which defaults to location.pathname from the DOM API.
	 */
	path?: string
	/**
	 * What platform the page viewed belongs to
	 */
	platform: string
	/**
	 * Full URL of the previous page. Equivalent to document.referrer from the DOM API.
	 */
	referrer?: string
	/**
	 * Query string portion of the URL of the page. Equivalent to location.search from the DOM API.
	 */
	search?: string
	/**
	 * Title of the page. Equivalent to document.title from the DOM API.
	 */
	title?: string
	/**
	 * Whether this is a BUY or SELL screen or page viewed. Sometimes it is the same button (e.g. Buy/Sell in navigation bar), in that case leave empty. Otherwise add whether it is Buy or Sell.
	 */
	type?: string
	/**
	 * Full URL of the page. First we look for the canonical url. If the canonical url is not provided, we use location.href from the DOM API.
	 */
	url?: string
}
export interface BuyWidgetAmountEntered {
	/**
	 * What device the event is tracked from
	 */
	device: string
	/**
	 * 

	 */
	input_amount: number
	/**
	 * Currency symbol for the currency being paid in exchange for some crypto. For example USD
	 */
	input_currency: string
	/**
	 * Currency symbol for the currency being received. For example BTC
	 */
	output_currency: string
	/**
	 * What platform the event is referring to
	 */
	platform: string
}
export interface BuyWidgetClicked {
	/**
	 * If available, what is the currency the user wants to buy ? For example in the Explorer crypto prices page, did he click on a specific currency ?
	 */
	currency?: string
	/**
	 * What device the event is tracked from
	 */
	device: string
	/**
	 * From which page was the widget clicked? HOME : Buy Crypto from landing page or explorer home page. CRYPTO_PRICES : from the explorer general price page with all the coins listed. CRYPTO_PRICE_DETAILS : from the explorer price page about a specific crypto
	 */
	origin: string
	/**
	 * What platform the event is referring to
	 */
	platform: string
}
export interface CameraPermissionChecked {
	/**
	 * Device the user was requested to access the camera from
	 */
	device: string
	/**
	 * whether the camera access is authorised
	 */
	is_authorised: boolean
	/**
	 * Whether the permission was checked during KYC verification or when scanning a QR_CODE
	 */
	origin: string
	/**
	 * Platform the user is using wallet connect from. Currently it will be only available from the WALLET
	 */
	platform: string
}
export interface CameraPermissionRequestActioned {
	/**
	 * What action the user took on the request. ALLOW : the user allows the device to access the camera. REJECT : the user does not allow the device to access the camera
	 */
	action: string
	/**
	 * Device the user answered the request from
	 */
	device: string
	/**
	 * Platform the user is using wallet connect from. Currently it will be only available from the WALLET
	 */
	platform: string
}
export interface CancelRecurringBuyClicked {
	/**
	 * Device type from where the event was triggered.
	 */
	device: string
	/**
	 * What is the frequency of the recurring buy. Also called period in the backend.
	 */
	frequency: string
	/**
	 * The amount for the input currency
	 */
	input_amount: number
	/**
	 * Currency symbol for the currency being paid in exchange for some crypto. For example USD
	 */
	input_currency: string
	/**
	 * What button we are referring to : RECURRING_BUY_DETAILS : When looking at the details of an active recurring buy. TRANSACTION_DETAILS : When looking at the details of the buy transaction that came from a recurring buy
	 */
	origin: string
	/**
	 * Currency symbol for the currency being received. For example BTC
	 */
	output_currency: string
	/**
	 * The payment method used for the recurring buy order
	 */
	payment_method: string
	/**
	 * What platform the user wants to set up recurring buy from
	 */
	platform: string
}
export interface CardStateTriggered {
	/**
	 * The country used in the billing address. extra_attributes -> 'billing_address' ->> 'country'
	 */
	country_billing: string
	/**
	 * Currency of the card
	 */
	currency: string
	/**
	 * Device type from where the event was triggered.
	 */
	device?: string
	institution_name?: string
	/**
	 * What entity or bank issued the card, such as Barclays, Revolut etc. (extra_attributes -> 'card' ->> 'issuer' from account).
	 */
	issuer?: string
	/**
	 * The card partner. From the partner column. Should be all upper case like in the table.
	 */
	partner: string
	/**
	 * The updated state of the card
	 */
	state: string
	/**
	 * Type of card. from extra_attributes -> 'card' ->> 'type' from account, transformed to upper_case. visa -> VISA. master_card -> MASTER_CARD
	 */
	type: string
}
export interface ChangeMobileNumberClicked {
	/**
	 * Device type from where the event was triggered.

	 */
	device: string
	/**
	 * From what platform the user is using the Settings
	 */
	platform: string
}
export interface ChangePinClicked {
	/**
	 * Device type from where the event was triggered.
	 */
	device: string
	/**
	 * From what platform the user is managing Security events
	 */
	platform: string
}
export interface Exchange4 {
	/**
	 * Whether the exchange account has 2FA set up
	 */
	two_fa_mode?: boolean
	/**
	 * Exchange user credentials ID
	 */
	user_id?: string
}
export interface Exchange5 {
	/**
	 * Whether the exchange account has 2FA set up
	 */
	two_fa_mode?: Record<string, any>
	/**
	 * Exchange user credentials ID
	 */
	user_id?: Record<string, any>
}
export interface Nabu2 {
	/**
	 * Whether the nabu user is eligible for recovery. Usually if account has value (> $300 or 1 payment method linked)
	 */
	recovery_eligible?: boolean
	/**
	 * The Nabu User ID. This is from the users table in nabu gateway
	 */
	user_id?: Record<string, any>
}
export interface Wallet2 {
	/**
	 * The wallet 2FA type that is enforced.
	 */
	auth_type?: string
	/**
	 * Parameters about the exchange account
	 */
	exchange?: Exchange5
	/**
	 * The first four characters of the wallet.guid field
	 */
	guid_first_four?: string
	/**
	 * Whether the wallet has cloud backups
	 */
	has_cloud_backup?: boolean
	/**
	 * Whether the wallet has a mobile client set up
	 */
	is_mobile_setup?: boolean
	/**
	 * The last time, in unix timestamp, in which a wallet has their mnemonic backup verified
	 */
	last_mnemonic_backup?: number
	/**
	 * The type of device being verified
	 */
	mobile_device_type?: string
	/**
	 * Parameter about the nabu account
	 */
	nabu?: Nabu2
}
export interface CloudBackupCodeScanned {
	/**
	 * Device type from where the event was triggered.
	 */
	device: string
	/**
	 * Parameters about the exchange account
	 */
	exchange?: Exchange4
	/**
	 * Indicates if possible to merge two unlinked accounts
	 */
	mergeable?: boolean
	/**
	 * What platform the user is is recovering the account from
	 */
	platform: string
	/**
	 * Whether the user is being redirected to the exchange or wallet
	 */
	site_redirect: string
	/**
	 * Indicates if possible to upgrade to a new unified Blockchain.com Account
	 */
	upgradeable?: boolean
	/**
	 * Parameters about the wallet account
	 */
	wallet?: Wallet2
}
export interface CoinSearchSubmitted {
	/**
	 * Currency symbol for the currency being selected to trade by the user.
	 */
	currency?: string
	/**
	 * What device the event is tracked from
	 */
	device: string
	/**
	 * What platform the user is searching from. For now, on BLOCKCHAIN_COM, the search is on the navigation bar, while on the explorer the search is just below next to the breadcrumb
	 */
	platform: string
}
export interface ConnectedDappActioned {
	/**
	 * What action the user is doing. LAUNCH or DISCONNECT
	 */
	action: string
	/**
	 * What is the name of the application being actioned on. Prefer "Proper Case" name rather than snake_case or camelCase
	 */
	app_name: string
	/**
	 * Device the user user is using wallet connect from
	 */
	device: string
	/**
	 * What button we are referring to. APPS_LIST : the list of already connected apps
	 */
	origin: string
	/**
	 * Platform the user is using wallet connect from. Currently it will be only available from the WALLET
	 */
	platform: string
}
export interface ConnectedDappClicked {
	/**
	 * What is the name of the application being clicked on. Prefer "Proper Case" name rather than snake_case or camelCase
	 */
	app_name: string
	/**
	 * Device the user user is using wallet connect from
	 */
	device: string
	/**
	 * What button we are referring to. APPS_LIST : the list of already connected apps
	 */
	origin: string
	/**
	 * Platform the user is using wallet connect from. Currently it will be only available from the WALLET
	 */
	platform: string
}
export interface ConnectedDappsListClicked {
	/**
	 * The device the user clicked on the button to view the list of Apps from
	 */
	device: string
	/**
	 * What button we are referring to. QR_CODE : when a link pops up after scanning a QR code. SETTINGS : from the settings
	 */
	origin: string
	/**
	 * Platform the user is using wallet connect from. Currently it will be only available from the WALLET
	 */
	platform: string
}
export interface ConnectedDappsListViewed {
	/**
	 * The device the user viewed the list of Apps from
	 */
	device: string
	/**
	 * Platform the user is using wallet connect from. Currently it will be only available from the WALLET
	 */
	platform: string
}
export interface CryptoLinkHandlingClicked {
	/**
	 * Device type from where the event was triggered.
	 */
	device: string
	/**
	 * From what platform the user is using the Settings
	 */
	platform: string
}
export interface CryptoLinkHandlingEnabled {
	/**
	 * Device type from where the event was triggered.
	 */
	device?: string
	/**
	 * From what platform the user is using the Settings
	 */
	platform: string
}
export interface CustodialTransferCompleted {
	/**
	 * Amount being transferred, in the given currency. e.g. for 1.23 BTC, the amount is 1.23
	 */
	amount: number
	/**
	 * Amount (in USD) being transferred. e.g. for 10.23, for $10.23
	 */
	amount_usd?: number
	/**
	 * What currency is being transferred
	 */
	currency: string
	/**
	 * To what account type the funds are coming from. This is usually named as a product SAVINGS or SIMPLEBUY
	 */
	destination: string
	/**
	 * Device type from where the event was triggered.
	 */
	device?: string
	/**
	 * From what account type the funds are coming from. This is usually named as the product like SAVINGS or SIMPLEBUY
	 */
	origin: string
	/**
	 * What platform the event was started from. WALLET is the only option

	 */
	platform: string
	/**
	 * id of the custodial transfer
	 */
	transfer_id: string
}
export interface DappConnectionActioned {
	/**
	 * What action the user is doing. CONFIRM : when confirming the connection to the app. CANCEL : when cancelling the connection request
	 */
	action: string
	/**
	 * What is the name of the application being actioned on. Prefer "Proper Case" name rather than snake_case or camelCase
	 */
	app_name: string
	/**
	 * Device the user user is using wallet connect from
	 */
	device: string
	/**
	 * Platform the user is using wallet connect from. Currently it will be only available from the WALLET
	 */
	platform: string
}
export interface DappConnectionConfirmed {
	/**
	 * What is the name of the application being actioned on. Prefer "Proper Case" name rather than snake_case or camelCase
	 */
	app_name: string
	/**
	 * Device the user user is using wallet connect from
	 */
	device: string
	/**
	 * Platform the user is using wallet connect from. Currently it will be only available from the WALLET
	 */
	platform: string
}
export interface DappConnectionRejected {
	/**
	 * What is the name of the application being actioned on. Prefer "Proper Case" name rather than snake_case or camelCase
	 */
	app_name: string
	/**
	 * Device the user user is using wallet connect from
	 */
	device: string
	/**
	 * Platform the user is using wallet connect from. Currently it will be only available from the WALLET
	 */
	platform: string
}
export interface DappRequestActioned {
	/**
	 * What action is taken by the user
	 */
	action: string
	/**
	 * What is the name of the application being actioned on. Prefer "Proper Case" name rather than snake_case or camelCase
	 */
	app_name: string
	/**
	 * Device the user user is using wallet connect from
	 */
	device: string
	/**
	 * Type of dapp request
	 */
	method: string
	/**
	 * Platform the user is using wallet connect from. Currently it will be only available from the WALLET
	 */
	platform: string
}
export interface DashboardClicked {
	/**
	 * Device type from where the event was triggered. (mobile only)
	 */
	device: string
	/**
	 * Where does the user come from. 
NAVIGATION : Home on the navigation bar.  
	 */
	origin: string
	/**
	 * What platform the user is clicking from
	 */
	platform: string
}
export interface DashboardViewed {
	/**
	 * Device type from where the event was triggered. (mobile only)
	 */
	device: string
	/**
	 * Path portion of the URL of the page. Equivalent to canonical path which defaults to location.pathname from the DOM API.
	 */
	path?: string
	/**
	 * What platform the page viewed belongs to
	 */
	platform: string
	/**
	 * Full URL of the previous page. Equivalent to document.referrer from the DOM API.
	 */
	referrer?: string
	/**
	 * Query string portion of the URL of the page. Equivalent to location.search from the DOM API.
	 */
	search?: string
	/**
	 * Title of the page. Equivalent to document.title from the DOM API.
	 */
	title?: string
	/**
	 * Full URL of the page. First we look for the canonical url. If the canonical url is not provided, we use location.href from the DOM API.
	 */
	url?: string
}
export interface Campaign {
	/**
	 * Campaign Medium
	 */
	medium?: string
	/**
	 * Campaign Name
	 */
	name?: string
	/**
	 * Campaign Source
	 */
	source?: string
}
export interface DeepLinkClicked {
	campaign?: Campaign
	/**
	 * Device type from where the event was triggered.
	 */
	device: string
	platfrom: string
	/**
	 * The deep link provider.
	 */
	provider?: string
	/**
	 * The deep link URL clicked.
	 */
	url?: string
}
export interface Campaign1 {
	/**
	 * Campaign Medium
	 */
	medium?: string
	/**
	 * Campaign Name
	 */
	name?: string
	/**
	 * Campaign source
	 */
	source?: string
}
export interface DeepLinkOpened {
	campaign?: Campaign1
	/**
	 * Device type from where the event was triggered.
	 */
	device: string
	/**
	 * Whether the deep link is opened from the Wallet of the Exchange
	 */
	platform: string
	platfrom: string
	/**
	 * The deep link provider.
	 */
	provider?: string
	/**
	 * The App URL opened.
	 */
	url?: string
}
export interface DeletedAddressLabel {
	/**
	 * Device type from where the event was triggered.
	 */
	device?: string
	/**
	 * From what platform the user is using the Settings
	 */
	platform: string
	/**
	 * Segwit format or Legacy format
	 */
	transaction_format: string
}
export interface DepositAmountEntered {
	/**
	 * the currency the user wants to deposit
	 */
	currency: string
	/**
	 * How the funds will be deposited : 
BANK_ACCOUNT: funds sent from a bank account, this is a classic transfer. 
BANK_TRANSFER : Funds sent from Linked account via Open Banking or ACH. 
	 */
	deposit_method: string
	/**
	 * Device type from where the event was triggered.
	 */
	device: string
	/**
	 * The amount the user will withdraw (before fee applies)
	 */
	input_amount: number
	/**
	 * The amount the user will actual get (after fee applies)
	 */
	output_amount: number
	/**
	 * What platform the user is depositing funds to
	 */
	platform: string
}
export interface DepositClicked {
	/**
	 * Device type from where the event was triggered.
	 */
	device: string
	/**
	 * What button we are referring to. BALANCE : for the exchange, next to the balance (total account value) info on the main trading page. CURRENCY_PAGE : CTA or menu on the coin page next to balance. DEPOSIT: when trying to deposit some funds. LINK_WALLET. PORTFOLIO (exchange) : deposit next to currency balance. RECURRING_BUY : order details or status suggesting to add cash SIGN_UP : when prompted to deposit at sign up SIMPLETRADE : when trying to buy via the Simple Trade product without funds. WITHDRAW: when suggesting to deposit from no funds in withdraw screen. TRADE_TICKET (web only?) : for trade ticket when user has no funds
	 */
	origin: string
	/**
	 * What platform the user is clicking from
	 */
	platform: string
}
export interface DepositMethodSelected {
	/**
	 * the currency the user wants to deposit
	 */
	currency: string
	/**
	 * How the funds will be deposited : 
BANK_ACCOUNT: funds sent from a bank account, this is a classic transfer. 
BANK_TRANSFER : Funds sent from Linked account via Open Banking or ACH. 
	 */
	deposit_method: string
	/**
	 * Device type from where the event was triggered.
	 */
	device: string
	/**
	 * What platform the user is depositing funds to
	 */
	platform: string
}
export interface DepositViewed {
	/**
	 * Device type from where the event was triggered.
	 */
	device: string
	/**
	 * Path portion of the URL of the page. Equivalent to canonical path which defaults to location.pathname from the DOM API.
	 */
	path?: string
	/**
	 * What platform the page viewed belongs to
	 */
	platform?: string
	/**
	 * Full URL of the previous page. Equivalent to document.referrer from the DOM API.
	 */
	referrer?: string
	/**
	 * Query string portion of the URL of the page. Equivalent to location.search from the DOM API.
	 */
	search?: string
	/**
	 * Title of the page. Equivalent to document.title from the DOM API.
	 */
	title?: string
	/**
	 * Full URL of the page. First we look for the canonical url. If the canonical url is not provided, we use location.href from the DOM API.
	 */
	url?: string
}
export interface Exchange6 {
	/**
	 * Whether the exchange account has 2FA set up
	 */
	two_fa_mode?: boolean
	/**
	 * Exchange user credentials ID
	 */
	user_id?: string
}
export interface Exchange7 {
	/**
	 * Whether the exchange account has 2FA set up
	 */
	two_fa_mode?: Record<string, any>
	/**
	 * Exchange user credentials ID
	 */
	user_id?: Record<string, any>
}
export interface Nabu3 {
	/**
	 * Whether the nabu user is eligible for recovery. Usually if account has value (> $300 or 1 payment method linked)
	 */
	recovery_eligible?: boolean
	/**
	 * The Nabu User ID. This is from the users table in nabu gateway
	 */
	user_id?: Record<string, any>
}
export interface Wallet3 {
	/**
	 * The wallet 2FA type that is enforced.
	 */
	auth_type?: string
	/**
	 * Parameters about the exchange account
	 */
	exchange?: Exchange7
	/**
	 * The first four characters of the wallet.guid field
	 */
	guid_first_four?: string
	/**
	 * Whether the wallet has cloud backups
	 */
	has_cloud_backup?: boolean
	/**
	 * Whether the wallet has a mobile client set up
	 */
	is_mobile_setup?: boolean
	/**
	 * The last time, in unix timestamp, in which a wallet has their mnemonic backup verified
	 */
	last_mnemonic_backup?: number
	/**
	 * The type of device being verified
	 */
	mobile_device_type?: string
	/**
	 * Parameter about the nabu account
	 */
	nabu?: Nabu3
}
export interface DeviceVerified {
	device: string
	/**
	 * Parameters about the exchange account
	 */
	exchange?: Exchange6
	/**
	 * Indicates if possible to merge two unlinked accounts
	 */
	mergeable?: boolean
	/**
	 * the platform that received the notification about the device being verified
	 */
	platform: string
	/**
	 * Whether the user is being redirected to the exchange or wallet
	 */
	site_redirect?: string
	/**
	 * Indicates if possible to “upgrade” to a new unified Blockchain.com Account
	 */
	upgradeable?: boolean
	/**
	 * Parameters about the wallet account
	 */
	wallet?: Wallet3
}
export interface EmailChangeClicked {
	/**
	 * Device type from where the event was triggered.
	 */
	device: string
	/**
	 * From what platform the user is managing Security events
	 */
	platform: string
}
export interface EmailChangeVerificationLinkResent {
	/**
	 * Device type from where the event was triggered.
	 */
	device?: string
	/**
	 * From what platform the user is managing Security events
	 */
	platform: string
}
export interface EmailVerificationRequested {
	/**
	 * Device type from where the event was triggered.
	 */
	device: string
	/**
	 * From what product or flow the request to verify the email was requested. SIGN_UP : just after sign up. VERIFICATION: during a kyc verification process. SECURITY : in the security settings, for example when an email is changed.
	 */
	origin: string
	/**
	 * What platform the email verification was requested from
	 */
	platform: string
}
export interface EmailVerificationSkipped {
	/**
	 * Device type from where the event was triggered.
	 */
	device: string
	/**
	 * From what product or flow the request to verify the email was skipped. SIGN_UP : just after sign up.
	 */
	origin: string
	/**
	 * What platform the email verification was requested from
	 */
	platform: string
}
export interface EmailVerified {
	/**
	 * Was there already a verified email?
	 */
	email_changed: boolean
	/**
	 * What platform the email verification was requested from (if available)
	 */
	platform: string
}
export interface ExchangeHyperlinkClicked {
	''?: Record<string, any>
	/**
	 * Currency symbol for the currency being selected to trade by the user.
	 */
	currency?: string
	/**
	 * What device the event is tracked from
	 */
	device: string
	/**
	 * From which part of the page was the button clicked
	 */
	origin: string
	/**
	 * What platform the event is referring to.
	 */
	platform: string
	/**
	 * Path portion of the URL of the page from where the button is clicked.
  PRICES: from the explorer general price page with all the coins listed. 
 PRICES_CURRENCY : blockchain.com/prices/[currency] : from the explorer price page about a specific crypto. .COM_EXCHANGE :
blockchain.com/exchange. EXPLORER : https://www.blockchain.com/explorer
	 */
	platform_path: string
}
export interface ExchangeSignedUp {
	/**
	 * What device the user created an exchange account from
	 */
	device: string
	/**
	 * What platform the user is creating his exchange account from.
	 */
	platform: string
}
export interface ExplorerSearchClicked {
	/**
	 * What device the event is tracked from
	 */
	device: string
	/**
	 * What platform the user is searching from. For now, on BLOCKCHAIN_COM, the search is on the navigation bar, while on the explorer the search is just below next to the breadcrumb
	 */
	platform: string
}
export interface ExplorerSearchSubmitted {
	/**
	 * What device the event is tracked from
	 */
	device: string
	/**
	 * What platform the user is searching from. For now, on BLOCKCHAIN_COM, the search is on the navigation bar, while on the explorer the search is just below next to the breadcrumb
	 */
	platform: string
}
export interface ExplorerSearchWithNoResults {
	/**
	 * What device the event is tracked from
	 */
	device: string
	/**
	 * What platform the user is searching from. For now, on BLOCKCHAIN_COM, the search is on the navigation bar, while on the explorer the search is just below next to the breadcrumb
	 */
	platform: string
	/**
	 * query with no results
	 */
	search_query: string
}
export interface FiatCurrencySelected {
	/**
	 * What fiat currency was selected
	 */
	currency: string
	/**
	 * Device type from where the event was triggered.
	 */
	device: string
	/**
	 * What platform the page viewed belongs to
	 */
	platform: string
}
export interface FooterOptionClicked {
	/**
	 * What device the event is tracked from
	 */
	device: string
	/**
	 * hyperlink to the app store or google store
	 */
	download_app?: string
	/**
	 * What option was clicked
	 */
	item?: string
	/**
	 * What platform the event is referring to
	 */
	platform: string
	/**
	 * Social media hyperlink clicked
	 */
	social_media?: string
}
export interface HistoryClicked {
	/**
	 * Device type from where the event was triggered.
	 */
	device: string
	/**
	 * What button we are referring to. NAVIGATION : navigation bar
	 */
	origin: string
	/**
	 * What platform the page viewed belongs to
	 */
	platform: string
	/**
	 * what type of history the button will bring the user to.
	 */
	type?: string
}
export interface HistoryViewed {
	/**
	 * Device type from where the event was triggered.
	 */
	device: string
	/**
	 * Path portion of the URL of the page. Equivalent to canonical path which defaults to location.pathname from the DOM API.
	 */
	path?: string
	/**
	 * What platform the page viewed belongs to
	 */
	platform: string
	/**
	 * Full URL of the previous page. Equivalent to document.referrer from the DOM API.
	 */
	referrer?: string
	/**
	 * Query string portion of the URL of the page. Equivalent to location.search from the DOM API.
	 */
	search?: string
	/**
	 * Title of the page. Equivalent to document.title from the DOM API.
	 */
	title?: string
	/**
	 * What type of history is viewed
	 */
	type?: string
	/**
	 * Full URL of the page. First we look for the canonical url. If the canonical url is not provided, we use location.href from the DOM API.
	 */
	url?: string
}
export interface ImportAddressClicked {
	/**
	 * Device type from where the event was triggered.
	 */
	device: string
	/**
	 * From what platform the user is using the Settings
	 */
	platform: string
}
export interface ImportWalletCancelled {
	/**
	 * Device type from where the event was triggered.
	 */
	device: string
	/**
	 * What button we are referring to. CONFIRMATION : "Go Back" In the final confirmation screen after entering a valid passphrase
	 */
	origin: string
	/**
	 * What platform the user is is recovering the account from
	 */
	platform: string
	/**
	 * Whether the user is being redirected to the exchange or wallet
	 */
	site_redirect: string
}
export interface ImportWalletClicked {
	/**
	 * Device type from where the event was triggered.
	 */
	device: string
	/**
	 * What button we are referring to. (mobile) LAUNCH_SCREEN. (web) To Be Determined !
	 */
	origin: string
	/**
	 * What platform the user is is recovering the account from
	 */
	platform: string
	/**
	 * Whether the user is being redirected to the exchange or wallet
	 */
	site_redirect: string
}
export interface ImportWalletConfirmed {
	/**
	 * Device type from where the event was triggered.
	 */
	device: string
	/**
	 * What platform the user is is recovering the account from
	 */
	platform: string
	/**
	 * Whether the user is being redirected to the exchange or wallet
	 */
	site_redirect: string
}
export interface Campaign2 {
	/**
	 * The ad creative name.
	 */
	ad_creative?: string
	/**
	 * The ad group name.
	 */
	ad_group?: string
	/**
	 * The content of the campaign.
	 */
	content?: string
	/**
	 * Identifies what type of link was used.
	 */
	medium?: string
	/**
	 * The name of the attributed campaign.
	 */
	name?: string
	/**
	 * Campaign source — attributed ad network
	 */
	source?: string
}
export interface InstallAttributed {
	campaign?: Campaign2
	/**
	 * Device type from where the event was triggered.
	 */
	device: string
	platform: string
	/**
	 * The attribution provider.
	 */
	provider?: string
}
export interface InterestClicked {
	/**
	 * Device type from where the event was triggered.
	 */
	device: string
	/**
	 * What button we are referring to. NAVIGATION : navigation bar. DASHBOARD_PROMO : announcement card or promo on dashboard.
	 */
	origin: string
	/**
	 * What platform the user is clicking from
	 */
	platform: string
}
export interface InterestDepositAmountEntered {
	/**
	 * If available, what amount in native fiat currency being entered. e.g. 12.23 if 12.23 USD.
	 */
	amount?: number
	/**
	 * If available,, what is the native fiat currency in which the amount is entered. e.g. USD. Empty if amount only entered in BTC terms
	 */
	amount_currency?: string
	/**
	 * The currency the user wants to deposit to their savings account. e.g. BTC
	 */
	currency: string
	/**
	 * Device type from where the event was triggered.
	 */
	device?: string
	/**
	 * From what account the user wants to deposit funds from
	 */
	from_account_type: string
	/**
	 * The amount in crypto currency the user sends to their interest savings account. This amount is before any fees are subtracted.
	 */
	input_amount: number
	/**
	 * What is in the interest rate in percentage being offered. For example, for 4.5%, enter 4.5
	 */
	interest_rate: number | null
	/**
	 * The amount in crypto currency the user will actually get in their interest savings account. This amount is after any fees are subtracted
	 */
	output_amount?: number
	/**
	 * What platform the user wants to deposit funds from
	 */
	platform: string
}
export interface InterestDepositClicked {
	/**
	 * What currency the user is about to deposit to their interest savings account (if known)
	 */
	currency?: string
	/**
	 * Device type from where the event was triggered.
	 */
	device: string
	/**
	 * What button we are referring to. CURRENCY_PAGE : CTA or menu on the coin page next to balance. SAVINGS_PAGE: general interest savings overview page or screen (currently Earn Interest Clicked).  SAVINGS_CONFIRMATION : from the confirmation screen of an interest deposit. SEND : from the send product

	 */
	origin: string
	/**
	 * What platform the user is clicking from
	 */
	platform: string
}
export interface InterestDepositMaxAmountClicked {
	/**
	 * If the button explicitly displays the amount in a specific currency, what is the currency being clicked on for the max amount
	 */
	amount_currency?: string
	/**
	 * The currency the user wants to deposit to their savings account. e.g. BTC
	 */
	currency: string
	/**
	 * Device type from where the event was triggered.
	 */
	device?: string
	/**
	 * From what account the user wants to deposit funds from
	 */
	from_account_type: string
	/**
	 * What platform the user wants to deposit funds from
	 */
	platform: string
}
export interface InterestDepositMinAmountClicked {
	/**
	 * If the button explicitly displays the amount in a specific currency, what is the currency being clicked on for the min amount
	 */
	amount_currency?: string
	/**
	 * The currency the user wants to deposit to their savings account. e.g. BTC
	 */
	currency: string
	/**
	 * Device type from where the event was triggered.
	 */
	device: string
	/**
	 * From what account the user wants to deposit funds from
	 */
	from_account_type: string
	/**
	 * What platform the user wants to deposit funds from
	 */
	platform: string
}
export interface InterestDepositViewed {
	/**
	 * What currency the user is about to deposit to their interest savings account (if known)
	 */
	currency?: string
	/**
	 * Device type from where the event was triggered.
	 */
	device: string
	/**
	 * Path portion of the URL of the page. Equivalent to canonical path which defaults to location.pathname from the DOM API.
	 */
	path?: string
	/**
	 * What platform the page viewed belongs to
	 */
	platform: string
	/**
	 * Full URL of the previous page. Equivalent to document.referrer from the DOM API.
	 */
	referrer?: string
	/**
	 * Query string portion of the URL of the page. Equivalent to location.search from the DOM API.
	 */
	search?: string
	/**
	 * Title of the page. Equivalent to document.title from the DOM API.
	 */
	title?: string
	/**
	 * Full URL of the page. First we look for the canonical url. If the canonical url is not provided, we use location.href from the DOM API.
	 */
	url?: string
}
export interface InterestSubmitInformationClicked {
	/**
	 * Device type from where the event was triggered.
	 */
	device: string
	/**
	 * what button we are referring to.  SAVINGS_PAGE: general interest savings overview page or screen. SAVINGS_CONFIRMATION : SAVINGS_PAGE general interest savings overview page or screen
	 */
	origin: string
	/**
	 * What platform the user wants to submit information from
	 */
	platform: string
}
export interface InterestViewed {
	/**
	 * Device type from where the event was triggered.
	 */
	device: string
	/**
	 * Path portion of the URL of the page. Equivalent to canonical path which defaults to location.pathname from the DOM API.
	 */
	path?: string
	/**
	 * What platform the page viewed belongs to
	 */
	platform: string
	/**
	 * Full URL of the previous page. Equivalent to document.referrer from the DOM API.
	 */
	referrer?: string
	/**
	 * Query string portion of the URL of the page. Equivalent to location.search from the DOM API.
	 */
	search?: string
	/**
	 * Title of the page. Equivalent to document.title from the DOM API.
	 */
	title?: string
	/**
	 * Full URL of the page. First we look for the canonical url. If the canonical url is not provided, we use location.href from the DOM API.
	 */
	url?: string
}
export interface InterestWithdrawalClicked {
	/**
	 * What currency the user is about to withdraw from their interest savings account (if known)
	 */
	currency?: string
	/**
	 * Device type from where the event was triggered.
	 */
	device: string
	/**
	 * What button we are referring to.  CURRENCY_PAGE : CTA or menu on the coin page next to balance. SAVINGS_PAGE: general interest savings overview page or screen
	 */
	origin: string
	/**
	 * What platform the user is clicking from
	 */
	platform: string
}
export interface InterestWithdrawalViewed {
	/**
	 * What currency the user is about to withdraw from their interest savings account (if known)
	 */
	currency?: string
	/**
	 * Device type from where the event was triggered.
	 */
	device: string
	/**
	 * Path portion of the URL of the page. Equivalent to canonical path which defaults to location.pathname from the DOM API.
	 */
	path?: string
	/**
	 * What platform the page viewed belongs to
	 */
	platform: string
	/**
	 * Full URL of the previous page. Equivalent to document.referrer from the DOM API.
	 */
	referrer?: string
	/**
	 * Query string portion of the URL of the page. Equivalent to location.search from the DOM API.
	 */
	search?: string
	/**
	 * Title of the page. Equivalent to document.title from the DOM API.
	 */
	title?: string
	/**
	 * Full URL of the page. First we look for the canonical url. If the canonical url is not provided, we use location.href from the DOM API.
	 */
	url?: string
}
export interface IpWhitelistUpdated {
	/**
	 * Device type from where the event was triggered.
	 */
	device?: string
	/**
	 * True if list is empty
	 */
	is_empty: boolean
	/**
	 * From what platform the user is managing Security events

	 */
	platform: string
}
export interface LanguageSet {
	/**
	 * Device type from where the event was triggered.
	 */
	device?: string
	/**
	 * Language in Alpha-2 code (2 letters lower cases)
	 */
	language: string
	/**
	 * From what platform the user is using the Settings
	 */
	platform: string
}
export interface LeftMenuSelectionClicked {
	/**
	 * What device the event is tracked from
	 */
	device: string
	/**
	 * What item is clicked on the navigation header
	 */
	item: string
	/**
	 * What platform the event is referring to
	 */
	platform: string
}
export interface LegalEntityUpdated {
	/**
	 * What device the user created the account from
	 */
	device: string
	/**
	 * legal entity has been updated to this label
	 */
	legal_entity: string
	/**
	 * the users past legal entity
	 */
	legal_entity_before_update: string
	/**
	 * legal entity to a user has been updated based on this reason.
	 */
	legal_entity_reason: string
	/**
	 * What platform the user signed up for
	 */
	platform: string
}
export interface LinkBankClicked {
	/**
	 * Device type from where the event was triggered.
	 */
	device: string
	/**
	 * What button we are referring to. DEPOSIT : from depositing funds. SETTINGS : user's settings page. BUY : from the Buy flow.  WITHDRAW : from withdrawing funds.
	 */
	origin: string
	/**
	 * What platform the user wants to link a bank for
	 */
	platform: string
}
export interface LinkBankConditionsApproved {
	/**
	 * Bank name, in camel case, for example "Barclays", "Revolut"
	 */
	bank_name: string
	/**
	 * Device type from where the event was triggered.
	 */
	device: string
	/**
	 * What is the bank partner. This will be used to know whether it is ACH or OB
	 */
	partner: string
	/**
	 * What platform the user wants to link a bank for
	 */
	platform: string
	/**
	 * What provider is used to link the bank
	 */
	provider: string
}
export interface LinkBankSelected {
	/**
	 * Bank name, in camel case, for example "Barclays", "Revolut"
	 */
	bank_name: string
	/**
	 * Device type from where the event was triggered.
	 */
	device: string
	/**
	 * What is the bank partner for the account being linked
	 */
	partner: string
	/**
	 * What platform the user wants to link a bank for
	 */
	platform: string
}
export interface LinkCardClicked {
	/**
	 * Device type from where the event was triggered.
	 */
	device: string
	/**
	 * What button we are referring to. SETTINGS : user's settings page. BUY : from the Buy flow.
	 */
	origin: string
	/**
	 * What platform the user wants to link a bank for
	 */
	platform: string
}
export interface LocalCurrencySet {
	/**
	 * What fiat currency
	 */
	currency: string
	/**
	 * Device type from where the event was triggered.
	 */
	device?: string
	/**
	 * From what platform the user is using the Settings
	 */
	platform: string
}
export interface Exchange8 {
	/**
	 * Whether the exchange account has 2FA set up
	 */
	two_fa_mode?: boolean
	/**
	 * Exchange user credentials ID
	 */
	user_id?: string
}
export interface Exchange9 {
	/**
	 * Whether the exchange account has 2FA set up
	 */
	two_fa_mode?: Record<string, any>
	/**
	 * Exchange user credentials ID
	 */
	user_id?: Record<string, any>
}
export interface Nabu4 {
	/**
	 * Whether the nabu user is eligible for recovery. Usually if account has value (> $300 or 1 payment method linked)
	 */
	recovery_eligible?: boolean
	/**
	 * The Nabu User ID. This is from the users table in nabu gateway
	 */
	user_id?: Record<string, any>
}
export interface Wallet4 {
	/**
	 * The wallet 2FA type that is enforced.
	 */
	auth_type?: string
	/**
	 * Parameters about the exchange account
	 */
	exchange?: Exchange9
	/**
	 * The first four characters of the wallet.guid field
	 */
	guid_first_four?: string
	/**
	 * Whether the wallet has cloud backups
	 */
	has_cloud_backup?: boolean
	/**
	 * Whether the wallet has a mobile client set up
	 */
	is_mobile_setup?: boolean
	/**
	 * The last time, in unix timestamp, in which a wallet has their mnemonic backup verified
	 */
	last_mnemonic_backup?: number
	/**
	 * The type of device being verified
	 */
	mobile_device_type?: string
	/**
	 * Parameter about the nabu account
	 */
	nabu?: Nabu4
}
export interface LoginClicked {
	/**
	 * Device from which the user is signing in
	 */
	device: string
	/**
	 * Parameters about the exchange account
	 */
	exchange?: Exchange8
	/**
	 * Indicates if possible to merge two unlinked accounts
	 */
	mergeable?: boolean
	/**
	 * What button we are referring to. 
GUEST_LIMITATION (exchange): A specific action from the guest view requires login. HOMEPAGE (dotcom) : from the Blockchain.com or Exchange.blockchain.com home page content. LAUNCH_SCREEN (mobile only) : when login from the launch screen. NAVIGATION (dotcom) : navigation bar. RECOVERY_CLOUD_BACKUP (wallet) : when failing to scan QR code cloud backup and clicking on login. 
	 */
	origin: string
	/**
	 * Platform from which the user is signing in
	 */
	platform: string
	/**
	 * Whether the user is being redirected to the exchange or wallet
	 */
	site_redirect?: string
	/**
	 * Indicates if possible to “upgrade” to a new unified Blockchain.com Account
	 */
	upgradeable?: boolean
	/**
	 * Parameters about the wallet account
	 */
	wallet?: Wallet4
}
export interface Exchange10 {
	/**
	 * Whether the exchange account has 2FA set up
	 */
	two_fa_mode?: boolean
	/**
	 * Exchange user credentials ID
	 */
	user_id?: string
}
export interface Exchange11 {
	/**
	 * Whether the exchange account has 2FA set up
	 */
	two_fa_mode?: Record<string, any>
	/**
	 * Exchange user credentials ID
	 */
	user_id?: Record<string, any>
}
export interface Nabu5 {
	/**
	 * Whether the nabu user is eligible for recovery. Usually if account has value (> $300 or 1 payment method linked)
	 */
	recovery_eligible?: boolean
	/**
	 * The Nabu User ID. This is from the users table in nabu gateway
	 */
	user_id?: Record<string, any>
}
export interface Wallet5 {
	/**
	 * The wallet 2FA type that is enforced.
	 */
	auth_type?: string
	/**
	 * Parameters about the exchange account
	 */
	exchange?: Exchange11
	/**
	 * The first four characters of the wallet.guid field
	 */
	guid_first_four?: string
	/**
	 * Whether the wallet has cloud backups
	 */
	has_cloud_backup?: boolean
	/**
	 * Whether the wallet has a mobile client set up
	 */
	is_mobile_setup?: boolean
	/**
	 * The last time, in unix timestamp, in which a wallet has their mnemonic backup verified
	 */
	last_mnemonic_backup?: number
	/**
	 * The type of device being verified
	 */
	mobile_device_type?: string
	/**
	 * Parameter about the nabu account
	 */
	nabu?: Nabu5
}
export interface LoginHelpClicked {
	/**
	 * What device the user is login in from
	 */
	device: string
	/**
	 * Parameters about the exchange account
	 */
	exchange?: Exchange10
	/**
	 * Indicates if possible to merge two unlinked accounts
	 */
	mergeable?: boolean
	/**
	 * what button we are referring to. IDENTIFIER : when failing to provide an identifier. PASSWORD: when failing to provide a correct password. QR_CODE : when failing to scan QR code.
	 */
	origin: string
	/**
	 * Platform from which the user is signing in
	 */
	platform: string
	/**
	 * Whether the user is being redirected to the exchange or wallet
	 */
	site_redirect?: string
	/**
	 * Indicates if possible to “upgrade” to a new unified Blockchain.com Account
	 */
	upgradeable?: boolean
	/**
	 * Parameters about the wallet account
	 */
	wallet?: Wallet5
}
export interface Exchange12 {
	/**
	 * Whether the exchange account has 2FA set up
	 */
	two_fa_mode?: boolean
	/**
	 * Exchange user credentials ID
	 */
	user_id?: string
}
export interface Exchange13 {
	/**
	 * Whether the exchange account has 2FA set up
	 */
	two_fa_mode?: Record<string, any>
	/**
	 * Exchange user credentials ID
	 */
	user_id?: Record<string, any>
}
export interface Nabu6 {
	/**
	 * Whether the nabu user is eligible for recovery. Usually if account has value (> $300 or 1 payment method linked)
	 */
	recovery_eligible?: boolean
	/**
	 * The Nabu User ID. This is from the users table in nabu gateway
	 */
	user_id?: Record<string, any>
}
export interface Wallet6 {
	/**
	 * The wallet 2FA type that is enforced.
	 */
	auth_type?: string
	/**
	 * Parameters about the exchange account
	 */
	exchange?: Exchange13
	/**
	 * The first four characters of the wallet.guid field
	 */
	guid_first_four?: string
	/**
	 * Whether the wallet has cloud backups
	 */
	has_cloud_backup?: boolean
	/**
	 * Whether the wallet has a mobile client set up
	 */
	is_mobile_setup?: boolean
	/**
	 * The last time, in unix timestamp, in which a wallet has their mnemonic backup verified
	 */
	last_mnemonic_backup?: number
	/**
	 * The type of device being verified
	 */
	mobile_device_type?: string
	/**
	 * Parameter about the nabu account
	 */
	nabu?: Nabu6
}
export interface LoginIdentifierEntered {
	/**
	 * What device you are viewing the login screen from
	 */
	device: string
	/**
	 * Parameters about the exchange account
	 */
	exchange?: Exchange12
	/**
	 * What type of identifier is supplied
	 */
	identifier_type?: string
	/**
	 * Indicates if possible to merge two unlinked accounts
	 */
	mergeable?: boolean
	/**
	 * Platform from which the user is signing in
	 */
	platform: string
	/**
	 * Whether the user is being redirected to the exchange or wallet
	 */
	site_redirect?: string
	/**
	 * Indicates if possible to “upgrade” to a new unified Blockchain.com Account
	 */
	upgradeable?: boolean
	/**
	 * Parameters about the wallet account
	 */
	wallet?: Wallet6
}
export interface LoginIpRestrictionUpdated {
	/**
	 * Device type from where the event was triggered.
	 */
	device?: string
	/**
	 * True if only allowing login from IP addresses whitelist.
	 */
	is_restricted: boolean
	/**
	 * From what platform the user is managing Security events

	 */
	platform: string
}
export interface Exchange14 {
	/**
	 * Whether the exchange account has 2FA set up
	 */
	two_fa_mode?: boolean
	/**
	 * Exchange user credentials ID
	 */
	user_id?: string
}
export interface Exchange15 {
	/**
	 * Whether the exchange account has 2FA set up
	 */
	two_fa_mode?: Record<string, any>
	/**
	 * Exchange user credentials ID
	 */
	user_id?: Record<string, any>
}
export interface Nabu7 {
	/**
	 * Whether the nabu user is eligible for recovery. Usually if account has value (> $300 or 1 payment method linked)
	 */
	recovery_eligible?: boolean
	/**
	 * The Nabu User ID. This is from the users table in nabu gateway
	 */
	user_id?: Record<string, any>
}
export interface Wallet7 {
	/**
	 * The wallet 2FA type that is enforced.
	 */
	auth_type?: string
	/**
	 * Parameters about the exchange account
	 */
	exchange?: Exchange15
	/**
	 * The first four characters of the wallet.guid field
	 */
	guid_first_four?: string
	/**
	 * Whether the wallet has cloud backups
	 */
	has_cloud_backup?: boolean
	/**
	 * Whether the wallet has a mobile client set up
	 */
	is_mobile_setup?: boolean
	/**
	 * The last time, in unix timestamp, in which a wallet has their mnemonic backup verified
	 */
	last_mnemonic_backup?: number
	/**
	 * The type of device being verified
	 */
	mobile_device_type?: string
	/**
	 * Parameter about the nabu account
	 */
	nabu?: Nabu7
}
export interface LoginMethodSelected {
	/**
	 * What device you are viewing the login screen from
	 */
	device: string
	/**
	 * Parameters about the exchange account
	 */
	exchange?: Exchange14
	/**
	 * How the user is trying to log in. APPLE: via Apple ID. GOOGLE : via Google Account. PASSWORD : with a password on mobile or web, PIN : with a PIN on mobile,  SECURE_CHANNEL : by sending a log in request via secure channel to another client.
	 */
	login_method: string
	/**
	 * Indicates if possible to merge two unlinked accounts
	 */
	mergeable?: boolean
	/**
	 * Platform from which the user is signing in
	 */
	platform: string
	/**
	 * Whether the user is being redirected to the exchange or wallet
	 */
	site_redirect?: string
	/**
	 * Indicates if possible to “upgrade” to a new unified Blockchain.com Account
	 */
	upgradeable?: boolean
	/**
	 * Parameters about the wallet account
	 */
	wallet?: Wallet7
}
export interface LoginRequestApproved {
	/**
	 * Device type from where the login request is approved
	 */
	device: string
	/**
	 * Whether the request is being approved from the WALLET or the EXCHANGE. Only possible from the WALLET for now
	 */
	platform: string
	/**
	 * The browser being displayed to the user. This is the browser from where the request was sent.
	 */
	request_browser?: string
	/**
	 * Parsed IP Geolocation displayed to the user. This is the ip from where the request was sent. country format TBD : ideally alpha 2 iso code
	 */
	request_location_country?: string
	/**
	 * The channel opening requester platform (exchange/wallet)
	 */
	request_platform: string
}
export interface LoginRequestDenied {
	/**
	 * Device type from where the login request is denied
	 */
	device: string
	/**
	 * The error that was experienced by the user
	 */
	error?: string | null
	/**
	 * Whether the rejection came for a secure channel opening request OR for a log in with magic link request.
	 */
	method?: string
	/**
	 * Whether the request is being denied from the WALLET or the EXCHANGE. Only possible from the WALLET for now
	 */
	platform: string
	/**
	 * The browser being displayed to the user. This is the browser from where the request was sent.
	 */
	request_browser?: string
	/**
	 * Parsed IP Geolocation displayed to the user. This is the ip from where the request was sent. country format TBD : ideally alpha 2 iso code
	 */
	request_location_country?: string
	/**
	 * Whether the log in request was sent to log in to the WALLET or the. EXCHANGE.
	 */
	request_platform: string
}
export interface Exchange16 {
	/**
	 * Whether the exchange account has 2FA set up
	 */
	two_fa_mode?: boolean
	/**
	 * Exchange user credentials ID
	 */
	user_id?: string
}
export interface Exchange17 {
	/**
	 * Whether the exchange account has 2FA set up
	 */
	two_fa_mode?: Record<string, any>
	/**
	 * Exchange user credentials ID
	 */
	user_id?: Record<string, any>
}
export interface Nabu8 {
	/**
	 * Whether the nabu user is eligible for recovery. Usually if account has value (> $300 or 1 payment method linked)
	 */
	recovery_eligible?: boolean
	/**
	 * The Nabu User ID. This is from the users table in nabu gateway
	 */
	user_id?: Record<string, any>
}
export interface Wallet8 {
	/**
	 * The wallet 2FA type that is enforced.
	 */
	auth_type?: string
	/**
	 * Parameters about the exchange account
	 */
	exchange?: Exchange17
	/**
	 * The first four characters of the wallet.guid field
	 */
	guid_first_four?: string
	/**
	 * Whether the wallet has cloud backups
	 */
	has_cloud_backup?: boolean
	/**
	 * Whether the wallet has a mobile client set up
	 */
	is_mobile_setup?: boolean
	/**
	 * The last time, in unix timestamp, in which a wallet has their mnemonic backup verified
	 */
	last_mnemonic_backup?: number
	/**
	 * The type of device being verified
	 */
	mobile_device_type?: string
	/**
	 * Parameter about the nabu account
	 */
	nabu?: Nabu8
}
export interface LoginTwoStepVerificationDenied {
	/**
	 * Device type from where the user is trying to log in
	 */
	device: string
	/**
	 * Parameters about the exchange account
	 */
	exchange?: Exchange16
	/**
	 * Indicates if possible to merge two unlinked accounts
	 */
	mergeable?: boolean
	/**
	 * Platform from which the user is signing in
	 */
	platform: string
	/**
	 * Whether the user is being redirected to the exchange or wallet
	 */
	site_redirect?: string
	/**
	 * Indicates if possible to “upgrade” to a new unified Blockchain.com Account
	 */
	upgradeable?: boolean
	/**
	 * Parameters about the wallet account
	 */
	wallet?: Wallet8
}
export interface Exchange18 {
	/**
	 * Whether the exchange account has 2FA set up
	 */
	two_fa_mode?: boolean
	/**
	 * Exchange user credentials ID
	 */
	user_id?: string
}
export interface Exchange19 {
	/**
	 * Whether the exchange account has 2FA set up
	 */
	two_fa_mode?: Record<string, any>
	/**
	 * Exchange user credentials ID
	 */
	user_id?: Record<string, any>
}
export interface Nabu9 {
	/**
	 * Whether the nabu user is eligible for recovery. Usually if account has value (> $300 or 1 payment method linked)
	 */
	recovery_eligible?: boolean
	/**
	 * The Nabu User ID. This is from the users table in nabu gateway
	 */
	user_id?: Record<string, any>
}
export interface Wallet9 {
	/**
	 * The wallet 2FA type that is enforced.
	 */
	auth_type?: string
	/**
	 * Parameters about the exchange account
	 */
	exchange?: Exchange19
	/**
	 * The first four characters of the wallet.guid field
	 */
	guid_first_four?: string
	/**
	 * Whether the wallet has cloud backups
	 */
	has_cloud_backup?: boolean
	/**
	 * Whether the wallet has a mobile client set up
	 */
	is_mobile_setup?: boolean
	/**
	 * The last time, in unix timestamp, in which a wallet has their mnemonic backup verified
	 */
	last_mnemonic_backup?: number
	/**
	 * The type of device being verified
	 */
	mobile_device_type?: string
	/**
	 * Parameter about the nabu account
	 */
	nabu?: Nabu9
}
export interface LoginTwoStepVerificationEntered {
	/**
	 * Device type from where the user is trying to log in
	 */
	device: string
	/**
	 * Parameters about the exchange account
	 */
	exchange?: Exchange18
	/**
	 * Indicates if possible to merge two unlinked accounts
	 */
	mergeable?: boolean
	/**
	 * Platform from which the user is signing in
	 */
	platform: string
	/**
	 * Whether the user is being redirected to the exchange or wallet
	 */
	site_redirect?: string
	/**
	 * Indicates if possible to “upgrade” to a new unified Blockchain.com Account
	 */
	upgradeable?: boolean
	/**
	 * Parameters about the wallet account
	 */
	wallet?: Wallet9
}
export interface LogoClicked {
	/**
	 * Device type from where the event was triggered.
	 */
	device: string
	/**
	 * What platform the user is clicking from
	 */
	platform: string
}
export interface ManageTabSelectionClicked {
	/**
	 * From which currency tab was the event activated. BTC or BCH
	 */
	currency: string
	/**
	 * Device type from where the event was triggered.
	 */
	device: string
	/**
	 * From what platform the user is using the Settings
	 */
	platform: string
	/**
	 * Example: "Show xPub".  Note: "Recover Funds" option only available for Bitcoin Cash drop down menu.
	 */
	selection: string
}
export interface ManualVerificationRequired {
	/**
	 * What platform the verification was started from. (WALLET if product=SWAP and EXCHANGE if product=MERCURY in the  kyc verification table from nabu gateway)
	 */
	platform: string
	/**
	 * BLOCKCHAIN or VERIFF
	 */
	provider: string
	/**
	 * What tier the user is trying to update to. 1 = Silver, 2 = Gold, 3 = SDD, 4 = SDD +, 5 = Platinium
	 */
	tier: number
}
export interface MarginCollateralClicked {
	/**
	 * From what device the user is adding collateral
	 */
	device?: string
	/**
	 * What is the trading pair of the position
	 */
	pair: string
	/**
	 * From what platform the user is adding collateral
	 */
	platform: string
	/**
	 * Id of the margin position for which the collateral is being added/removed
	 */
	position_id?: string
}
export interface MarginCollateralUpdated {
	/**
	 * Whether add or remove collateral
	 */
	action: string
	/**
	 * The amount of collateral to be added or removed.
	 */
	amount: number
	/**
	 * what collateral currency the user is adding or removing
	 */
	currency: string
	/**
	 * From what device the user is adding collateral
	 */
	device?: string
	/**
	 * Id of the gateway order created to add/remove the collateral
	 */
	gw_order_id?: string
	/**
	 * What is the trading pair of the position
	 */
	pair: string
	/**
	 * From what platform the user is adding collateral
	 */
	platform: string
	/**
	 * Id of the position for which the collateral is being added/removed
	 */
	position_id?: string
}
export interface MarginOrderCancelled {
	/**
	 * The amount of the order.
	 */
	amount: number
	/**
	 * Device type from where the event was triggered
	 */
	device: string
	/**
	 * What is the trading pair of the position
	 */
	pair: string
	/**
	 * From what platform the event is triggered

	 */
	platform: string
	/**
	 * what type of trade
	 */
	trade_type: string
}
export interface MarginOrderSubmitted {
	/**
	 * What device the user is using. Only available for WEB for now.
	 */
	device: string
	/**
	 * Amount of the trade in input currency
	 */
	input_amount: number
	/**
	 * leverage ratio
	 */
	leverage_ratio: number
	/**
	 * Limit price of the trade (empty for market orders)

	 */
	limit_price?: number
	/**
	 * The trading instrument
	 */
	pair: string
	/**
	 * What platform offers leverage (EXCHANGE only for now)
	 */
	platform: string
	/**
	 * What side is selected when the leverage button is clicked. BUY when it says "Buy With Leverage" and SELL when it says "Sell With Leverage"
	 */
	side: string
	/**
	 * what type of trade
	 */
	trade_type: string
}
export interface MarginPositionClosed {
	/**
	 * The amount of the order placed to close a margin position.
	 */
	amount: number
	/**
	 * From what device the user is adding collateral
	 */
	device?: string
	/**
	 * The limit price when the position closes with a limit order.
	 */
	limit_price?: number
	/**
	 * The type of the order placed to close a margin position.
	 */
	order_type: string
	/**
	 * From what platform the user is adding collateral
	 */
	platform: string
	/**
	 * Id of the margin position for which the collateral is being added/removed
	 */
	position_id?: Record<string, any>
}
export interface MarginWaitlistActioned {
	/**
	 * What action the user performed when shown the Margin waitlist announcement. JOINED : Clicked on a button to join. DISMISSED : clicked anywhere else on the screen or clicks on the small cross to close the announcement
	 */
	action: string
	/**
	 * What device is used to action on the announcement
	 */
	device: string
	/**
	 * What platform the user is on : EXCHANGE
	 */
	platform: string
}
export interface MarginWaitlistShown {
	/**
	 * What device the announcement is shown on
	 */
	device: string
	/**
	 * What platform the user is on : EXCHANGE
	 */
	platform: string
}
export interface MobileAppInstallDeviceUpdated {
	/**
	 * Device type from where the event was triggered.
	 */
	device: string
	/**
	 * Whether the device was updated to view APP-Android or APP-iOS instructions
	 */
	device_app: string
	/**
	 * What platform the user is clicking from
	 */
	platform: string
}
export interface MobileAppInstallIconClicked {
	/**
	 * Device type from where the event was triggered.
	 */
	device: string
	/**
	 * What platform the user is clicking from
	 */
	platform: string
}
export interface MobileAppInstallLinkCopied {
	/**
	 * Device type from where the event was triggered.
	 */
	device: string
	/**
	 * Whether the copied app link is APP-iOS or APP-Android
	 */
	device_app: string
	/**
	 * What platform the user is clicking from
	 */
	platform: string
}
export interface MobileNumberVerified {
	/**
	 * country of the mobile number, in alpha iso 2 code.
	 */
	country_code: string
	/**
	 * Device type from where the event was triggered.
	 */
	device?: string
	/**
	 * From which page are they verifying the Mobile Number? Settings or Security
	 */
	origin: string
	/**
	 * From what platform the user is using the Settings
	 */
	platform: string
}
export interface MobilePinCodeChanged {
	/**
	 * Device type from where the event was triggered.
	 */
	device: string
	/**
	 * From what platform the user is managing Security events
	 */
	platform: string
}
export interface MoreNftClicked {
	''?: Record<string, any>
	/**
	 * What device the event is tracked from
	 */
	device: string
	/**
	 * What platform the event is referring to
	 */
	platform: string
}
export interface NftHyperlinkClicked {
	''?: Record<string, any>
	/**
	 * What device the event is tracked from
	 */
	device: string
	/**
	 * What item is clicked on the navigation header
	 */
	item: string
	/**
	 * What platform the event is referring to
	 */
	platform: string
}
export interface NftOrderCreated {
	/**
	 * What device the nft order
	 */
	device: string
	/**
	 * what platform the nft order was from. Only in WALLET
	 */
	platform: string
}
export interface NftOrderFailed {
	/**
	 * What device the nft order
	 */
	device: string
	/**
	 * what platform the nft order was from. Only in WALLET
	 */
	platform: string
}
export interface NftOrderSucceeded {
	/**
	 * What device the nft order
	 */
	device: string
	/**
	 * what platform the nft order was from. Only in WALLET
	 */
	platform: string
}
export interface NavigationBreadcrumbsClicked {
	/**
	 * What device the event is tracked from
	 */
	device: string
	/**
	 * What item is clicked on the navigation header
	 */
	item: string
	/**
	 * What platform the event is referring to
	 */
	platform: string
	/**
	 * What sub item in the breadcrumb is clicked on. NONE if the user clicks on the first level item
	 */
	sub_item: string
}
export interface NavigationOptionClicked {
	/**
	 * What device the event is tracked from
	 */
	device: string
	/**
	 * What item is clicked on the navigation header. Explorer: NONE since it has only one level (old navigation bar). Wallet: OVERVIEW, KEYS, SECURITY. Exchange: FEATURES, FEES, MARKETS, PRIME, AFFILIATE, API
	 */
	item?: string
	/**
	 * What platform the event is referring to
	 */
	platform: string
	/**
	 * What sub item in the dropdown menu was clicked
	 */
	sub_item?: string
}
export interface NextAddressAdded {
	currency: string
	/**
	 * Device type from where the event was triggered.
	 */
	device?: string
	/**
	 * From what platform the user is using the Settings
	 */
	platform: string
	/**
	 * Segwit format or Legacy format
	 */
	transaction_format: string
}
export interface NotificationPreferencesUpdated {
	/**
	 * Device type from where the event was triggered.
	 */
	device: string
	/**
	 * Whether email notifications is enabled (Only available on WEB)
	 */
	email_enabled?: boolean
	/**
	 * From what platform the user is using the Settings
	 */
	platform: string
	/**
	 * Whether sms notifications is enabled
	 */
	sms_enabled?: boolean
}
export interface SearchParams {
	/**
	 * unix timestamp used for custom date range in the prices/currency page
	 */
	from?: string
	/**
	 * linear scale (default) = 0. logarithmic= 1
	 */
	scale?: number
	/**
	 * chart style LINE (default) or CANDELSTICK used in the prices/currency page
	 */
	style?: string
	/**
	 * days parameter used in the prices/currency page
	 */
	timeSpan?: number
	/**
	 * unix timestamp used for custom date range in the prices/currency page
	 */
	to?: string
	/**
	 * utm parameter
	 */
	utm_campaign?: string
	/**
	 * which blockchain network is being requested in the home page
	 */
	view?: string
	/**
	 * show volume on used in the prices/currency page
	 */
	volume?: boolean
}
export interface UrlPaths {
	''?: Record<string, any>
	/**
	 * block hash
	 */
	block?: string
	/**
	 * which chart was selected from the charts page. example: transactions-per-second
	 */
	chart?: string
	/**
	 * Currency symbol for the currency being requested in the prices page by the user. For example USDT

	 */
	currency?: string
	/**
	 * which blockchain network is being requested in tx or block page
	 */
	network?: string
	/**
	 * tx hash
	 */
	tx?: string
}
export interface PageViewed {
	/**
	 * What device the page is viewed from
	 */
	device: string
	/**
	 * Path portion of the URL of the page. Equivalent to canonical path which defaults to location.pathname from the DOM API.
	 */
	path?: string
	/**
	 * What platform the page viewed belongs to
	 */
	platform: string
	/**
	 * Full URL of the previous page. Equivalent to document.referrer from the DOM API.
	 */
	referrer?: string
	/**
	 * Query string portion of the URL of the page. Equivalent to location.search from the DOM API.
	 */
	search?: string
	/**
	 * parameters passed in the link
	 */
	search_params?: SearchParams
	/**
	 * Title of the page. Equivalent to document.title from the DOM API.
	 */
	title?: string
	/**
	 * Full URL of the page. First we look for the canonical url. If the canonical url is not provided, we use location.href from the DOM API.
	 */
	url?: string
	/**
	 * example: blockchain.com/btc/tx/hash  paths: currency:btc tx:hash
	 */
	url_paths?: UrlPaths
}
export interface PasswordStretchingChanged {
	/**
	 * Device type from where the event was triggered.
	 */
	device?: string
	/**
	 * PBKDF2 must be between 1 and 20000
	 */
	pbkdf2: number
	/**
	 * From what platform the user is managing Security events

	 */
	platform: string
}
export interface PaymentRuleExecuted {
	/**
	 * The decision of the rule
	 */
	decision: string
	/**
	 * Device type from where the event was triggered.
	 */
	device?: string
	/**
	 * id of the payment (id of the transaction from nabu payments)
	 */
	payment_id: string
	/**
	 * The type of payment. (type column from the transaction table in nabu payments db)
	 */
	payment_type: string
	/**
	 * What platform the event was started from. (WALLET if product=SIMPLEBUY and EXCHANGE if product=MERCURY
	 */
	platfrom: string
	/**
	 * Product for which the payment was made for
	 */
	product?: string
	/**
	 * The rule
	 */
	rule_type: string
}
export interface PaymentStateTriggered {
	/**
	 * Amount (in "currency") being deposited by the user, usually as a float. For BTC, it should be for example 1.23, meaning 1.23 BTC
	 */
	amount: number
	/**
	 * Amount in USD deposited by the user.
	 */
	amount_usd?: number
	/**
	 * Currency being deposited by the user
	 */
	currency?: string
	/**
	 * Device type from where the event was triggered.
	 */
	device?: string
	/**
	 * if failed, Why the payment failed
	 */
	failure_reason?: string | null
	/**
	 * Fee (in "currency") being charged for the payment.
	 */
	fee_amount?: number
	/**
	 * Fee in USD being charged for the payment
	 */
	fee_amount_usd: number
	/**
	 * It is the name of the bank the user has used for the payment. Used specifically with open banking for now
	 */
	institution_name?: string
	/**
	 * Payment partner. For example HWS, LHV, EVERYPAY
	 */
	partner: string
	/**
	 * id of the payment (id of the transaction from nabu payments)
	 */
	payment_id: string
	/**
	 * The type of payment. (type column from the transaction table in nabu payments db)
	 */
	payment_type: string
	/**
	 * What platform the event was started from. (WALLET if product=SIMPLEBUY and EXCHANGE if product=MERCURY
	 */
	platform: string
	/**
	 * The processing account used for the card payment
	 */
	processing_account?: string
	/**
	 * Product for which the payment was made for
	 */
	product: string
	/**
	 * Payment status. ideal for tracking status transition timings.
	 */
	state: string
}
export interface PeeksheetDismissed {
	/**
	 * what is the current completed step of the user. 0 = verification pending, 1 = payment method pending or 2 = Buy never started
	 */
	current_step_completed: string
	/**
	 * Device type from where the Peeksheet was dismissed.
	 */
	device: string
	/**
	 * What platform the Peeksheet was dismissed
	 */
	platform: string
}
export interface PeeksheetProcessClicked {
	/**
	 * what is the current completed step of the user. 0 = verification pending, 1 = payment method pending or 2 = Buy never started
	 */
	current_step_completed: string
	/**
	 * Device type from where the Peeksheet was shown.
	 */
	device: string
	/**
	 * What platform the Peeksheet was displayed
	 */
	platform: string
}
export interface PeeksheetSelectionClicked {
	/**
	 * True if selection was clicking the main button, False if selection was made from the three items (center)
	 */
	button_clicked: boolean
	/**
	 * what is the current completed step of the user. 0 = verification pending, 1 = payment method pending or 2 = Buy never started
	 */
	current_step_completed: string
	/**
	 * Device type from which the selection was clicked
	 */
	device: string
	/**
	 * Peek sheet item selected
	 */
	item: string
	/**
	 * What platform the Peeksheet selection was clicked
	 */
	platform: string
}
export interface PeeksheetViewed {
	/**
	 * what is the current completed step of the user. 0 = verification pending, 1 = payment method pending or 2 = Buy never started
	 */
	current_step_completed: string
	/**
	 * Device type from where the Peeksheet was shown.
	 */
	device: string
	/**
	 * What platform the Peeksheet was displayed
	 */
	platform: string
}
export interface PersonalInformationEntered {
	/**
	 * Device type from where the event was triggered.
	 */
	device: string
	/**
	 * What platform the user is entering PII from
	 */
	platform: string
}
export interface PortfolioClicked {
	/**
	 * Device type from where the event was triggered.
	 */
	device: string
	/**
	 * what button we are referring to. BALANCE : next to the balance (total account value) info on the main trading page. NAVIGATION (mobile only) : navigation bar.
	 */
	origin: string
	/**
	 * What platform the user is clicking from
	 */
	platform: string
}
export interface PortfolioViewed {
	/**
	 * Device type from where the event was triggered.
	 */
	device: string
	/**
	 * Path portion of the URL of the page. Equivalent to canonical path which defaults to location.pathname from the DOM API.
	 */
	path?: string
	/**
	 * What platform the page viewed belongs to
	 */
	platform: string
	/**
	 * Full URL of the previous page. Equivalent to document.referrer from the DOM API.
	 */
	referrer?: string
	/**
	 * Query string portion of the URL of the page. Equivalent to location.search from the DOM API.
	 */
	search?: string
	/**
	 * Title of the page. Equivalent to document.title from the DOM API.
	 */
	title?: string
	/**
	 * Full URL of the page. First we look for the canonical url. If the canonical url is not provided, we use location.href from the DOM API.
	 */
	url?: string
}
export interface PrivateKeysShown {
	/**
	 * current cryptocurrency information being showed by the user. (Ethereum or Stellar for now) Example: ETH for Ethereum.
	 */
	currency?: string
	/**
	 * Device type from where the event was triggered.
	 */
	device: string
	/**
	 * From what platform the user is using the Settings
	 */
	platform: string
}
export interface Campaign3 {
	/**
	 * Push notification content.
	 */
	content?: string
	/**
	 * Identifies what type of link was used (Push Notification).
	 */
	medium?: string
	/**
	 * The name of the attributed campaign.
	 */
	name?: string
	/**
	 * Designates the push provider.
	 */
	source?: string
}
export interface PushNotificationBounced {
	campaign?: Campaign3
	/**
	 * Device type from where the event was triggered.
	 */
	device: string
	platform: string
}
export interface Campaign4 {
	/**
	 * Push notification content.
	 */
	content?: string
	/**
	 * Identifies what type of link was used (Push Notification).

	 */
	medium?: string
	/**
	 * The name of the attributed campaign.
	 */
	name?: string
	/**
	 * Designates the push provider.
	 */
	source?: string
}
export interface PushNotificationReceived {
	campaign?: Campaign4
	/**
	 * Device type from where the event was triggered.
	 */
	device: string
	platform: string
}
export interface PushNotificationSent {
	/**
	 * Device type from where the event was triggered.
	 */
	device: string
	name?: string
	platform: string
}
export interface Campaign5 {
	/**
	 * Push notification content.
	 */
	content?: string
	/**
	 * Identifies what type of link was used (Push Notification).

	 */
	medium?: string
	/**
	 * The name of the attributed campaign.
	 */
	name?: string
	/**
	 * Designates the push provider.
	 */
	source?: string
}
export interface PushNotificationTapped {
	campaign?: Campaign5
	/**
	 * Device type from where the event was triggered.
	 */
	device: string
	platform: string
}
export interface QrCodeClicked {
	/**
	 * Device the user clicked the QR code from
	 */
	device: string
	/**
	 * What button we are referring to. DASHBOARD : from the Home (=DASHBOARD) page
	 */
	origin: string
	/**
	 * Platform the user is using wallet connect from. Currently it will be only available from the WALLET
	 */
	platform: string
}
export interface QrCodeScanned {
	/**
	 * Device the user user is using wallet connect from
	 */
	device: string
	/**
	 * Platform the user is using wallet connect from. Currently it will be only available from the WALLET
	 */
	platform: string
	/**
	 * What type of QR code is scanned, if it is valid. INVALID : the qr_code scanned is not valid. CRYPTO_ADDRESS : address of a crypto currency to send funds to (CryptoTarget in iOS). DAPP : to connect to a dapp with Wallet Connect. DEEPLINK: when scanning a deeplink. LOG_IN : when opening a secure channel to log in via sso
	 */
	qr_type?: string
}
export interface ReceiveCurrencySelected {
	/**
	 * To what type of account the user wants to receive funds to. 
SAVINGS is the interest saving account. 
TRADING is the wallet custodial wallet. 
USERKEY is the Non Custodial, Private Key, wallet
	 */
	account_type: string
	/**
	 * The currency the user wants to receive (e.g. BTC)
	 */
	currency: string
	/**
	 * Device type from where the event was triggered.
	 */
	device: string
	/**
	 * What platform the user wants to receive funds to
	 */
	platform: string
}
export interface ReceiveDetailsCopied {
	/**
	 * To what type of account the user wants to receive funds to. 
SAVINGS is the interest saving account. 
TRADING is the wallet custodial wallet. 
USERKEY is the Non Custodial, Private Key, wallet
	 */
	account_type: string
	/**
	 * The currency the user wants to receive (e.g. BTC)
	 */
	currency: string
	/**
	 * Device type from where the event was triggered.
	 */
	device: string
	/**
	 * What platform the user wants to receive funds to
	 */
	platform: string
}
export interface RecoveryPhraseBackedUp {
	/**
	 * Device type from where the event was triggered.
	 */
	device?: string
	/**
	 * From what platform the user is managing Security events
	 */
	platform: string
}
export interface Exchange20 {
	/**
	 * Whether the exchange account has 2FA set up
	 */
	two_fa_mode?: boolean
	/**
	 * Exchange user credentials ID
	 */
	user_id?: string
}
export interface Exchange21 {
	/**
	 * Whether the exchange account has 2FA set up
	 */
	two_fa_mode?: Record<string, any>
	/**
	 * Exchange user credentials ID
	 */
	user_id?: Record<string, any>
}
export interface Nabu10 {
	/**
	 * Whether the nabu user is eligible for recovery. Usually if account has value (> $300 or 1 payment method linked)
	 */
	recovery_eligible?: boolean
	/**
	 * The Nabu User ID. This is from the users table in nabu gateway
	 */
	user_id?: Record<string, any>
}
export interface Wallet10 {
	/**
	 * The wallet 2FA type that is enforced.
	 */
	auth_type?: string
	/**
	 * Parameters about the exchange account
	 */
	exchange?: Exchange21
	/**
	 * The first four characters of the wallet.guid field
	 */
	guid_first_four?: string
	/**
	 * Whether the wallet has cloud backups
	 */
	has_cloud_backup?: boolean
	/**
	 * Whether the wallet has a mobile client set up
	 */
	is_mobile_setup?: boolean
	/**
	 * The last time, in unix timestamp, in which a wallet has their mnemonic backup verified
	 */
	last_mnemonic_backup?: number
	/**
	 * The type of device being verified
	 */
	mobile_device_type?: string
	/**
	 * Parameter about the nabu account
	 */
	nabu?: Nabu10
}
export interface RecoveryPhraseEntered {
	/**
	 * Device type from where the event was triggered.
	 */
	device: string
	/**
	 * Parameters about the exchange account
	 */
	exchange?: Exchange20
	/**
	 * Indicates if possible to merge two unlinked accounts
	 */
	mergeable?: boolean
	/**
	 * What platform the user is is recovering the account from
	 */
	platform: string
	/**
	 * Whether the user is being redirected to the exchange or wallet
	 */
	site_redirect: string
	/**
	 * Indicates if possible to upgrade to a new unified Blockchain.com Account
	 */
	upgradeable?: boolean
	/**
	 * Parameters about the wallet account
	 */
	wallet?: Wallet10
}
export interface RecoveryPhraseShown {
	/**
	 * Device type from where the event was triggered.
	 */
	device: string
	/**
	 * From what platform the user is managing Security events
	 */
	platform: string
}
export interface RecurringBuyActivated {
	/**
	 * What is the frequency of the recurring buy. Also called period in the backend.
	 */
	frequency: string
	/**
	 * The amount in input_currency being spend by the user
	 */
	input_amount: number
	/**
	 * The amount in USD being spend by the user
	 */
	input_amount_usd: number
	/**
	 * Currency symbol for the currency being paid in exchange for some crypto. For example USD
	 */
	input_currency: string
	/**
	 * Currency symbol for the currency being received. For example BTC
	 */
	output_currency: string
	/**
	 * The payment method used for the recurring buy order
	 */
	payment_method: string
	/**
	 * What platform the user is looking at recurring buy from
	 */
	platform: string
	/**
	 * What id the id of the recurring buy being cancelled
	 */
	recurring_buy_id: string
}
export interface RecurringBuyCancelled {
	/**
	 * Whether the order is cancelled by the user or by our backend (for example after many failed reattempts)
	 */
	cancelled_by_user: boolean
	/**
	 * What is the frequency of the recurring buy. Also called period in the backend.
	 */
	frequency: string | null
	/**
	 * The amount in input_currency being spend by the user
	 */
	input_amount: number
	/**
	 * The amount in USD being spend by the user
	 */
	input_amount_usd: number
	/**
	 * Currency symbol for the currency being paid in exchange for some crypto. For example USD
	 */
	input_currency: string
	/**
	 * Currency symbol for the currency being received. For example BTC
	 */
	output_currency: string
	/**
	 * The payment method used for the recurring buy order
	 */
	payment_method: string
	/**
	 * What platform the user is looking at recurring buy from
	 */
	platform: string
	/**
	 * What id the id of the recurring buy being cancelled
	 */
	recurring_buy_id: string
}
export interface RecurringBuyClicked {
	/**
	 * Device type from where the event was triggered.

	 */
	device: string
	/**
	 * What button we are referring to. BUY_CONFIRMATION : at the end of the buy flow (Create Recurring Buy at the suggestion screen).
	 */
	origin: string
	/**
	 * What platform the user is looking at recurring buy from
	 */
	platform: string
}
export interface RecurringBuyDetailsClicked {
	/**
	 * Currency of the crypto being bought (output currency) for the recurring order
	 */
	currency: string
	/**
	 * Device type from where the event was triggered.

	 */
	device: string
	/**
	 * What button we are referring to : CURRENCY_PAGE : Currency page (Coin View) of the coin being bought. TRANSACTION_LIST : From the historical transaction list, also called Activity in mobile
	 */
	origin: string
	/**
	 * What platform the user is looking at recurring buy from
	 */
	platform: string
}
export interface RecurringBuyInfoViewed {
	/**
	 * Device type from where the event was triggered.
	 */
	device: string
	/**
	 * (From 0 to 4) If applicable : what page of the info is being viewed.
	 */
	page: number | null
	/**
	 * What platform the user is looking at recurring buy from
	 */
	platform: string
	/**
	 * type of info being viewed. e.g. DCA : Dollar Cost Averaging
	 */
	type?: string
}
export interface RecurringBuyLearnMoreClicked {
	/**
	 * Device type from where the event was triggered.
	 */
	device: string
	/**
	 * What button we are referring to. CURRENCY_PAGE : Currency page (Coin View) of the coin being bought. DASHBOARD_PROMO : announcement card or promo on dashboard.  DCA_DETAILS_LINK : the external link to learn more about the DCA method
	 */
	origin: string
	/**
	 * What platform the user is looking at recurring buy from
	 */
	platform: string
	/**
	 * What does the user want to learn more about ? DCA : Dollar Cost Averaging
	 */
	type?: string
}
export interface RecurringBuySuggestionSkipped {
	/**
	 * Device type from where the event was triggered.
	 */
	device: string
	/**
	 * What recurring buy suggestion we are referring to. BUY_CONFIRMATION : at the end of the buy flow ("Maybe Later" at the suggestion screen)
	 */
	origin: string
	/**
	 * What platform the user is looking at recurring buy from
	 */
	platform?: string
}
export interface RecurringBuyUnavailableShown {
	/**
	 * Device type from where the event was triggered.
	 */
	device: string
	/**
	 * What platform the user wants to buy from
	 */
	platform: string
	/**
	 * Reason for not being able to set up recurring buy. PAYMENT_METHOD_UNAVAILABLE : the current selected payment method is not available. (e.g. if cards payments cannot be used for that client for some reason) SELECT_PAYMENT : the user needs to select the payment method before selecting the frequency of the buy order, mainly shown for first time buyer.
	 */
	reason: string
}
export interface RecurringBuyViewed {
	/**
	 * Device type from where the event was triggered.

	 */
	device: string
	/**
	 * Path portion of the URL of the page. Equivalent to canonical path which defaults to location.pathname from the DOM API.
	 */
	path?: string
	/**
	 * What platform the page viewed belongs to
	 */
	platform: string
	/**
	 * Full URL of the previous page. Equivalent to document.referrer from the DOM API.
	 */
	referrer?: string
	/**
	 * Query string portion of the URL of the page. Equivalent to location.search from the DOM API.
	 */
	search?: string
	/**
	 * Title of the page. Equivalent to document.title from the DOM API.
	 */
	title?: string
	/**
	 * Full URL of the page. First we look for the canonical url. If the canonical url is not provided, we use location.href from the DOM API.
	 */
	url?: string
}
export interface RememberTwoStepVerificationUpdated {
	/**
	 * Device type from where the event was triggered.
	 */
	device?: string
	/**
	 * If Enabled, browser will be remembered, allowing user to login again without having to re-authenticate. If Disabled, authentication is needed for every login.
	 */
	is_enabled: boolean
	/**
	 * From what platform the user is managing Security events

	 */
	platform: string
}
export interface RemoveLinkedCardClicked {
	/**
	 * Device type from where the event was triggered.
	 */
	device: string
	/**
	 * What button we are referring to. SETTINGS : user's settings page. BUY : from the Buy flow.
	 */
	origin: string
	/**
	 * What platform the user wants to link a bank for
	 */
	platform: string
}
export interface Exchange22 {
	/**
	 * Whether the exchange account has 2FA set up
	 */
	two_fa_mode?: boolean
	/**
	 * Exchange user credentials ID
	 */
	user_id?: string
}
export interface Exchange23 {
	/**
	 * Whether the exchange account has 2FA set up
	 */
	two_fa_mode?: Record<string, any>
	/**
	 * Exchange user credentials ID
	 */
	user_id?: Record<string, any>
}
export interface Nabu11 {
	/**
	 * Whether the nabu user is eligible for recovery. Usually if account has value (> $300 or 1 payment method linked)
	 */
	recovery_eligible?: boolean
	/**
	 * The Nabu User ID. This is from the users table in nabu gateway
	 */
	user_id?: Record<string, any>
}
export interface Wallet11 {
	/**
	 * The wallet 2FA type that is enforced.
	 */
	auth_type?: string
	/**
	 * Parameters about the exchange account
	 */
	exchange?: Exchange23
	/**
	 * The first four characters of the wallet.guid field
	 */
	guid_first_four?: string
	/**
	 * Whether the wallet has cloud backups
	 */
	has_cloud_backup?: boolean
	/**
	 * Whether the wallet has a mobile client set up
	 */
	is_mobile_setup?: boolean
	/**
	 * The last time, in unix timestamp, in which a wallet has their mnemonic backup verified
	 */
	last_mnemonic_backup?: number
	/**
	 * The type of device being verified
	 */
	mobile_device_type?: string
	/**
	 * Parameter about the nabu account
	 */
	nabu?: Nabu11
}
export interface ResetAccountCancelled {
	/**
	 * Device type from where the event was triggered.
	 */
	device: string
	/**
	 * Parameters about the exchange account
	 */
	exchange?: Exchange22
	/**
	 * Indicates if possible to merge two unlinked accounts
	 */
	mergeable?: boolean
	/**
	 * What button we are referring to. RESET_CONFIRMATION : when confirming reset in reset flow. RESET_FINAL_WARNING : when confirming reset wish after the final warning
	 */
	origin: string
	/**
	 * What platform the user is is recovering the account from
	 */
	platform: string
	/**
	 * Whether the user is being redirected to the exchange or wallet
	 */
	site_redirect: string
	/**
	 * Indicates if possible to upgrade to a new unified Blockchain.com Account
	 */
	upgradeable?: boolean
	/**
	 * Parameters about the wallet account
	 */
	wallet?: Wallet11
}
export interface Exchange24 {
	/**
	 * Whether the exchange account has 2FA set up
	 */
	two_fa_mode?: boolean
	/**
	 * Exchange user credentials ID
	 */
	user_id?: string
}
export interface Exchange25 {
	/**
	 * Whether the exchange account has 2FA set up
	 */
	two_fa_mode?: Record<string, any>
	/**
	 * Exchange user credentials ID
	 */
	user_id?: Record<string, any>
}
export interface Nabu12 {
	/**
	 * Whether the nabu user is eligible for recovery. Usually if account has value (> $300 or 1 payment method linked)
	 */
	recovery_eligible?: boolean
	/**
	 * The Nabu User ID. This is from the users table in nabu gateway
	 */
	user_id?: Record<string, any>
}
export interface Wallet12 {
	/**
	 * The wallet 2FA type that is enforced.
	 */
	auth_type?: string
	/**
	 * Parameters about the exchange account
	 */
	exchange?: Exchange25
	/**
	 * The first four characters of the wallet.guid field
	 */
	guid_first_four?: string
	/**
	 * Whether the wallet has cloud backups
	 */
	has_cloud_backup?: boolean
	/**
	 * Whether the wallet has a mobile client set up
	 */
	is_mobile_setup?: boolean
	/**
	 * The last time, in unix timestamp, in which a wallet has their mnemonic backup verified
	 */
	last_mnemonic_backup?: number
	/**
	 * The type of device being verified
	 */
	mobile_device_type?: string
	/**
	 * Parameter about the nabu account
	 */
	nabu?: Nabu12
}
export interface ResetAccountClicked {
	/**
	 * Device type from where the event was triggered.
	 */
	device: string
	/**
	 * Parameters about the exchange account
	 */
	exchange?: Exchange24
	/**
	 * Indicates if possible to merge two unlinked accounts
	 */
	mergeable?: boolean
	/**
	 * What button we are referring to. RECOVERY_OPTIONS : when failing to choose between recovery options. RECOVERY_PHRASE : when failing to enter recovery phrase. RESET_CONFIRMATION : when confirming reset in reset flow. RESET_FINAL_WARNING : when confirming reset wish after the final warning
	 */
	origin: string
	/**
	 * What platform the user is is recovering the account from
	 */
	platform: string
	/**
	 * Whether the user is being redirected to the exchange or wallet
	 */
	site_redirect: string
	/**
	 * Indicates if possible to upgrade to a new unified Blockchain.com Account
	 */
	upgradeable?: boolean
	/**
	 * Parameters about the wallet account
	 */
	wallet?: Wallet12
}
export interface RevenueGenerated {
	/**
	 * What product the user is buying, it's usually the trading pair of the order (e.g. BTC-EUR)
	 */
	product_id: string
	/**
	 * The approximated profit in usd that we make from the order. Usually a fixed approximate margin for Buy, Sell & Swap product, and the fee for trades
	 */
	profit: number
	/**
	 * The revenue amount in usd. This is the volume of crypto of fiat traded or bought from a buy, swap, sell or trade order
	 */
	revenue: number
	/**
	 * What type of revenue this is
	 */
	revenue_type: string
}
export interface SearchCoinOpened {
	/**
	 * Device type from where the event was triggered.
	 */
	device: string
	/**
	 * What platform the search is initiated from.
	 */
	platform: string
	/**
	 * What elements the user is looking for. TRADING_PAIR : trading pairs containing the coin. CRYPTO_PRICES : from the explorer price page
	 */
	search_type: string
}
export interface SecurityTabClicked {
	/**
	 * Device type from where the event was triggered.
	 */
	device: string
	/**
	 * From what platform the user clicking the Security options
	 */
	platform: string
}
export interface SellAmountEntered {
	/**
	 * Device type from where the event was triggered.
	 */
	device: string
	/**
	 * What type of account the user wants to sell funds from.
	 */
	from_account_type: string
	/**
	 * The expected amount for the input currency, usually as a float. For BTC, it should be for example 1.23, meaning 1.23 BTC
	 */
	input_amount: number
	/**
	 * Currency symbol for the crypto currency being sent by the user in exchange for some fiat. For example BTC
	 */
	input_currency: string
	/**
	 * Currency symbol for the currency being received by the user. For example USD
	 */
	output_currency: string
	/**
	 * What platform the user is to selling from
	 */
	platform: string
}
export interface SellAmountMaxClicked {
	/**
	 * Device type from where the event was triggered.
	 */
	device: string
	/**
	 * What type of account the user wants to sell funds from.
	 */
	from_account_type: string
	/**
	 * Currency symbol for the crypto currency being sent by the user in exchange for some fiat. For example BTC
	 */
	input_currency: string
	/**
	 * Currency symbol for the currency being received by the user. For example USD
	 */
	output_currency: string
	/**
	 * What platform the user is to selling from
	 */
	platform: string
}
export interface SellAmountMinClicked {
	/**
	 * Device type from where the event was triggered.
	 */
	device: string
	/**
	 * What type of account the user wants to sell funds from.
	 */
	from_account_type: string
	/**
	 * Currency symbol for the crypto currency being sent by the user in exchange for some fiat. For example BTC
	 */
	input_currency: string
	/**
	 * Currency symbol for the currency being received by the user. For example USD
	 */
	output_currency: string
	/**
	 * What platform the user is to selling from
	 */
	platform: string
}
export interface SellCancelled {
	/**
	 * Device the sell order was made from
	 */
	device?: string
	/**
	 * What type of account the user wants to sell funds from. For simple_transactions with paymentType "Funds", it is TRADING. For custodial transactions, it is TRADING for INTERNAL type, or USERKEY for FROM_USERKEY type. 
SAVINGS : interest saving account. 
	 */
	from_account_type: string
	/**
	 * The expected amount for the input currency, usually as a float. For BTC, it should be for example 1.23, meaning 1.23 BTC. Exact amount is only in Buy Completed
	 */
	input_amount?: number
	/**
	 * The amount of crypto sold by the user in USD, usually as a float. it should be for example 10.23, meaning $10.23 worth of crypto was sold
	 */
	input_amount_usd?: number
	/**
	 * Currency symbol for the crypto currency being sent by the user in exchange for some fiat. For example BTC

	 */
	input_currency: string
	/**
	 * The expected amount for the output currency, usually as a float. For USD, it should be for example 1.23, meaning 1.23 USD. Exact amount is only in Sell Completed
	 */
	output_amount?: number
	/**
	 * Currency symbol for the currency being received by the user. For example USD

	 */
	output_currency: string
	/**
	 * What platform the event was started from. (WALLET if product=SIMPLEBUY and EXCHANGE if product=MERCURY
	 */
	paltform: string
	/**
	 * id of the payment (id of the transaction from nabu payments)
	 */
	payment_id?: string
	/**
	 * The Product for which the sell order is (the product columns of the simple_transactions table, or SIMPLEBUY for custodial transactions since they aren't used in the Exchange Simple Trade product)
	 */
	product: string
	/**
	 * The id of the transaction for the sell order (the id of either the  simple_transactions or the custodial_transactions table in nabu gateway)
	 */
	transaction_id?: string
}
export interface SellCompleted {
	/**
	 * Device the sell order was made from
	 */
	device?: string
	/**
	 * What type of account the user wants to sell funds from. For simple_transactions with paymentType "Funds", it is TRADING. For custodial transactions, it is TRADING for INTERNAL type, or USERKEY for FROM_USERKEY type. 
SAVINGS : interest saving account. 
	 */
	from_account_type: string
	/**
	 * The expected amount for the input currency, usually as a float. For BTC, it should be for example 1.23, meaning 1.23 BTC. Exact amount is only in Buy Completed
	 */
	input_amount?: number
	/**
	 * The amount of crypto sold by the user in USD, usually as a float. it should be for example 10.23, meaning $10.23 worth of crypto was sold
	 */
	input_amount_usd: number
	/**
	 * Currency symbol for the crypto currency being sent by the user in exchange for some fiat. For example BTC

	 */
	input_currency: string
	/**
	 * The expected amount for the output currency, usually as a float. For USD, it should be for example 1.23, meaning 1.23 USD. Exact amount is only in Sell Completed
	 */
	output_amount?: number
	/**
	 * Currency symbol for the currency being received by the user. For example USD

	 */
	output_currency: string
	/**
	 * What platform the event was started from. (WALLET if product=SIMPLEBUY and EXCHANGE if product=MERCURY

	 */
	platform: string
	/**
	 * The Product for which the sell order is (the product columns of the simple_transactions table, or SIMPLEBUY for custodial transactions since they aren't used in the Exchange Simple Trade product)
	 */
	product: string
	/**
	 * Spread percentage applied to the exchange rate
	 */
	spread_percentage: number
	/**
	 * The id of the transaction for the sell order (the id of either the  simple_transactions or the custodial_transactions table in nabu gateway)
	 */
	transaction_id?: string
}
export interface SellCreated {
	/**
	 * Device the sell order was made from
	 */
	device?: string
	/**
	 * What type of account the user wants to sell funds from. For simple_transactions with paymentType "Funds", it is TRADING. For custodial transactions, it is TRADING for INTERNAL type, or USERKEY for FROM_USERKEY type. 
SAVINGS : interest saving account. 
	 */
	from_account_type: string
	/**
	 * The expected amount for the input currency, usually as a float. For BTC, it should be for example 1.23, meaning 1.23 BTC. Exact amount is only in Buy Completed
	 */
	input_amount?: number
	/**
	 * The amount of crypto sold by the user in USD, usually as a float. it should be for example 10.23, meaning $10.23 worth of crypto was sold
	 */
	input_amount_usd?: number
	/**
	 * Currency symbol for the crypto currency being sent by the user in exchange for some fiat. For example BTC

	 */
	input_currency: string
	/**
	 * The expected amount for the output currency, usually as a float. For USD, it should be for example 1.23, meaning 1.23 USD. Exact amount is only in Sell Completed
	 */
	output_amount?: number
	/**
	 * Currency symbol for the currency being received by the user. For example USD

	 */
	output_currency: string
	/**
	 * id of the payment (id of the transaction from nabu payments)
	 */
	payment_id?: string
	/**
	 * What platform the event was started from. (WALLET if product=SIMPLEBUY and EXCHANGE if product=MERCURY

	 */
	platform: string
	/**
	 * The Product for which the sell order is (the product columns of the simple_transactions table, or SIMPLEBUY for custodial transactions since they aren't used in the Exchange Simple Trade product)
	 */
	product: string
	/**
	 * The id of the transaction for the sell order (the id of either the  simple_transactions or the custodial_transactions table in nabu gateway)
	 */
	transaction_id?: string
}
export interface SellExpired {
	/**
	 * Device the sell order was made from
	 */
	device?: string
	/**
	 * What type of account the user wants to sell funds from. For simple_transactions with paymentType "Funds", it is TRADING. For custodial transactions, it is TRADING for INTERNAL type, or USERKEY for FROM_USERKEY type. 
SAVINGS : interest saving account. 
	 */
	from_account_type: string
	/**
	 * The expected amount for the input currency, usually as a float. For BTC, it should be for example 1.23, meaning 1.23 BTC. Exact amount is only in Buy Completed
	 */
	input_amount?: number
	/**
	 * The amount of crypto sold by the user in USD, usually as a float. it should be for example 10.23, meaning $10.23 worth of crypto was sold
	 */
	input_amount_usd?: number
	/**
	 * Currency symbol for the crypto currency being sent by the user in exchange for some fiat. For example BTC

	 */
	input_currency: string
	/**
	 * The expected amount for the output currency, usually as a float. For USD, it should be for example 1.23, meaning 1.23 USD. Exact amount is only in Sell Completed
	 */
	output_amount?: number
	/**
	 * Currency symbol for the currency being received by the user. For example USD

	 */
	output_currency: string
	/**
	 * id of the payment (id of the transaction from nabu payments)
	 */
	payment_id?: string
	/**
	 * What platform the event was started from. (WALLET if product=SIMPLEBUY and EXCHANGE if product=MERCURY

	 */
	platform: string
	/**
	 * The Product for which the sell order is (the product columns of the simple_transactions table, or SIMPLEBUY for custodial transactions since they aren't used in the Exchange Simple Trade product)
	 */
	product: string
	/**
	 * The id of the transaction for the sell order (the id of either the  simple_transactions or the custodial_transactions table in nabu gateway)
	 */
	transaction_id?: string
}
export interface SellFailed {
	/**
	 * Device the sell order was made from
	 */
	device?: string
	/**
	 * What type of account the user wants to sell funds from. For simple_transactions with paymentType "Funds", it is TRADING. For custodial transactions, it is TRADING for INTERNAL type, or USERKEY for FROM_USERKEY type. 
SAVINGS : interest saving account. 
	 */
	from_account_type: string
	/**
	 * The expected amount for the input currency, usually as a float. For BTC, it should be for example 1.23, meaning 1.23 BTC. Exact amount is only in Buy Completed
	 */
	input_amount?: number
	/**
	 * The amount of crypto sold by the user in USD, usually as a float. it should be for example 10.23, meaning $10.23 worth of crypto was sold
	 */
	input_amount_usd?: number
	/**
	 * Currency symbol for the crypto currency being sent by the user in exchange for some fiat. For example BTC

	 */
	input_currency: string
	/**
	 * The expected amount for the output currency, usually as a float. For USD, it should be for example 1.23, meaning 1.23 USD. Exact amount is only in Sell Completed
	 */
	output_amount?: number
	/**
	 * Currency symbol for the currency being received by the user. For example USD

	 */
	output_currency: string
	/**
	 * id of the payment (id of the transaction from nabu payments)
	 */
	payment_id?: string
	/**
	 * What platform the event was started from. (WALLET if product=SIMPLEBUY and EXCHANGE if product=MERCURY

	 */
	platform: string
	/**
	 * The Product for which the sell order is (the product columns of the simple_transactions table, or SIMPLEBUY for custodial transactions since they aren't used in the Exchange Simple Trade product)
	 */
	product: string
	/**
	 * The id of the transaction for the sell order (the id of either the  simple_transactions or the custodial_transactions table in nabu gateway)
	 */
	transaction_id?: string
}
export interface SellFromSelected {
	/**
	 * Device type from where the event was triggered.
	 */
	device: string
	/**
	 * What type of account the user wants to sell funds from.
	 */
	from_account_type: string
	/**
	 * Currency symbol for the crypto currency being sent by the user in exchange for some fiat. For example BTC
	 */
	input_currency: string
	/**
	 * What platform the user is to selling from
	 */
	platform: string
}
export interface SellRejected {
	/**
	 * Device the sell order was made from
	 */
	device?: string
	/**
	 * Error message related to the rejection. This is more detailed than the rejection_reason
	 */
	error_reason?: string
	/**
	 * What type of account the user wants to sell funds from. For simple_transactions with paymentType "Funds", it is TRADING. For custodial transactions, it is TRADING for INTERNAL type, or USERKEY for FROM_USERKEY type. 
SAVINGS : interest saving account. 
	 */
	from_account_type: string
	/**
	 * The expected amount for the input currency, usually as a float. For BTC, it should be for example 1.23, meaning 1.23 BTC. Exact amount is only in Buy Completed
	 */
	input_amount?: number
	/**
	 * The amount of crypto sold by the user in USD, usually as a float. it should be for example 10.23, meaning $10.23 worth of crypto was sold
	 */
	input_amount_usd?: number
	/**
	 * Currency symbol for the crypto currency being sent by the user in exchange for some fiat. For example BTC

	 */
	input_currency: string
	/**
	 * The expected amount for the output currency, usually as a float. For USD, it should be for example 1.23, meaning 1.23 USD. Exact amount is only in Sell Completed
	 */
	output_amount?: number
	/**
	 * Currency symbol for the currency being received by the user. For example USD

	 */
	output_currency: string
	/**
	 * id of the payment (id of the transaction from nabu payments)
	 */
	payment_id?: string
	/**
	 * What platform the event was started from. (WALLET if product=SIMPLEBUY and EXCHANGE if product=MERCURY

	 */
	platform: string
	/**
	 * The Product for which the sell order is (the product columns of the simple_transactions table, or SIMPLEBUY for custodial transactions since they aren't used in the Exchange Simple Trade product)
	 */
	product: string
	/**
	 * Raison of the rejection
	 */
	rejection_reason?: string
	/**
	 * The id of the transaction for the sell order (the id of either the  simple_transactions or the custodial_transactions table in nabu gateway)
	 */
	transaction_id?: string
}
export interface SendAmountEntered {
	/**
	 * The currency the user wants to send (e.g. BTC)
	 */
	currency: string
	/**
	 * Device type from where the event was triggered.

	 */
	device: string
	/**
	 * What fee rate is used for sending the crypto. The user may or may not have selected it explicitly, for transfers from custodial wallets for example. BACKEND : the backend will chose what fee_rate to apply. CUSTOM : custom priority defined by the user. NORMAL : normal priority for transactions according to our fee estimation.  PRIORITY : high priority for transactions according to our fee estimation.
	 */
	fee_rate: string
	/**
	 * To what type of account the user wants to send funds from. 
SAVINGS : interest saving account. 
TRADING : wallet custodial wallet. 
USERKEY : Non Custodial, Private Key, wallet
	 */
	from_account_type: string
	/**
	 * From what platform the user is sending crypto from
	 */
	platform: string
	/**
	 * To what type of account the user wants to send funds to. EXCHANGE : Blockchain Exchange wallet 
EXTERNAL : external address outside Blockchain.com. 
SAVINGS : interest saving account. 
TRADING : wallet custodial wallet. 
USERKEY : Non Custodial, Private Key, wallet
	 */
	to_account_type: string
}
export interface SendAmountMaxClicked {
	/**
	 * The currency the user wants to send (e.g. BTC)
	 */
	currency: string
	/**
	 * Device type from where the event was triggered.
	 */
	device: string
	/**
	 * To what type of account the user wants to send funds from. 
SAVINGS : interest saving account. 
TRADING : wallet custodial wallet. 
USERKEY : Non Custodial, Private Key, wallet
	 */
	from_account_type: string
	/**
	 * From what platform the user is sending crypto from
	 */
	platform: string
	/**
	 * To what type of account the user wants to send funds to. EXCHANGE : Blockchain Exchange wallet 
EXTERNAL : external address outside Blockchain.com. 
SAVINGS : interest saving account. 
TRADING : wallet custodial wallet. 
USERKEY : Non Custodial, Private Key, wallet
	 */
	to_account_type: string
}
export interface SendFeeRateSelected {
	/**
	 * The currency the user wants to send (e.g. BTC)
	 */
	currency: string
	/**
	 * Device type from where the event was triggered.
	 */
	device: string
	/**
	 * What fee rate the user has selected
	 */
	fee_rate: string
	/**
	 * To what type of account the user wants to send funds from. 
SAVINGS : interest saving account. 
TRADING : wallet custodial wallet. 
USERKEY : Non Custodial, Private Key, wallet
	 */
	from_account_type: string
	/**
	 * From what platform the user is sending crypto from
	 */
	platform: string
	/**
	 * To what type of account the user wants to send funds to. EXCHANGE : Blockchain Exchange wallet 
EXTERNAL : external address outside Blockchain.com. 
SAVINGS : interest saving account. 
TRADING : wallet custodial wallet. 
USERKEY : Non Custodial, Private Key, wallet
	 */
	to_account_type: string
}
export interface SendFromSelected {
	/**
	 * The currency the user wants to send (e.g. BTC)
	 */
	currency: string
	/**
	 * Device type from where the event was triggered.
	 */
	device: string
	/**
	 * To what type of account the user wants to send funds from. 
SAVINGS is the interest saving account. 
TRADING is the wallet custodial wallet. 
USERKEY is the Non Custodial, Private Key, wallet
	 */
	from_account_type: string
	/**
	 * From what platform the user is sending crypto from
	 */
	platform: string
}
export interface SendReceiveClicked {
	/**
	 * What currency is being viewed. Used only for legacy flow, as the new flow will ask for the currency at a later stage.
	 */
	currency?: string
	/**
	 * Device type from where the event was triggered.
	 */
	device: string
	/**
	 * What button we are referring to. DASHBOARD_PROMO : announcement card or promo on dashboard. 
NAVIGATION: Navigation Bar.

	 */
	origin: string
	/**
	 * What platform the user is clicking from
	 */
	platform: string
	/**
	 * Whether the user clicked on a send or receive button specifically. For Android the Send or Receive screen is the same button, so this type will be empty.
	 */
	type?: string
}
export interface SendReceiveViewed {
	/**
	 * What currency is being viewed. Used only for legacy flow, as the new flow will ask for the currency at a later stage.
	 */
	currency?: string
	/**
	 * Device type from where the event was triggered.
	 */
	device: string
	/**
	 * Path portion of the URL of the page. Equivalent to canonical path which defaults to location.pathname from the DOM API.
	 */
	path?: string
	/**
	 * What platform the page viewed belongs to
	 */
	platform: string
	/**
	 * Full URL of the previous page. Equivalent to document.referrer from the DOM API.
	 */
	referrer?: string
	/**
	 * Query string portion of the URL of the page. Equivalent to location.search from the DOM API.
	 */
	search?: string
	/**
	 * Title of the page. Equivalent to document.title from the DOM API.
	 */
	title?: string
	/**
	 * Whether the user views a send or receive screen specifically. For Android the Send or Receive screen is the same, so this type will be empty.
	 */
	type?: string
	/**
	 * Full URL of the page. First we look for the canonical url. If the canonical url is not provided, we use location.href from the DOM API.
	 */
	url?: string
}
export interface SendSubmitted {
	/**
	 * The currency the user wants to send (e.g. BTC)
	 */
	currency: string
	/**
	 * Device type from where the event was triggered.
	 */
	device: string
	/**
	 * What fee rate is used for sending the crypto. The user may or may not have selected it explicitly, for transfers from custodial wallets for example. BACKEND : the backend will chose what fee_rate to apply. CUSTOM : custom priority defined by the user. NORMAL : normal priority for transactions according to our fee estimation.  PRIORITY : high priority for transactions according to our fee estimation.
	 */
	fee_rate: string
	/**
	 * To what type of account the user wants to send funds from. 
SAVINGS : interest saving account. 
TRADING : wallet custodial wallet. 
USERKEY : Non Custodial, Private Key, wallet
	 */
	from_account_type: string
	/**
	 * From what platform the user is sending crypto from
	 */
	platform: string
	/**
	 * To what type of account the user wants to send funds to. EXCHANGE : Blockchain Exchange wallet 
EXTERNAL : external address outside Blockchain.com. 
SAVINGS : interest saving account. 
TRADING : wallet custodial wallet. 
USERKEY : Non Custodial, Private Key, wallet
	 */
	to_account_type: string
}
export interface SettingsCurrencyClicked {
	currency: string
	/**
	 * Device type from where the event was triggered.
	 */
	device: string
	/**
	 * From what platform the user is using the Settings
	 */
	platform: string
}
export interface SettingsHyperlinkClicked {
	''?: Record<string, any>
	/**
	 * Destination link. Example: Terms of Service
	 */
	destination: string
	/**
	 * Device type from where the event was triggered.
	 */
	device: string
	/**
	 * From what platform the user is using the Settings
	 */
	platform: string
}
export interface SettingsTabClicked {
	''?: Record<string, any>
	/**
	 * Device type from where the event was triggered.
	 */
	device: string
	/**
	 * From what platform the user is using the Settings
	 */
	platform: string
	/**
	 * General, Trading Limits, Preferences or Wallets & Addresses
	 */
	settings_tab: string
}
export interface SignInSkipped {
	/**
	 * Device type from where the event was triggered.
	 */
	device: string
	/**
	 * In the Exchange, the sign in can be skipped to continue as guest
	 */
	plaform: string
}
export interface SignUpAddressUnsupported {
	/**
	 * Country, as iso code alpha 2, provided by the user at sign up
	 */
	country: string
	/**
	 * country state, as ISO 3166-2 (US-NY for example), provided by the user at sign up
	 */
	country_state: string
	/**
	 * What device the user is signing up from
	 */
	device: string
	email: Record<string, any>
	/**
	 * What platform the user is signing up to
	 */
	platform: string
}
export interface SignUpClicked {
	/**
	 * What device the user is signing up from
	 */
	device: string
	/**
	 * What button we are referring to. NUX_LAUNCH_PROMO_BUY_CRYPTO : (mobile) Buy Crypto button at the bottom of a card announcement  when launching the app and before login in.
	 */
	origin: string
	/**
	 * What platform the user is signing up to
	 */
	platform: string
}
export interface SignUpCountrySelected {
	/**
	 * Country, as iso code alpha 2, provided by the user at sign up
	 */
	country: string
	/**
	 * country state, as ISO 3166-2 (US-NY for example), provided by the user at sign up
	 */
	country_state?: string
	/**
	 * What device the user is signing up from
	 */
	device: string
	/**
	 * What platform the user is signing up to
	 */
	platform: string
}
export interface SignedIn {
	/**
	 * How the user is trying to log in. PASSWORD : with a password on mobile or web, PIN : with a PIN on mobile,  SECURE_CHANNEL : by sending a log in request via secure channel to another client
	 */
	authentification_type?: string
	/**
	 * Device type from where the event was triggered.
	 */
	device: string
	/**
	 * What platform the user logs in to.
	 */
	platform: string
	/**
	 * Whether the user is being redirected to the WALLET or the EXCHANGE
	 */
	site_redirect?: string
}
export interface SignedOut {
	/**
	 * Device type from where the event was triggered.
	 */
	device: string
	/**
	 * What platform the user logs out from.
	 */
	platform: string
}
export interface SignedUp {
	/**
	 * What device the user created the account from
	 */
	device: string
	/**
	 * Whether the profile is created from linking the account from another product. For now, we record it specifically when an exchange account is created by linking a wallet account.
	 */
	is_from_linking?: boolean
	/**
	 * every user need to be assigned to a legal entity based on a certain reason.
	 */
	legal_entity: string
	/**
	 * legal entity to a user assigned based on this reason.
	 */
	legal_entity_reason: string
	/**
	 * What platform the user signed up for
	 */
	platform: string
}
export interface SimpleTradeClicked {
	/**
	 * Device type from where the event was triggered.
	 */
	device: string
	/**
	 * what button we are referring to. NAVIGATION : navigation bar. 

	 */
	origin: string
	/**
	 * What platform the user is clicking from
	 */
	platform: string
}
export interface SimpleTradeViewed {
	/**
	 * Device type from where the event was triggered.
	 */
	device: string
	/**
	 * Path portion of the URL of the page. Equivalent to canonical path which defaults to location.pathname from the DOM API.
	 */
	path?: string
	/**
	 * What platform the page viewed belongs to
	 */
	platform: string
	/**
	 * Full URL of the previous page. Equivalent to document.referrer from the DOM API.
	 */
	referrer?: string
	/**
	 * Query string portion of the URL of the page. Equivalent to location.search from the DOM API.
	 */
	search?: string
	/**
	 * Title of the page. Equivalent to document.title from the DOM API.
	 */
	title?: string
	/**
	 * Full URL of the page. First we look for the canonical url. If the canonical url is not provided, we use location.href from the DOM API.
	 */
	url?: string
}
export interface SmsMessageSent {
	/**
	 * country of the mobile number, in alpha iso 2 code.
	 */
	country_code: string
	/**
	 * Device type from where the event was triggered.
	 */
	device?: string
	/**
	 * From which page are they verifying the Mobile Number? Settings or Security
	 */
	origin: string
	/**
	 * From what platform the user is using the Settings
	 */
	platform: string
}
export interface SwapAccountsSelected {
	/**
	 * Device type from where the event was triggered.
	 */
	device: string
	/**
	 * Currency symbol for the currency being swap from in exchange for some other currency. For example BTC in a BTC-ETH swap
	 */
	input_currency: string
	/**
	 * The type of account the swap funds are coming from
	 */
	input_type: string
	/**
	 * Currency symbol for the currency being swap to. For example ETH in a BTC-ETH swap
	 */
	output_currency: string
	/**
	 * The type of account the swap funds are going to
	 */
	output_type: string
	/**
	 * From what platform the user wants to Swap from
	 */
	platform: string
	/**
	 * Whether the swap accounts and currency were suggested by the UX and the user clicked on it. Empty if this information is unknown.
	 */
	was_suggested?: boolean
}
export interface SwapAmountEntered {
	/**
	 * The amount in the native fiat currency that the user selects the amount
	 */
	amount?: number
	/**
	 * The native fiat currency
	 */
	amount_currency?: string
	/**
	 * Device type from where the event was triggered.
	 */
	device: string
	/**
	 * The amount for the input currency
	 */
	input_amount: number
	/**
	 * Currency symbol for the currency being swap from in exchange for some other currency. For example BTC in a BTC-ETH swap
	 */
	input_currency: string
	/**
	 * The type of account the swap funds are coming from
	 */
	input_type: string
	/**
	 * The amount for the output currency
	 */
	output_amount?: number
	/**
	 * Currency symbol for the currency being swap to. For example ETH in a BTC-ETH swap
	 */
	output_currency: string
	/**
	 * The type of account the swap funds are going to
	 */
	output_type: string
	/**
	 * From what platform the user wants to Swap from
	 */
	platform: string
}
export interface SwapAmountMaxClicked {
	/**
	 * If the button explicitly displays the amount in a specific currency. what is the currency being clicked on for the max amount ?
	 */
	amount_currency?: string
	/**
	 * Device type from where the event was triggered.
	 */
	device: string
	/**
	 * Currency symbol for the currency being swap from in exchange for some other currency. For example BTC in a BTC-ETH swap
	 */
	input_currency: string
	/**
	 * The type of account the swap funds are coming from
	 */
	input_type: string
	/**
	 * Currency symbol for the currency being swap to. For example ETH in a BTC-ETH swap
	 */
	output_currency: string
	/**
	 * The type of account the swap funds are going to
	 */
	output_type: string
	/**
	 * From what platform the user wants to Swap from
	 */
	platform: string
}
export interface SwapAmountMinClicked {
	/**
	 * If the button explicitly displays the amount in a specific currency. what is the currency being clicked on for the min amount ?
	 */
	amount_currency?: string
	/**
	 * Device type from where the event was triggered.
	 */
	device: string
	/**
	 * Currency symbol for the currency being swap from in exchange for some other currency. For example BTC in a BTC-ETH swap
	 */
	input_currency: string
	/**
	 * The type of account the swap funds are coming from
	 */
	input_type: string
	/**
	 * Currency symbol for the currency being swap to. For example ETH in a BTC-ETH swap
	 */
	output_currency: string
	/**
	 * The type of account the swap funds are going to
	 */
	output_type: string
	/**
	 * From what platform the user wants to Swap from
	 */
	platform: string
}
export interface SwapCancelled {
	/**
	 * Device type from where the event was triggered.
	 */
	device: string
	/**
	 * What type of swap transactions it is, as a direction from/to Custodial or Non Custodial Wallet. INTERNAL is from TRADING to TRADING wallets. ON_CHAIN is from USERKEY to USERKEY. FROM_USERKEY is from USERKEY to TRADING wallets. TO_USERKEY is from TRADING to USERKEY wallets
	 */
	direction: string
	/**
	 * The type of account the swap funds are coming from. (USERKEY for ON_CHAIN and FROM_USERKEY directions, TRADING for INTERNAL and TO_USERKEY)
	 */
	from_account_type: string
	/**
	 * The amount for the input currency
	 */
	input_amount: number
	/**
	 * Approximate amount in USD sent by the user.
	 */
	input_amount_usd?: number
	/**
	 * Symbol for the crypto currency being swap from in exchange for some other crypto currency. For example BTC in a BTC-ETH swap
	 */
	input_currency: string
	/**
	 * The amount for the output currency
	 */
	output_amount: number
	/**
	 * Symbol for the crypto currency being swap to. For example ETH in a BTC-ETH swap
	 */
	output_currency: string
	/**
	 * id of the payment (id of the transaction from nabu payments)
	 */
	payment_id?: string
	/**
	 * What platform the event was started from. (WALLET)

	 */
	platform: string
	/**
	 * The type of account the swap funds are coming from. (USERKEY for ON_CHAIN and TO_USERKEY directions, TRADING for INTERNAL and FROM_USERKEY directions)
	 */
	to_account_type: string
	/**
	 * id of the transaction from nabu gateway custodial_transaction table
	 */
	transaction_id: string
}
export interface SwapClicked {
	/**
	 * Device type from where the event was triggered.
	 */
	device: string
	/**
	 * What button we are referring to. 
CURRENCY_PAGE : CTA or menu on the coin page next to balance. 
DASHBOARD_PROMO : announcement card or promo on dashboard. 
DEEP_LINK : any deep linking
NAVIGATION : navigation bar. 
PRICES_PAGE : prices page in wallet. 
SEND: comes from Send product. 
SETTINGS : Settings page

	 */
	origin: string
	/**
	 * What platform the user is clicking from
	 */
	platform: string
}
export interface SwapCompleted {
	/**
	 * Device type from where the event was triggered.
	 */
	device: string
	/**
	 * What type of swap transactions it is, as a direction from/to Custodial or Non Custodial Wallet. INTERNAL is from TRADING to TRADING wallets. ON_CHAIN is from USERKEY to USERKEY. FROM_USERKEY is from USERKEY to TRADING wallets. TO_USERKEY is from TRADING to USERKEY wallets
	 */
	direction: string
	/**
	 * The type of account the swap funds are coming from. (USERKEY for ON_CHAIN and FROM_USERKEY directions, TRADING for INTERNAL and TO_USERKEY)
	 */
	from_account_type: string
	/**
	 * The amount for the input currency
	 */
	input_amount: number
	/**
	 * Approximate amount in USD sent by the user.
	 */
	input_amount_usd: number
	/**
	 * Symbol for the crypto currency being swap from in exchange for some other crypto currency. For example BTC in a BTC-ETH swap
	 */
	input_currency: string
	/**
	 * The amount for the output currency
	 */
	output_amount: number
	/**
	 * Symbol for the crypto currency being swap to. For example ETH in a BTC-ETH swap
	 */
	output_currency: string
	/**
	 * id of the payment (id of the transaction from nabu payments)
	 */
	payment_id?: string
	/**
	 * What platform the event was started from. (WALLET)

	 */
	platform: string
	/**
	 * Spread percentage applied to the exchange rate
	 */
	spread_percentage: number
	/**
	 * The type of account the swap funds are coming from. (USERKEY for ON_CHAIN and TO_USERKEY directions, TRADING for INTERNAL and FROM_USERKEY directions)
	 */
	to_account_type: string
	/**
	 * id of the transaction from nabu gateway custodial_transaction table
	 */
	transaction_id: string
}
export interface SwapCreated {
	/**
	 * Device type from where the event was triggered.
	 */
	device: string
	/**
	 * What type of swap transactions it is, as a direction from/to Custodial or Non Custodial Wallet. INTERNAL is from TRADING to TRADING wallets. ON_CHAIN is from USERKEY to USERKEY. FROM_USERKEY is from USERKEY to TRADING wallets. TO_USERKEY is from TRADING to USERKEY wallets
	 */
	direction: string
	/**
	 * The type of account the swap funds are coming from. (USERKEY for ON_CHAIN and FROM_USERKEY directions, TRADING for INTERNAL and TO_USERKEY)
	 */
	from_account_type: string
	/**
	 * The amount for the input currency
	 */
	input_amount: number
	/**
	 * Approximate amount in USD sent by the user.
	 */
	input_amount_usd?: number
	/**
	 * Symbol for the crypto currency being swap from in exchange for some other crypto currency. For example BTC in a BTC-ETH swap
	 */
	input_currency: string
	/**
	 * The amount for the output currency
	 */
	output_amount: number
	/**
	 * Symbol for the crypto currency being swap to. For example ETH in a BTC-ETH swap
	 */
	output_currency: string
	/**
	 * id of the payment (id of the transaction from nabu payments)
	 */
	payment_id?: string
	/**
	 * What platform the event was started from. (WALLET)

	 */
	platform: string
	/**
	 * The type of account the swap funds are coming from. (USERKEY for ON_CHAIN and TO_USERKEY directions, TRADING for INTERNAL and FROM_USERKEY directions)
	 */
	to_account_type: string
	/**
	 * id of the transaction from nabu gateway custodial_transaction table
	 */
	transaction_id: string
}
export interface SwapExpired {
	/**
	 * Device type from where the event was triggered.
	 */
	device: string
	/**
	 * What type of swap transactions it is, as a direction from/to Custodial or Non Custodial Wallet. INTERNAL is from TRADING to TRADING wallets. ON_CHAIN is from USERKEY to USERKEY. FROM_USERKEY is from USERKEY to TRADING wallets. TO_USERKEY is from TRADING to USERKEY wallets
	 */
	direction: string
	/**
	 * The type of account the swap funds are coming from. (USERKEY for ON_CHAIN and FROM_USERKEY directions, TRADING for INTERNAL and TO_USERKEY)
	 */
	from_account_type: string
	/**
	 * The amount for the input currency
	 */
	input_amount: number
	/**
	 * Approximate amount in USD sent by the user.
	 */
	input_amount_usd?: number
	/**
	 * Symbol for the crypto currency being swap from in exchange for some other crypto currency. For example BTC in a BTC-ETH swap
	 */
	input_currency: string
	/**
	 * The amount for the output currency
	 */
	output_amount: number
	/**
	 * Symbol for the crypto currency being swap to. For example ETH in a BTC-ETH swap
	 */
	output_currency: string
	/**
	 * id of the payment (id of the transaction from nabu payments)
	 */
	payment_id?: string
	/**
	 * What platform the event was started from. (WALLET)
	 */
	platform: string
	/**
	 * The type of account the swap funds are coming from. (USERKEY for ON_CHAIN and TO_USERKEY directions, TRADING for INTERNAL and FROM_USERKEY directions)
	 */
	to_account_type: string
	/**
	 * id of the transaction from nabu gateway custodial_transaction table
	 */
	transaction_id: string
}
export interface SwapFailed {
	/**
	 * Device type from where the event was triggered.
	 */
	device: string
	/**
	 * What type of swap transactions it is, as a direction from/to Custodial or Non Custodial Wallet. INTERNAL is from TRADING to TRADING wallets. ON_CHAIN is from USERKEY to USERKEY. FROM_USERKEY is from USERKEY to TRADING wallets. TO_USERKEY is from TRADING to USERKEY wallets
	 */
	direction: string
	/**
	 * The type of account the swap funds are coming from. (USERKEY for ON_CHAIN and FROM_USERKEY directions, TRADING for INTERNAL and TO_USERKEY)
	 */
	from_account_type: string
	/**
	 * The amount for the input currency
	 */
	input_amount: number
	/**
	 * Approximate amount in USD sent by the user.
	 */
	input_amount_usd?: number
	/**
	 * Symbol for the crypto currency being swap from in exchange for some other crypto currency. For example BTC in a BTC-ETH swap
	 */
	input_currency: string
	/**
	 * The amount for the output currency
	 */
	output_amount: number
	/**
	 * Symbol for the crypto currency being swap to. For example ETH in a BTC-ETH swap
	 */
	output_currency: string
	/**
	 * id of the payment (id of the transaction from nabu payments)
	 */
	payment_id?: string
	/**
	 * What platform the event was started from. (WALLET)
	 */
	platform: string
	/**
	 * The type of account the swap funds are coming from. (USERKEY for ON_CHAIN and TO_USERKEY directions, TRADING for INTERNAL and FROM_USERKEY directions)
	 */
	to_account_type: string
	/**
	 * id of the transaction from nabu gateway custodial_transaction table
	 */
	transaction_id: string
}
export interface SwapFromSelected {
	/**
	 * Device type from where the event was triggered.
	 */
	device: string
	/**
	 * Currency symbol for the currency being swap from in exchange for some other currency. For example BTC in a BTC-ETH swap
	 */
	input_currency: string
	/**
	 * The type of account the swap funds are coming from
	 */
	input_type: string
	/**
	 * From what platform the user wants to Swap from
	 */
	platform: string
}
export interface SwapReceiveSelected {
	/**
	 * Device type from where the event was triggered.
	 */
	device: string
	/**
	 * Currency symbol for the currency being swap to. For example ETH in a BTC-ETH swap
	 */
	output_currency: string
	/**
	 * The type of account the swap funds are going to
	 */
	output_type: string
	/**
	 * From what platform the user wants to Swap from
	 */
	platform: string
}
export interface SwapRejected {
	/**
	 * Device type from where the event was triggered.
	 */
	device: string
	/**
	 * What type of swap transactions it is, as a direction from/to Custodial or Non Custodial Wallet. INTERNAL is from TRADING to TRADING wallets. ON_CHAIN is from USERKEY to USERKEY. FROM_USERKEY is from USERKEY to TRADING wallets. TO_USERKEY is from TRADING to USERKEY wallets
	 */
	direction: string
	/**
	 * error message for the rejection
	 */
	error_message?: string
	/**
	 * The type of account the swap funds are coming from. (USERKEY for ON_CHAIN and FROM_USERKEY directions, TRADING for INTERNAL and TO_USERKEY)
	 */
	from_account_type: string
	/**
	 * The amount for the input currency
	 */
	input_amount: number
	/**
	 * Approximate amount in USD sent by the user.
	 */
	input_amount_usd?: number
	/**
	 * Symbol for the crypto currency being swap from in exchange for some other crypto currency. For example BTC in a BTC-ETH swap
	 */
	input_currency: string
	/**
	 * The amount for the output currency
	 */
	output_amount: number
	/**
	 * Symbol for the crypto currency being swap to. For example ETH in a BTC-ETH swap
	 */
	output_currency: string
	/**
	 * id of the payment (id of the transaction from nabu payments)
	 */
	payment_id?: string
	/**
	 * What platform the event was started from. (WALLET)
	 */
	platform: string
	/**
	 * What platform the event was started from. (WALLET)
	 */
	property: string
	/**
	 * The main reason why creating the swap order was rejected.
	 */
	rejection_reason: string
	/**
	 * The type of account the swap funds are coming from. (USERKEY for ON_CHAIN and TO_USERKEY directions, TRADING for INTERNAL and FROM_USERKEY directions)
	 */
	to_account_type: string
}
export interface SwapRequested {
	/**
	 * Device type from where the event was triggered.
	 */
	device: string
	/**
	 * The exchange rate of the swap, how much 1 input_currency is worth in output_currency.. For example, for a BTC-ETH swap, we would have 1 BTC = 31.48 ETH, we would store 31.48
	 */
	exchange_rate?: number
	/**
	 * The amount for the input currency
	 */
	input_amount: number
	/**
	 * Symbol for the crypto currency being swap from in exchange for some other crypto currency. For example BTC in a BTC-ETH swap
	 */
	input_currency: string
	/**
	 * The type of account the swap funds are coming from. (USERKEY for ON_CHAIN and FROM_USERKEY directions, TRADING for INTERNAL and TO_USERKEY)
	 */
	input_type: string
	/**
	 * Network fee amount for the deposit (input) of the swap transaction. Amount should be for the network_fee_input_currency. Will be 0 for input_type TRADING and > 0 for USERKEY
	 */
	network_fee_input_amount: number
	/**
	 * Network fee currency for the deposit (input) of the swap transaction, for the network_fee_input_amount
	 */
	network_fee_input_currency: string
	/**
	 * Network fee amount for the destination (output) of the swap transaction. Amount should be for the network_fee_output_currency. Will be 0 for output_type TRADING and > 0 for USERKEY
	 */
	network_fee_output_amount: number
	/**
	 * Network fee currency for the destination (output) of the swap transaction, for the network_fee_output_amount
	 */
	network_fee_output_currency: string
	/**
	 * The amount for the output currency
	 */
	output_amount: number
	/**
	 * Symbol for the crypto currency being swap to. For example ETH in a BTC-ETH swap
	 */
	output_currency: string
	/**
	 * The type of account the swap funds are going to. (USERKEY for ON_CHAIN and TO_USERKEY directions, TRADING for INTERNAL and FROM_USERKEY directions)
	 */
	output_type: string
	/**
	 * From what platform the user wants to Swap from
	 */
	platform: string
}
export interface SwapViewed {
	/**
	 * Device type from where the event was triggered.
	 */
	device: string
	/**
	 * Path portion of the URL of the page. Equivalent to canonical path which defaults to location.pathname from the DOM API.
	 */
	path?: string
	/**
	 * What platform the page viewed belongs to
	 */
	platform?: string
	/**
	 * Full URL of the previous page. Equivalent to document.referrer from the DOM API.
	 */
	referrer?: string
	/**
	 * Query string portion of the URL of the page. Equivalent to location.search from the DOM API.
	 */
	search?: string
	/**
	 * Title of the page. Equivalent to document.title from the DOM API.
	 */
	title?: string
	/**
	 * Full URL of the page. First we look for the canonical url. If the canonical url is not provided, we use location.href from the DOM API.
	 */
	url?: string
}
export interface SwipeToReceiveOptionUpdated {
	/**
	 * Device type from where the event was triggered.
	 */
	device: string
	/**
	 * Receiving feature was enabled or disabled.
	 */
	is_enabled: boolean
	/**
	 * From what platform the user is managing Security events
	 */
	platform: string
}
export interface SyncMyWidgetPortfolioUpdated {
	/**
	 * Device type from where the event was triggered.
	 */
	device: string
	/**
	 * My Widget Portafolio Sync option enabled or disabled.
	 */
	is_enabled: boolean
	/**
	 * From what platform the user is managing Security events
	 */
	platform: string
}
export interface ThemeSet {
	/**
	 * Device type from where the event was triggered.
	 */
	device?: string
	/**
	 * From what platform the user is using the Settings
	 */
	platform: string
	theme: string
}
export interface TradeAmountEntered {
	/**
	 * Currency for collateral
	 */
	collateral_type?: string
	/**
	 * Device type from where the event was triggered.
	 */
	device: string
	/**
	 * Amount of the trade in input currency
	 */
	input_amount: number
	/**
	 * Ratio of leverage. 2 for 2x, 3 for 3x, etc.
	 */
	leverage_ratio?: number | null
	/**
	 * Limit price of the trade (empty for market orders)
	 */
	limit_price?: number
	/**
	 * What is the trading pair of the trade
	 */
	pair: string
	/**
	 * From what platform the event is triggered
	 */
	platform: string
	/**
	 * whether it's a buy or sell trade
	 */
	side: string
	/**
	 * Stop loss price for leverage
	 */
	stop_loss?: number
	/**
	 * Stop price of the trade (only for stop-limit orders)
	 */
	stop_price?: number
	/**
	 * Time In Force (empty for Market trades, required otherwise)
	 */
	tif: string
	/**
	 * What type of trade is created
	 */
	trade_type: string
	/**
	 * Trade with leverage
	 */
	with_leverage: boolean
}
export interface TradeAmountHelperClicked {
	/**
	 * What amount in amount_currency the user clicks on (either amount or amount_pct should be specified)
	 */
	amount?: number
	/**
	 * What currency  for the amount selected (empty if the amount is in percentage)
	 */
	amount_currency?: string
	/**
	 * What amount percentage the user clicks on (either amount or amount_pct should be specified) Enter 25 if 25% selected
	 */
	amount_pct?: number
	/**
	 * Device type from where the event was triggered.
	 */
	device: string
	/**
	 * Amount of the trade in input currency
	 */
	input_amount: number
	/**
	 * What is the trading pair of the trade
	 */
	pair: string
	/**
	 * From what platform the amount is triggered
	 */
	platform: string
	/**
	 * whether it's a buy or sell trade
	 */
	side: string
	/**
	 * Time In Force (empty for Market trades, required otherwise)
	 */
	tif: string
	/**
	 * What type of trade is created
	 */
	trade_type: string
}
export interface TradeCancellationRequested {
	/**
	 * Device type from where the event was triggered.
	 */
	device: string
	/**
	 * What button the user clicked on to request the cancelation.  OPEN_ORDERS : From the list of open orders. TRADE_HISTORY : from the trade history page. TRADE_DETAILS : bottom of the trade details.
	 */
	origin: string
}
export interface TradeCreated {
	/**
	 * Device type from where the event was triggered.
	 */
	device: string
	/**
	 * the exchange rate, If pair is BTC-USD, it is how much 1 BTC is worth in BTC.
	 */
	exchange_rate: number
	/**
	 * Handle instruction. M for margin order, PSF for spot orders that are created in the background to close a margin position, null for spot orders, C not used at the moment.
	 */
	handle_instruction?: string | null
	/**
	 * Amount of the trade in input currency
	 */
	input_amount: number
	/**
	 * Amount of the trade in USD
	 */
	input_amount_usd: number
	/**
	 * What is the trading pair of the trade
	 */
	pair: string
	/**
	 * whether it's a buy or sell trade
	 */
	side: string
	/**
	 * Time In Force (empty for Market trades, required otherwise)
	 */
	tif?: string
	/**
	 * TBD with Niall
	 */
	trade_id?: string
	/**
	 * What type of trade is created
	 */
	trade_type: string
}
export interface TradeFilled {
	/**
	 * Device type from where the event was triggered.
	 */
	device: string
	/**
	 * the exchange rate, If pair is BTC-USD, it is how much 1 BTC is worth in BTC.
	 */
	exchange_rate: number
	/**
	 * Trade fee in native counter currency. (for BTC-ETH pair it would be ETH). For 0.013 ETH fee, enter 0.013.
	 */
	fee_amount: number
	/**
	 * IMPORTANT : Trade fee in USD. This will be used for revenue information. For 0.12 USD enter 0.12, NOT 12.
	 */
	fee_amount_usd: number
	/**
	 * Handle instruction. M for margin order, PSF for spot orders that are created in the background to close a margin position, null for spot orders, C not used at the moment.
	 */
	handle_instruction: string
	/**
	 * The amount being filled for the trade, the input currency
	 */
	input_amount: number
	/**
	 * The amount being filled for the trade in USD
	 */
	input_amount_usd: number
	/**
	 * Whether the trade fill Adds liquidity (A) = MAKER  or Removes liquidity = TAKER. or NEUTRAL
	 */
	liquidity_indicator: string
	/**
	 * What is the trading pair of the trade
	 */
	pair: string
	/**
	 * Whether it is a Buy or Sell trade
	 */
	side: string
	/**
	 * Time In Force (empty for Market trades, required otherwise)
	 */
	tif: string
	/**
	 * TBD with Niall
	 */
	trade_id?: string
	/**
	 * What type of trade is created
	 */
	trade_type: string
	/**
	 * What is the trading volume of the user in the last 30d, including this input_amount_usd. This is mainly used for Tune integration to reward user based on the user tier.
	 */
	volume_usd_last_30d: number
}
export interface TradePreviewCancelled {
	/**
	 * Device type from where the event was triggered.
	 */
	device: string
	/**
	 * Amount of the trade in input currency
	 */
	input_amount: number
	/**
	 * Limit price of the trade (empty for market orders)
	 */
	limit_price?: number
	/**
	 * What is the trading pair of the trade
	 */
	pair: string
	/**
	 * From what platform the event is triggered
	 */
	platform: string
	/**
	 * whether it's a buy or sell trade
	 */
	side: string
	/**
	 * Stop price of the trade (only for stop-limit orders)
	 */
	stop_price?: number
	/**
	 * Time In Force (empty for Market trades, required otherwise)
	 */
	tif: string
	/**
	 * What type of trade is created
	 */
	trade_type: string
}
export interface TradePreviewRetried {
	/**
	 * Device type from where the event was triggered.
	 */
	device: string
	/**
	 * Why the previously submit trade previous failed
	 */
	failure_reason?: string
	/**
	 * Amount of the trade in input currency
	 */
	input_amount: number
	/**
	 * Limit price of the trade (empty for market orders)
	 */
	limit_price?: number
	/**
	 * What is the trading pair of the trade
	 */
	pair: string
	/**
	 * From what platform the event is triggered
	 */
	platform: string
	/**
	 * whether it's a buy or sell trade
	 */
	side: string
	/**
	 * Stop price of the trade (only for stop-limit orders)
	 */
	stop_price?: number
	/**
	 * Time In Force (empty for Market trades, required otherwise)
	 */
	tif: string
	/**
	 * What type of trade is created
	 */
	trade_type: string
}
export interface TradePreviewSubmitted {
	/**
	 * Device type from where the event was triggered.
	 */
	device: string
	/**
	 * Amount of the trade in input currency
	 */
	input_amount: number
	/**
	 * Limit price of the trade (empty for market orders)
	 */
	limit_price?: number
	/**
	 * What is the trading pair of the trade
	 */
	pair: string
	/**
	 * From what platform the event is triggered
	 */
	platform: string
	/**
	 * whether it's a buy or sell trade
	 */
	side: string
	/**
	 * Stop price of the trade (only for stop-limit orders)
	 */
	stop_price?: number
	/**
	 * Time In Force (empty for Market trades, required otherwise)
	 */
	tif: string
	/**
	 * What type of trade is created
	 */
	trade_type: string
}
export interface TradingClicked {
	/**
	 * Device type from where the event was triggered.
	 */
	device: string
	/**
	 * what button we are referring to. NAVIGATION (mobile only) : navigation bar. TOP_MARKETS (mobile only) : click on the trading pair in Top Markets page, HOMEPAGE (web only) : the View Exchange button. PAIR_MENU : the pair selection. When clicking on the tab on web, or on the select from dropdown on mobile

	 */
	origin: string
	/**
	 * What platform the user is clicking from
	 */
	platform: string
}
export interface TradingViewed {
	/**
	 * Device type from where the event was triggered.
	 */
	device: string
	/**
	 * What trading pair is being viewed
	 */
	pair: string
	/**
	 * Path portion of the URL of the page. Equivalent to canonical path which defaults to location.pathname from the DOM API.
	 */
	path?: string
	/**
	 * What platform the page viewed belongs to
	 */
	platform: string
	/**
	 * Full URL of the previous page. Equivalent to document.referrer from the DOM API.
	 */
	referrer?: string
	/**
	 * Query string portion of the URL of the page. Equivalent to location.search from the DOM API.
	 */
	search?: string
	/**
	 * Title of the page. Equivalent to document.title from the DOM API.
	 */
	title?: string
	/**
	 * Full URL of the page. First we look for the canonical url. If the canonical url is not provided, we use location.href from the DOM API.
	 */
	url?: string
}
export interface TwoStepVerificationDisabled {
	/**
	 * Device type from where the event was triggered.
	 */
	device?: string
	/**
	 * From what platform the user is managing Security events
	 */
	platform: string
	/**
	 * Which was the verification option activated before the user disabled two-step security? Authenticator App, Yubikey or Mobile Number
	 */
	two_step_option: string
}
export interface TwoStepVerificationEnabled {
	/**
	 * Device type from where the event was triggered.
	 */
	device?: string
	/**
	 * From what platform the user is managing Security events
	 */
	platform: string
	/**
	 * Which verification option was activated? Authenticator App, Yubikey or Mobile Number
	 */
	two_step_option: string
}
export interface TwoStepVerificationOptionClicked {
	/**
	 * Device type from where the event was triggered.
	 */
	device: string
	/**
	 * From what platform the user is managing Security events
	 */
	platform: string
	/**
	 * Authenticator App, Yubikey or Mobile Number
	 */
	two_step_option: string
}
export interface UpgradeVerificationClicked {
	''?: Record<string, any>
	/**
	 * Device type from where the event was triggered.
	 */
	device: string
	/**
	 * From what screen or action the user started the verification. What button we are referring to. 
AIRDROP: . 
DASHBOARD_PROMO : announcement card or promo on dashboard. EDD : when an upgrade is required because an Enhanced Due Diligence required for a high risk user. DEPOSIT : when depositing funds requires upgrading.
FIAT_FUNDS : when trying to deposit fiat. ONBOARDING : during a usual onboarding process.
RESUBMISSION : navigation bar.
SAVINGS (web only) : comes from interest savings product. 
SETTINGS: settings page. SIGN_UP : gold verification prompted at sign up upon account creation.  
SIMPLEBUY : from buy or sell product. SIMPLETRADE : from Simple Trade product in exchange.
SWAP: swap product. UNKNOWN : where origin could not be match to a product or other enums, or is hard to get
	 */
	origin: string
	/**
	 * What platform the Upgrade Verification was clicked from
	 */
	platform: string
	/**
	 * What tier the user is trying to update to. 1 = Silver, 2 = Gold, 3 = SDD + silver, 5 = Platinium
	 */
	tier: number | null
}
export interface UserProductEligible {
	/**
	 * Used to check blocked regions and enabled currencies. (e.g. EUR)
	 */
	currency: string | null
	/**
	 * Product name that the eligibility is checked for
	 */
	product: string
}
export interface UserProductNotEligible {
	/**
	 * Used to check blocked regions and enabled currencies. (e.g. EUR)
	 */
	currency: string | null
	/**
	 * Reason for the inelegibility
	 */
	ineligibility_reason: string
	/**
	 * What platform the event was started from. (WALLET for wallet products nd EXCHANGE if product=MERCURY
	 */
	platform: string
	/**
	 * Product name that the eligibility is checked for
	 */
	product: string
}
export interface UserSddNotEligible {
	/**
	 * Reason for the inelegibility
	 */
	ineligibility_reason: string
}
export interface VerificationCodeSubmitted {
	/**
	 * Device type from where the event was triggered.
	 */
	device: string
	/**
	 * From what platform the user is managing Security events
	 */
	platform: string
	/**
	 * Authenticator App, Yubikey or Mobile Number
	 */
	two_step_option: string
}
export interface VerificationCompleted {
	/**
	 * What platform the verification was started from. (WALLET if product=SWAP and EXCHANGE if product=MERCURY in the  kyc verification table from nabu gateway)
	 */
	platform: string
	/**
	 * what entity is performing the verification. Typically BLOCKCHAIN or VERIFF
	 */
	provider: string
	/**
	 * The tier the verification is about. 1 (Silver) or 2 (Gold) or 3 (SDD)
	 */
	tier: number
}
export interface VerificationRejected {
	/**
	 * What platform the verification was started from. (WALLET if product=SWAP and EXCHANGE if product=MERCURY in the  kyc verification table from nabu gateway)
	 */
	platform: string
	/**
	 * The entity that verifies the identity
	 */
	provider: string
	/**
	 * The tier the verification is about. 1 (Silver) or 2 (Gold) or 3 (SDD)
	 */
	tier: number
}
export interface VerificationStarted {
	/**
	 * What platform the verification was started from. (WALLET if product=SWAP and EXCHANGE if product=MERCURY in the  kyc verification table from nabu gateway)
	 */
	platform: string
	/**
	 * The entity that verifies the identity
	 */
	provider?: string
	/**
	 * Only available for tier 2 (Gold). Missing for tier 1 (Silver) and 3 (SDD)
	 */
	tier: number
}
export interface VerificationSubmissionFailed {
	/**
	 * what device the verification submission was sent from
	 */
	device: string
	/**
	 * why the verification submission failed
	 */
	failure_reason: string
	/**
	 * What platform the verification was started from. (WALLET if product=SWAP and EXCHANGE if product=MERCURY in the  kyc verification table from nabu gateway)
	 */
	platform: string
	/**
	 * The entity that verifies the identity
	 */
	provider: string
	/**
	 * The tier the verification is about. 1 (Silver) or 2 (Gold) or 3 (SDD)
	 */
	tier: number
}
export interface WalletAccessViaTorUpdated {
	/**
	 * Device type from where the event was triggered.
	 */
	device?: string
	/**
	 * True if user only allowed login from IP whitelist.
	 */
	is_blocked: boolean
	/**
	 * From what platform the user is managing Security events

	 */
	platform: string
}
export interface WalletHyperlinkClicked {
	''?: Record<string, any>
	/**
	 * What device the event is tracked from
	 */
	device: string
	/**
	 * From which part of the page was the button clicked
	 */
	origin?: string
	/**
	 * What platform the event is referring to.
	 */
	platform: string
	/**
	 * Path portion of the URL of the page from where the button is clicked.
  PRICES: from the explorer general price page with all the coins listed. 
 PRICES_CURRENCY : blockchain.com/prices/[currency] : from the explorer price page about a specific crypto. .COM_WALLET :
blockchain.com/wallet. EXPLORER : https://www.blockchain.com/explorer
	 */
	platform_path?: string
}
export interface WalletSignedUp {
	/**
	 * Country, as iso code alpha 2, provided by the user at sign up
	 */
	country?: string
	/**
	 * If applicable, country state, as ISO 3166-2 (US-NY for example),  provided by the user at sign up
	 */
	country_state?: string
	/**
	 * What device the user created a wallet from
	 */
	device: string
	/**
	 * What platform the user is creating his wallet account from.
	 */
	platform: string
}
export interface WithdrawalAmountEntered {
	/**
	 * The amount the user will withdraw (before fee applies)
	 */
	amount: number
	/**
	 * the currency the user wants to withdraw
	 */
	currency: string
	/**
	 * Device type from where the event was triggered.
	 */
	device: string
	/**
	 * What platform the user is withdraw funds from
	 */
	platform: string
	/**
	 * How the funds will be withdrawn : 
BANK_ACCOUNT: funds sent to a bank account. 
BANK_TRANSFER : Funds sent to Linked account via Open Banking or ACH. CRYPTO : withdrawing to a crypto address
	 */
	withdrawal_method: string
}
export interface WithdrawalAmountHelperClicked {
	/**
	 * If the button explicitly displays the amount in a specific currency, what is the currency being clicked on for the max amount
	 */
	amount_currency?: number
	/**
	 * What amount percentage the user clicks on (either amount or amount_pct should be specified) Enter 25 if 25% selected
	 */
	amount_pct: number
	/**
	 * the currency the user wants to withdraw
	 */
	currency: string
	/**
	 * Device type from where the event was triggered.
	 */
	device: string
	/**
	 * From what platform the amount is triggered
	 */
	platform: string
	/**
	 * How the funds will be withdrawn : 
BANK_ACCOUNT: funds sent to a bank account. 
BANK_TRANSFER : Funds sent to Linked account via Open Banking or ACH. CRYPTO : withdrawing to a crypto address
	 */
	withdrawal_method: string
}
export interface WithdrawalAmountMaxClicked {
	/**
	 * If the button explicitly displays the amount in a specific currency, what is the currency being clicked on for the max amount
	 */
	amount_currency?: number
	/**
	 * the currency the user wants to withdraw
	 */
	currency: string
	/**
	 * Device type from where the event was triggered.
	 */
	device: string
	/**
	 * What platform the user is withdraw funds from
	 */
	platform: string
	/**
	 * How the funds will be withdrawn : 
BANK_ACCOUNT: funds sent to a bank account. 
BANK_TRANSFER : Funds sent to Linked account via Open Banking or ACH. 
	 */
	withdrawal_method: string
}
export interface WithdrawalAmountMinClicked {
	/**
	 * If the button explicitly displays the amount in a specific currency, what is the currency being clicked on for the max amount
	 */
	amount_currency?: string
	/**
	 * the currency the user wants to withdraw
	 */
	currency: string
	/**
	 * Device type from where the event was triggered.
	 */
	device: string
	/**
	 * What platform the user is withdraw funds from
	 */
	platform: string
	/**
	 * How the funds will be withdrawn : 
BANK_ACCOUNT: funds sent to a bank account. 
BANK_TRANSFER : Funds sent to Linked account via Open Banking or ACH. 
	 */
	withdrawal_method: string
}
export interface WithdrawalClicked {
	/**
	 * Device type from where the event was triggered.
	 */
	device: string
	/**
	 * What Withdrawal button we are referring to. BALANCE : for the exchange, next to the balance (total account value) info on the main trading page. CURRENCY_PAGE : CTA or menu on the coin page next to balance. LINK_BANK : link a bank flow. LINK_WALLET. PORTFOLIO (exchange) : deposit next to currency balance.

	 */
	origin: string
	/**
	 * What platform the user clicked on the withdrawal
	 */
	platform: string
}
export interface WithdrawalMethodSelected {
	/**
	 * the currency the user wants to withdraw
	 */
	currency: string
	/**
	 * Device type from where the event was triggered.
	 */
	device: string
	/**
	 * What platform the user is withdraw funds from
	 */
	platform: string
	/**
	 * To what type of account the user wants to withdraw funds to. Only makes sense for Exchange. Null otherwise. 
EXCHANGE : Blockchain Exchange wallet 
EXTERNAL : external address outside Blockchain.com. 
SAVINGS : interest saving account. 
TRADING : wallet custodial wallet. 
USERKEY : Non Custodial, Private Key, wallet
	 */
	to_account_type?: string | null
	/**
	 * How the funds will be withdrawn : 
BANK_ACCOUNT: funds sent to a bank account. 
BANK_TRANSFER : Funds sent to Linked account via Open Banking or ACH. CRYPTO : withdrawing to a crypto address
	 */
	withdrawal_method: string
}
export interface WithdrawalViewed {
	/**
	 * Device type from where the event was triggered.
	 */
	device: string
	/**
	 * Path portion of the URL of the page. Equivalent to canonical path which defaults to location.pathname from the DOM API.
	 */
	path?: string
	/**
	 * What platform the user wants to withdraw from
	 */
	platform: string
	/**
	 * Full URL of the previous page. Equivalent to document.referrer from the DOM API.
	 */
	referrer?: string
	/**
	 * Query string portion of the URL of the page. Equivalent to location.search from the DOM API.
	 */
	search?: string
	/**
	 * Title of the page. Equivalent to document.title from the DOM API.
	 */
	title?: string
	/**
	 * Full URL of the page. First we look for the canonical url. If the canonical url is not provided, we use location.href from the DOM API.
	 */
	url?: string
}

export type ViolationHandler = (
	message: Record<string, any>,
	violations: Ajv.ErrorObject[]
) => void

/**
 * The default handler that is fired if none is supplied with setTypewriterOptions.
 * This handler will log a warning message to the console.
 */
export const defaultValidationErrorHandler: ViolationHandler = (
	message,
	violations
) => {
	const msg = JSON.stringify(
		{
			type: 'Typewriter JSON Schema Validation Error',
			description:
				`You made an analytics call (${message.event}) using Typewriter that doesn't match the ` +
				'Tracking Plan spec.',
			errors: violations,
		},
		undefined,
		2
	)

	console.warn(msg)
}

let onViolation = defaultValidationErrorHandler

let analytics: () => SegmentAnalytics.AnalyticsJS | undefined = () => {
	return window.analytics
}

/** Options to customize the runtime behavior of a Typewriter client. */
export interface TypewriterOptions {
	/**
	 * Underlying analytics instance where analytics calls are forwarded on to.
	 * Defaults to window.analytics.
	 */
	analytics?: SegmentAnalytics.AnalyticsJS
	/**
	 * Handler fired when if an event does not match its spec. This handler
	 * does not fire in production mode, because it requires inlining the full
	 * JSON Schema spec for each event in your Tracking Plan.
	 *
	 * By default, it will throw errors if NODE_ENV = "test" so that tests will fail
	 * if a message does not match the spec. Otherwise, errors will be logged to stderr.
	 */
	onViolation?: ViolationHandler
}

/**
 * Updates the run-time configuration of this Typewriter client.
 *
 * @param {TypewriterOptions} options - the options to upsert
 *
 * @typedef {Object} TypewriterOptions
 * @property {Segment.AnalyticsJS} [analytics] - Underlying analytics instance where analytics
 * 		calls are forwarded on to. Defaults to window.analytics.
 * @property {Function} [onViolation] - Handler fired when if an event does not match its spec. This handler does not fire in
 * 		production mode, because it requires inlining the full JSON Schema spec for each event in your Tracking Plan. By default,
 * 		it will throw errors if NODE_ENV="test" so that tests will fail if a message does not match the spec. Otherwise, errors
 * 		will be logged to stderr.
 */
export function setTypewriterOptions(options: TypewriterOptions) {
	analytics = options.analytics
		? () => options.analytics || window.analytics
		: analytics
	onViolation = options.onViolation || onViolation
}

/**
 * Validates a message against a JSON Schema using Ajv. If the message
 * is invalid, the `onViolation` handler will be called.
 */
function validateAgainstSchema(message: Record<string, any>, schema: object) {
	const ajv = new Ajv({ schemaId: 'auto', allErrors: true, verbose: true })
	ajv.addMetaSchema(require('ajv/lib/refs/json-schema-draft-06.json'))
	ajv.addMetaSchema(require('ajv/lib/refs/json-schema-draft-04.json'))

	if (!ajv.validate(schema, message) && ajv.errors) {
		onViolation(message, ajv.errors)
	}
}

/**
 * Helper to attach metadata on Typewriter to outbound requests.
 * This is used for attribution and debugging by the Segment team.
 */
function withTypewriterContext(message: Segment.Options = {}): Segment.Options {
	return {
		...message,
		context: {
			...(message.context || {}),
			typewriter: {
				language: 'typescript',
				version: '7.4.1',
			},
		},
	}
}

/**
 * @typedef AccountPasswordChanged
 * @property {string} account_type - What account we are talking about : USERKEY account : the Private Key (non custodial) wallet. CUSTODIAL : the custodial account allowing user to access their Trading, Savings, and/or Exchange wallets
 * @property {string} [device] - Device type from where the event was triggered.
 * @property {string} platform - From what platform the user is managing Security events

 */
/**
 * @typedef Exchange
 * @property {boolean} [two_fa_mode] - Whether the exchange account has 2FA set up
 * @property {string} [user_id] - Exchange user credentials ID
 */
/**
 * @typedef Exchange1
 * @property {Record<string, any>} [two_fa_mode] - Whether the exchange account has 2FA set up
 * @property {Record<string, any>} [user_id] - Exchange user credentials ID
 */
/**
 * @typedef Nabu
 * @property {boolean} [recovery_eligible] - Whether the nabu user is eligible for recovery. Usually if account has value (> $300 or 1 payment method linked)
 * @property {Record<string, any>} [user_id] - The Nabu User ID. This is from the users table in nabu gateway
 */
/**
 * @typedef Wallet
 * @property {string} [auth_type] - The wallet 2FA type that is enforced.
 * @property {Exchange1} [exchange] - Parameters about the exchange account
 * @property {string} [guid_first_four] - The first four characters of the wallet.guid field
 * @property {boolean} [has_cloud_backup] - Whether the wallet has cloud backups
 * @property {boolean} [is_mobile_setup] - Whether the wallet has a mobile client set up
 * @property {number} [last_mnemonic_backup] - The last time, in unix timestamp, in which a wallet has their mnemonic backup verified
 * @property {string} [mobile_device_type] - The type of device being verified
 * @property {Nabu} [nabu] - Parameter about the nabu account
 */
/**
 * @typedef AccountPasswordReset
 * @property {string} account_type - What account we are talking about : USERKEY account : the Private Key (non custodial) wallet. CUSTODIAL : the custodial account allowing user to access their Trading, Savings, and/or Exchange wallets
 * @property {string} [device] - Device type from where the event was triggered.
 * @property {Exchange} [exchange] - Parameters about the exchange account
 * @property {boolean} [mergeable] - Indicates if possible to merge two unlinked accounts
 * @property {string} platform - what platform the account is for
 * @property {string} site_redirect - In reset : Whether the user is being redirected to the exchange or wallet
 * @property {boolean} [upgradeable] - Indicates if possible to upgrade to a new unified Blockchain.com Account
 * @property {Wallet} [wallet] - Parameters about the wallet account
 * @property {boolean} with_recovery_phrase - Whether the resetting the password was after successfully providing the recovery phrase (True). If Not, (False) it is the reset flow without recovery phrase after acknowledging there could be loss of funds
 */
/**
 * @typedef Exchange2
 * @property {boolean} [two_fa_mode] - Whether the exchange account has 2FA set up
 * @property {string} [user_id] - Exchange user credentials ID
 */
/**
 * @typedef Exchange3
 * @property {Record<string, any>} [two_fa_mode] - Whether the exchange account has 2FA set up
 * @property {Record<string, any>} [user_id] - Exchange user credentials ID
 */
/**
 * @typedef Nabu1
 * @property {boolean} [recovery_eligible] - Whether the nabu user is eligible for recovery. Usually if account has value (> $300 or 1 payment method linked)
 * @property {Record<string, any>} [user_id] - The Nabu User ID. This is from the users table in nabu gateway
 */
/**
 * @typedef Wallet1
 * @property {string} [auth_type] - The wallet 2FA type that is enforced.
 * @property {Exchange3} [exchange] - Parameters about the exchange account
 * @property {string} [guid_first_four] - The first four characters of the wallet.guid field
 * @property {boolean} [has_cloud_backup] - Whether the wallet has cloud backups
 * @property {boolean} [is_mobile_setup] - Whether the wallet has a mobile client set up
 * @property {number} [last_mnemonic_backup] - The last time, in unix timestamp, in which a wallet has their mnemonic backup verified
 * @property {string} [mobile_device_type] - The type of device being verified
 * @property {Nabu1} [nabu] - Parameter about the nabu account
 */
/**
 * @typedef AccountRecoveryFailed
 * @property {string} account_type - What account we are talking about : USERKEY account : the Private Key (non custodial) wallet. CUSTODIAL : the custodial account allowing user to access their Trading, Savings, and/or Exchange wallets
 * @property {string} [device] - Device type from where the event was triggered.
 * @property {Exchange2} [exchange] - Parameters about the exchange account
 * @property {boolean} [mergeable] - Indicates if possible to merge two unlinked accounts
 * @property {string} platform - what platform the account is for
 * @property {string} site_redirect - In reset : Whether the user is being redirected to the exchange or wallet
 * @property {boolean} [upgradeable] - Indicates if possible to upgrade to a new unified Blockchain.com Account
 * @property {Wallet1} [wallet] - Parameters about the wallet account
 */
/**
 * @typedef AddMobileNumberClicked
 * @property {string} device - Device type from where the event was triggered.
 * @property {string} platform - From what platform the user is using the Settings
 */
/**
 * @typedef AddressImported
 * @property {string} currency -
 * @property {string} [device] - Device type from where the event was triggered.
 * @property {boolean} funds_transferred - True if user transferred funds from the imported address to an existing wallet.
 * @property {boolean} label_added - True if the user added a label when importing address
 * @property {string} platform - From what platform the user is using the Settings
 */
/**
 * @typedef AddressInformationEntered
 * @property {string} device - Device type from where the event was triggered.
 * @property {string} platform - What platform the user is entering PII from
 */
/**
 * @typedef AddressLabelEdited
 * @property {string} currency -
 * @property {string} [device] - Device type from where the event was triggered.
 * @property {string} platform - From what platform the user is using the Settings
 * @property {string} transaction_format - Segwit format or Legacy format
 */
/**
 * @typedef AddressMessageVerified
 * @property {string} currency -
 * @property {string} [device] - Device type from where the event was triggered.
 * @property {string} platform - From what platform the user is using the Settings
 */
/**
 * @typedef AddressVerifyMessageClicked
 * @property {string} device - Device type from where the event was triggered.
 * @property {string} platform - From what platform the user is using the Settings
 */
/**
 * @typedef AddressesRevealed
 * @property {string} currency -
 * @property {string} [device] - Device type from where the event was triggered.
 * @property {string} platform - From what platform the user is using the Settings
 * @property {string} transaction_format - Segwit format or Legacy format
 */
/**
 * @typedef AmountSwitched
 * @property {string} device - Device type from where the event was triggered.
 * @property {string} platform - What platform the amount form is from.
 * @property {string} product - for what product the user has switched the amount. BUY: buy crypto with Simplebuy product. SAVINGS : interest savings account product SELL: sell crypto with Simplebuy product. SEND : send product to send or move crypto.  SIMPLEBUY: either buy or sell transaction (prefer BUY or SELL if known). SWAP : swap product
 * @property {string} switch_to - whether the amount switches to FIAT or Crypto. If the users sees $100 and wants to enter amount in BTC, it will click on the button and trigger this event with switch_to = CRYPTO
 */
/**
 * @typedef ApiAccessLinkClicked
 * @property {string} device - Device type from where the event was triggered.
 * @property {string} platform - From what platform the user is managing Security events

 */
/**
 * @typedef ApplicationBackgrounded
 * @property {string} device - Device type from where the event was triggered.
 * @property {string} platfrom - From Which platform (WALLET or EXCHANGE)

 */
/**
 * @typedef ApplicationCrashed
 * @property {string} device - Device type from where the event was triggered.
 * @property {string} platfrom - From Which platform (WALLET or EXCHANGE)

 */
/**
 * @typedef ApplicationInstalled
 * @property {string} build - The build number of the installed app.

 * @property {string} device - Device type from where the event was triggered.
 * @property {string} [gps_adid] - the google play store advertising identifier
 * @property {number} [install_begin_timestamp_server_seconds] - The timestamp in seconds when the install started
 * @property {string} [install_referrer] - The referrer from the google play store referrer api
 * @property {string} platform - From Which platform (WALLET or EXCHANGE)

 * @property {string} version - The version installed.
 */
/**
 * @typedef ApplicationOpened
 * @property {string} build - The build number of the installed app.

 * @property {string} device - Device type from where the event was triggered.
 * @property {boolean} from_background - If application transitioned from “Background” to “Inactive” state prior to foregrounding (as opposed to from “Not Running” state).
 * @property {string} platform - From Which platform (WALLET or EXCHANGE)

 * @property {string} [referring_application] - The value of UIApplicationLaunchOptionsSourceApplicationKey from launchOptions. Automatically collected on iOS only.
 * @property {string} [url] - The value of UIApplicationLaunchOptionsURLKey from launchOptions. Collected on iOS only.
 * @property {string} version - The version installed.
 */
/**
 * @typedef ApplicationUninstalled
 * @property {string} device - Device type from where the event was triggered.
 * @property {string} platform - From Which platform (WALLET or EXCHANGE)

 */
/**
 * @typedef ApplicationUpdated
 * @property {string} build - The build number of the installed app.

 * @property {string} device - Device type from where the event was triggered.
 * @property {string} [installed_version] - Which version was installed the first time.
 * @property {string} platfrom - From Which platform (WALLET or EXCHANGE)

 * @property {string} [previous_build] - The previously recorded build.
 * @property {string} [previous_version] - The previously recorded version.
 * @property {string} version - The version installed.
 */
/**
 * @typedef AutoLogoutPeriodSet
 * @property {string} [device] - Device type from where the event was triggered.
 * @property {number} minutes - minutes set for the max inactivity time period
 * @property {string} platform - From what platform the user is using the Settings
 */
/**
 * @typedef BankAccountStateTriggered
 * @property {string} [bank_name] - What is the bank name. Found in extra_attributes -> 'bankName'. For example, BARCLAYS BANK PLC. Could be empty
 * @property {string} currency - What fiat currency the bank account is for
 * @property {string} [entity] - Payment Entity. Found in distinct(extra_attributes -> 'entity') and could be empty (optional). For example, Fintecture(EU) or "Safeconnect(UK)"
 * @property {string} [institution_name] -
 * @property {string} partner - What is the bank partner. Found in partner column. Should be all upper case like in the table
 * @property {string} [service] - Whether this is ACH, OPEN_BANK. This does not apply for bank accounts, so set value to BANK_ACCOUNT in that case. You could know this by looking at account_ref which is either "ach_account" -> ACH or "open_banking" -> OPEN_BANKING
 * @property {string} state - The updated state of the bank account
 * @property {string} type - What type of account it is. BANK_TRANSFER_ACCOUNT is renamed into BANK_TRANSFER and is for open banking and ach
 */
/**
 * @typedef BeneficiaryUpdated
 * @property {string} currency -
 * @property {string} [institution_name] -
 * @property {string} partner -
 * @property {string} state -
 * @property {string} type -
 */
/**
 * @typedef BiometricsUpdated
 * @property {string} device - Device type from where the event was triggered.
 * @property {boolean} is_enabled - Face Id was enabled or disabled.
 * @property {string} platform - From what platform the user is managing Security events
 */
/**
 * @typedef BuyAmountEntered
 * @property {string} device - Device type from where the event was triggered.
 * @property {string} [frequency] - What is the recurring frequency of the buy. Set it as ONE_TIME if it is not a recurring buy
 * @property {number} input_amount - The amount for the input currency
 * @property {string} input_currency - Currency symbol for the currency being paid in exchange for some crypto. For example USD
 * @property {number} [max_card_limit] - What is the maximum amount (in input_currency) being allowed for the Card order. Should be empty for other payment types. Amount usually recorded as a float. If 500 EUR, record 500.
 * @property {string} output_currency - Currency symbol for the currency being received. For example BTC
 * @property {string} [payment_method] - The payment method used for the order
 * @property {string} platform - What platform the user wants to buy from
 */
/**
 * @typedef BuyAmountHelperClicked
 * @property {number} amount - What amount in amount_currency the user clicks on
 * @property {string} amount_currency - What currency  for the amount selected
 * @property {string} device - Device type from where the event was triggered.
 * @property {string} input_currency - Currency symbol for the currency being paid in exchange for some crypto. For example USD
 * @property {string} output_currency - Currency symbol for the currency being received. For example BTC
 * @property {string} platform - From what platform the amount is triggered
 */
/**
 * @typedef BuyAmountMaxClicked
 * @property {string} [amount_currency] - If the button explicitly displays the amount in a specific currency, what is the currency being clicked on for the max amount
 * @property {string} device - Device type from where the event was triggered.
 * @property {string} input_currency - Currency symbol for the currency being paid in exchange for some crypto. For example USD
 * @property {number} [max_card_limit] - What is the maximum amount (in input_currency) being allowed for the Card order. Should be empty for other payment types. Amount usually recorded as a float. If 500 EUR, record 500.
 * @property {string} output_currency - Currency symbol for the currency being received. For example BTC
 * @property {string} platform - What platform the user wants to buy from
 */
/**
 * @typedef BuyAmountMinClicked
 * @property {string} [amount_currency] - If the button explicitly displays the amount in a specific currency, what is the currency being clicked on for the min amount
 * @property {string} device - Device type from where the event was triggered.
 * @property {string} input_currency - Currency symbol for the currency being paid in exchange for some crypto. For example USD
 * @property {string} output_currency - Currency symbol for the currency being received. For example BTC
 * @property {string} platform - What platform the user wants to buy from
 */
/**
 * @typedef BuyCancelled
 * @property {string} [device] - Device the payment was made from
 * @property {number} [fee_amount] - Fee (in "currency") being charged for the payment.
 * @property {number} [fee_amount_usd] - Amount in USD payed by the user.
 * @property {number} [input_amount] - The amount for the input currency, usually as a float. For USD, it should be for example 1.23, meaning 1.23 USD
 * @property {number} [input_amount_usd] - The amount paid by the user in USD, usually as a float. it should be for example 10.23, meaning 10.23 USD
 * @property {string} input_currency - Currency symbol for the currency being paid by the user in exchange for some crypto. For example USD

 * @property {boolean} [is_recurring_buy] - Whether the buy order was created automatically by a recurring buy order. It is when no "recurringBuyId" is found in input_attributes
 * @property {number} [output_amount] - The amount for the output currency, usually as a float. For BTC, it should be for example 1.23, meaning 1.23 BTC

 * @property {string} output_currency - Currency symbol for the currency being received by the user. For example BTC

 * @property {string} [payment_id] - id of the payment (id of the transaction from nabu payments)
 * @property {string} payment_method - The payment method used for the buy order. (the paymentType in simple_transactions input_attributes)
 * @property {string} platform - What platform the event was started from. (WALLET if product=SIMPLEBUY and EXCHANGE if product=MERCURY

 * @property {string} product - The Product for which the buy order is (the product columns of the simple_transactions table)
 * @property {string} [quote_id] - The id used for the new pricing fee model (WALLET)
 * @property {string | null} [recurring_buy_id] - If the buy order was generated from a recurring buy, what is that recurringBuyId. Null otherwise
 * @property {string} [transaction_id] - The id of the transaction for the buy order (the id of the simple_transactions table in nabu gateway)
 */
/**
 * @typedef BuyCompleted
 * @property {string} [device] - Device the payment was made from
 * @property {number} [fee_amount] - Fee (in "currency") being charged for the payment.
 * @property {number} [fee_amount_usd] - Amount in USD payed by the user.
 * @property {number} input_amount - The amount for the input currency, usually as a float. For BTC, it should be for example 1.23, meaning 1.23 BTC
 * @property {number} input_amount_usd - The amount paid by the user in USD, usually as a float. it should be for example 10.23, meaning 10.23 USD
 * @property {string} input_currency - Currency symbol for the currency being paid by the user in exchange for some crypto. For example USD

 * @property {boolean} [is_recurring_buy] - Whether the buy order was created automatically by a recurring buy order. It is when no "recurringBuyId" is found in input_attributes
 * @property {number} [output_amount] - The amount for the output currency, usually as a float. For BTC, it should be for example 1.23, meaning 1.23 BTC

 * @property {string} output_currency - Currency symbol for the currency being received by the user. For example BTC

 * @property {string} [payment_id] - id of the payment (id of the transaction from nabu payments)
 * @property {string} payment_method - The payment method used for the buy order. (the paymentType in simple_transactions input_attributes)
 * @property {string} [platform] - What platform the event was started from. (WALLET if product=SIMPLEBUY and EXCHANGE if product=MERCURY

 * @property {string} product - The Product for which the buy order is (the product columns of the simple_transactions table)
 * @property {string} [quote_id] - The id used for the new pricing fee model (WALLET)
 * @property {string | null} [recurring_buy_id] - If the buy order was generated from a recurring buy, what is that recurringBuyId. Null otherwise
 * @property {number} spread_percentage - Spread percentage applied to the exchange rate
 * @property {string} [transaction_id] - The id of the transaction for the buy order (the id of the simple_transactions table in nabu gateway)
 */
/**
 * @typedef BuyCreated
 * @property {string} [device] - Device the payment was made from
 * @property {number} [fee_amount] - Fee (in "currency") being charged for the payment.
 * @property {number} [fee_amount_usd] - Amount in USD payed by the user.
 * @property {number} [input_amount] - The expected amount for the input currency, usually as a float. For BTC, it should be for example 1.23, meaning 1.23 BTC. Exact amount is only in Buy Completed
 * @property {number} [input_amount_usd] - The amount paid by the user in USD, usually as a float. it should be for example 10.23, meaning 10.23 USD
 * @property {string} input_currency - Currency symbol for the currency being paid by the user in exchange for some crypto. For example USD

 * @property {boolean} [is_recurring_buy] - Whether the buy order was created automatically by a recurring buy order. It is when no "recurringBuyId" is found in input_attributes
 * @property {number} [output_amount] - The expected amount for the output currency, usually as a float. For BTC, it should be for example 1.23, meaning 1.23 BTC. Exact amount is only in Buy Completed
 * @property {string} output_currency - Currency symbol for the currency being received by the user. For example BTC

 * @property {string} [payment_id] - id of the payment (id of the transaction from nabu payments)
 * @property {string} payment_method - The payment method used for the buy order. (the paymentType in simple_transactions input_attributes)
 * @property {string} platform - What platform the event was started from. (WALLET if product=SIMPLEBUY and EXCHANGE if product=MERCURY

 * @property {string} product - The Product for which the buy order is (the product columns of the simple_transactions table)
 * @property {string} [quote_id] - The id used for the new pricing fee model (WALLET)
 * @property {string | null} [recurring_buy_id] - If the buy order was generated from a recurring buy, what is that recurringBuyId. Null otherwise
 * @property {string} [transaction_id] - The id of the transaction for the buy order (the id of the simple_transactions table in nabu gateway)
 */
/**
 * @typedef BuyExpired
 * @property {string} [device] - Device the payment was made from
 * @property {number} [fee_amount] - Fee (in "currency") being charged for the payment.
 * @property {number} [fee_amount_usd] - Amount in USD payed by the user.
 * @property {number} [input_amount] - The amount for the input currency, usually as a float. For BTC, it should be for example 1.23, meaning 1.23 BTC
 * @property {number} [input_amount_usd] - The amount paid by the user in USD, usually as a float. it should be for example 10.23, meaning 10.23 USD
 * @property {string} input_currency - Currency symbol for the currency being paid by the user in exchange for some crypto. For example USD

 * @property {boolean} [is_recurring_buy] - Whether the buy order was created automatically by a recurring buy order. It is when no "recurringBuyId" is found in input_attributes
 * @property {number} [output_amount] - The amount for the output currency, usually as a float. For BTC, it should be for example 1.23, meaning 1.23 BTC

 * @property {string} output_currency - Currency symbol for the currency being received by the user. For example BTC

 * @property {string} [payment_id] - id of the payment (id of the transaction from nabu payments)
 * @property {string} payment_method - The payment method used for the buy order. (the paymentType in simple_transactions input_attributes)
 * @property {string} platform - What platform the event was started from. (WALLET if product=SIMPLEBUY and EXCHANGE if product=MERCURY

 * @property {string} product - The Product for which the buy order is (the product columns of the simple_transactions table)
 * @property {string} [quote_id] - The id used for the new pricing fee model (WALLET)
 * @property {string | null} [recurring_buy_id] - If the buy order was generated from a recurring buy, what is that recurringBuyId. Null otherwise
 * @property {string} [transaction_id] - The id of the transaction for the buy order (the id of the simple_transactions table in nabu gateway)
 */
/**
 * @typedef BuyFailed
 * @property {string} [device] - Device the payment was made from
 * @property {number} [fee_amount] - Fee (in "currency") being charged for the payment.
 * @property {number} [fee_amount_usd] - Amount in USD payed by the user.
 * @property {number} [input_amount] - The amount for the input currency, usually as a float. For BTC, it should be for example 1.23, meaning 1.23 BTC
 * @property {number} [input_amount_usd] - The amount paid by the user in USD, usually as a float. it should be for example 10.23, meaning 10.23 USD
 * @property {string} input_currency - Currency symbol for the currency being paid by the user in exchange for some crypto. For example USD

 * @property {boolean} [is_recurring_buy] - Whether the buy order was created automatically by a recurring buy order. It is when no "recurringBuyId" is found in input_attributes
 * @property {number} [output_amount] - The amount for the output currency, usually as a float. For BTC, it should be for example 1.23, meaning 1.23 BTC

 * @property {string} output_currency - Currency symbol for the currency being received by the user. For example BTC

 * @property {string} [payment_id] - id of the payment (id of the transaction from nabu payments)
 * @property {string} payment_method - The payment method used for the buy order. (the paymentType in simple_transactions input_attributes)
 * @property {string} platform - What platform the event was started from. (WALLET if product=SIMPLEBUY and EXCHANGE if product=MERCURY

 * @property {string} product - The Product for which the buy order is (the product columns of the simple_transactions table)
 * @property {string} [quote_id] - The id used for the new pricing fee model (WALLET)
 * @property {string | null} [recurring_buy_id] - If the buy order was generated from a recurring buy, what is that recurringBuyId. Null otherwise
 * @property {string} [transaction_id] - The id of the transaction for the buy order (the id of the simple_transactions table in nabu gateway)
 */
/**
 * @typedef BuyFrequencySelected
 * @property {string} device - Device type from where the event was triggered.
 * @property {string} frequency - What is the recurring frequency of the buy. Set it as ONE_TIME if it is not a recurring buy
 * @property {string} platform - What platform the user wants to buy from
 */
/**
 * @typedef BuyLearnMoreClicked
 * @property {string} device - Device type from where the event was triggered.
 * @property {string} [platform] - What platform the user wants to buy from
 * @property {string} type - What does the user want to learn more about ? WITHDRAWAL_LOCK
 */
/**
 * @typedef BuyPaymentMethodSelected
 * @property {string} device - Device type from where the event was triggered.
 * @property {string} payment_type - What payment type is selected : 
BANK_ACCOUNT: funds sent from a bank account. 
BANK_TRANSFER : Funds sent from Linked account via Open Banking or ACH. 
FUNDS: Funds taken from available funds in fiat wallet. 
PAYMENT_CARD:  by debit or credit card
 * @property {string} platform - What platform the user wants to buy from
 */
/**
 * @typedef BuyRejected
 * @property {string} [device] - Device the payment was made from
 * @property {string} [error_reason] - Error message related to the rejection. This is more detailed than the rejection_reason 
 * @property {number} [fee_amount] - Fee (in "currency") being charged for the payment.
 * @property {number} [fee_amount_usd] - Amount in USD payed by the user.
 * @property {number} [input_amount] - The expected amount for the input currency, usually as a float. For BTC, it should be for example 1.23, meaning 1.23 BTC. The exact amount might not be known.
 * @property {number} [input_amount_usd] - The amount paid by the user in USD, usually as a float. it should be for example 10.23, meaning 10.23 USD
 * @property {string} input_currency - Currency symbol for the currency being paid by the user in exchange for some crypto. For example USD

 * @property {boolean} [is_recurring_buy] - Whether the buy order was created automatically by a recurring buy order. It is when no "recurringBuyId" is found in input_attributes
 * @property {number} [output_amount] - The amount for the output currency, usually as a float. For BTC, it should be for example 1.23, meaning 1.23 BTC. The exact amount might not be known.

 * @property {string} output_currency - Currency symbol for the currency being received by the user. For example BTC

 * @property {string} [payment_id] - id of the payment (id of the transaction from nabu payments)
 * @property {string} payment_method - The payment method used for the buy order. (the paymentType in simple_transactions input_attributes)
 * @property {string} platform - What platform the event was started from. (WALLET if product=SIMPLEBUY and EXCHANGE if product=MERCURY

 * @property {string} product - The Product for which the buy order is (the product columns of the simple_transactions table)
 * @property {string} [quote_id] - The id used for the new pricing fee model (WALLET)
 * @property {string | null} [recurring_buy_id] - If the buy order was generated from a recurring buy, what is that recurringBuyId. Null otherwise
 * @property {string} [rejection_details] - More details about the rejection, if more context would be useful to know
 * @property {string} rejection_reason - The main reason why creating the buy order was rejected.
 */
/**
 * @typedef BuySellClicked
 * @property {string} device - Device type from where the event was triggered.
 * @property {string} origin - What button we are referring to. 
BUY_WIDGET: buy widget from Explorer. 
CURRENCY_PAGE : cta or menu on the coin page next to balance. 
DASHBOARD_PROMO : announcement card or promo on dashboard. 
DCA_EXPLAINER : from the DCA (Dollar Cost Averaging)) Info Viewed.
DEEP_LINK : any deep link other than BUY_WIDGET
NAVIGATION : navigation bar.
PENDING_ORDER : user looks up details about pending order.
PRICE_CHART (web only). 
SAVINGS (web only) : comes from interest savings product. 
SAVINGS_CONFIRMATION : from the confirmation screen of an interest savings deposit.
SEND: comes from Send product. 
SELL (web only) : from sell product. 
SIMPLETRADE: from simple trade general product page 
TRANSACTION_DETAILS : from historical transaction details. 
TRANSACTION_LIST : from the historical transaction list
WELCOME : from the onboarding flow. 
 * @property {string} platform - What platform the user is clicking from
 * @property {string} [type] - Whether this is a BUY or SELL click. Sometimes it is the same button (e.g. Buy/Sell in navigation bar), in that case leave empty. Otherwise add whether it is Buy or Sell.
 */
/**
 * @typedef BuySellViewed
 * @property {Record<string, any>} [] - 
 * @property {string} device - Device type from where the event was triggered.

 * @property {string} [path] - Path portion of the URL of the page. Equivalent to canonical path which defaults to location.pathname from the DOM API.
 * @property {string} platform - What platform the page viewed belongs to
 * @property {string} [referrer] - Full URL of the previous page. Equivalent to document.referrer from the DOM API.
 * @property {string} [search] - Query string portion of the URL of the page. Equivalent to location.search from the DOM API.
 * @property {string} [title] - Title of the page. Equivalent to document.title from the DOM API.
 * @property {string} [type] - Whether this is a BUY or SELL screen or page viewed. Sometimes it is the same button (e.g. Buy/Sell in navigation bar), in that case leave empty. Otherwise add whether it is Buy or Sell.
 * @property {string} [url] - Full URL of the page. First we look for the canonical url. If the canonical url is not provided, we use location.href from the DOM API.
 */
/**
 * @typedef BuyWidgetAmountEntered
 * @property {string} device - What device the event is tracked from
 * @property {number} input_amount - 

 * @property {string} input_currency - Currency symbol for the currency being paid in exchange for some crypto. For example USD
 * @property {string} output_currency - Currency symbol for the currency being received. For example BTC
 * @property {string} platform - What platform the event is referring to
 */
/**
 * @typedef BuyWidgetClicked
 * @property {string} [currency] - If available, what is the currency the user wants to buy ? For example in the Explorer crypto prices page, did he click on a specific currency ?
 * @property {string} device - What device the event is tracked from
 * @property {string} origin - From which page was the widget clicked? HOME : Buy Crypto from landing page or explorer home page. CRYPTO_PRICES : from the explorer general price page with all the coins listed. CRYPTO_PRICE_DETAILS : from the explorer price page about a specific crypto
 * @property {string} platform - What platform the event is referring to
 */
/**
 * @typedef CameraPermissionChecked
 * @property {string} device - Device the user was requested to access the camera from
 * @property {boolean} is_authorised - whether the camera access is authorised
 * @property {string} origin - Whether the permission was checked during KYC verification or when scanning a QR_CODE
 * @property {string} platform - Platform the user is using wallet connect from. Currently it will be only available from the WALLET
 */
/**
 * @typedef CameraPermissionRequestActioned
 * @property {string} action - What action the user took on the request. ALLOW : the user allows the device to access the camera. REJECT : the user does not allow the device to access the camera
 * @property {string} device - Device the user answered the request from
 * @property {string} platform - Platform the user is using wallet connect from. Currently it will be only available from the WALLET
 */
/**
 * @typedef CancelRecurringBuyClicked
 * @property {string} device - Device type from where the event was triggered.
 * @property {string} frequency - What is the frequency of the recurring buy. Also called period in the backend.
 * @property {number} input_amount - The amount for the input currency
 * @property {string} input_currency - Currency symbol for the currency being paid in exchange for some crypto. For example USD
 * @property {string} origin - What button we are referring to : RECURRING_BUY_DETAILS : When looking at the details of an active recurring buy. TRANSACTION_DETAILS : When looking at the details of the buy transaction that came from a recurring buy
 * @property {string} output_currency - Currency symbol for the currency being received. For example BTC
 * @property {string} payment_method - The payment method used for the recurring buy order
 * @property {string} platform - What platform the user wants to set up recurring buy from
 */
/**
 * @typedef CardStateTriggered
 * @property {string} country_billing - The country used in the billing address. extra_attributes -> 'billing_address' ->> 'country'
 * @property {string} currency - Currency of the card
 * @property {string} [device] - Device type from where the event was triggered.
 * @property {string} [institution_name] -
 * @property {string} [issuer] - What entity or bank issued the card, such as Barclays, Revolut etc. (extra_attributes -> 'card' ->> 'issuer' from account).
 * @property {string} partner - The card partner. From the partner column. Should be all upper case like in the table.
 * @property {string} state - The updated state of the card
 * @property {string} type - Type of card. from extra_attributes -> 'card' ->> 'type' from account, transformed to upper_case. visa -> VISA. master_card -> MASTER_CARD
 */
/**
 * @typedef ChangeMobileNumberClicked
 * @property {string} device - Device type from where the event was triggered.

 * @property {string} platform - From what platform the user is using the Settings
 */
/**
 * @typedef ChangePinClicked
 * @property {string} device - Device type from where the event was triggered.
 * @property {string} platform - From what platform the user is managing Security events
 */
/**
 * @typedef Exchange4
 * @property {boolean} [two_fa_mode] - Whether the exchange account has 2FA set up
 * @property {string} [user_id] - Exchange user credentials ID
 */
/**
 * @typedef Exchange5
 * @property {Record<string, any>} [two_fa_mode] - Whether the exchange account has 2FA set up
 * @property {Record<string, any>} [user_id] - Exchange user credentials ID
 */
/**
 * @typedef Nabu2
 * @property {boolean} [recovery_eligible] - Whether the nabu user is eligible for recovery. Usually if account has value (> $300 or 1 payment method linked)
 * @property {Record<string, any>} [user_id] - The Nabu User ID. This is from the users table in nabu gateway
 */
/**
 * @typedef Wallet2
 * @property {string} [auth_type] - The wallet 2FA type that is enforced.
 * @property {Exchange5} [exchange] - Parameters about the exchange account
 * @property {string} [guid_first_four] - The first four characters of the wallet.guid field
 * @property {boolean} [has_cloud_backup] - Whether the wallet has cloud backups
 * @property {boolean} [is_mobile_setup] - Whether the wallet has a mobile client set up
 * @property {number} [last_mnemonic_backup] - The last time, in unix timestamp, in which a wallet has their mnemonic backup verified
 * @property {string} [mobile_device_type] - The type of device being verified
 * @property {Nabu2} [nabu] - Parameter about the nabu account
 */
/**
 * @typedef CloudBackupCodeScanned
 * @property {string} device - Device type from where the event was triggered.
 * @property {Exchange4} [exchange] - Parameters about the exchange account
 * @property {boolean} [mergeable] - Indicates if possible to merge two unlinked accounts
 * @property {string} platform - What platform the user is is recovering the account from
 * @property {string} site_redirect - Whether the user is being redirected to the exchange or wallet
 * @property {boolean} [upgradeable] - Indicates if possible to upgrade to a new unified Blockchain.com Account
 * @property {Wallet2} [wallet] - Parameters about the wallet account
 */
/**
 * @typedef CoinSearchSubmitted
 * @property {string} [currency] - Currency symbol for the currency being selected to trade by the user.
 * @property {string} device - What device the event is tracked from
 * @property {string} platform - What platform the user is searching from. For now, on BLOCKCHAIN_COM, the search is on the navigation bar, while on the explorer the search is just below next to the breadcrumb
 */
/**
 * @typedef ConnectedDappActioned
 * @property {string} action - What action the user is doing. LAUNCH or DISCONNECT
 * @property {string} app_name - What is the name of the application being actioned on. Prefer "Proper Case" name rather than snake_case or camelCase
 * @property {string} device - Device the user user is using wallet connect from
 * @property {string} origin - What button we are referring to. APPS_LIST : the list of already connected apps
 * @property {string} platform - Platform the user is using wallet connect from. Currently it will be only available from the WALLET
 */
/**
 * @typedef ConnectedDappClicked
 * @property {string} app_name - What is the name of the application being clicked on. Prefer "Proper Case" name rather than snake_case or camelCase
 * @property {string} device - Device the user user is using wallet connect from
 * @property {string} origin - What button we are referring to. APPS_LIST : the list of already connected apps
 * @property {string} platform - Platform the user is using wallet connect from. Currently it will be only available from the WALLET
 */
/**
 * @typedef ConnectedDappsListClicked
 * @property {string} device - The device the user clicked on the button to view the list of Apps from
 * @property {string} origin - What button we are referring to. QR_CODE : when a link pops up after scanning a QR code. SETTINGS : from the settings
 * @property {string} platform - Platform the user is using wallet connect from. Currently it will be only available from the WALLET
 */
/**
 * @typedef ConnectedDappsListViewed
 * @property {string} device - The device the user viewed the list of Apps from
 * @property {string} platform - Platform the user is using wallet connect from. Currently it will be only available from the WALLET
 */
/**
 * @typedef CryptoLinkHandlingClicked
 * @property {string} device - Device type from where the event was triggered.
 * @property {string} platform - From what platform the user is using the Settings
 */
/**
 * @typedef CryptoLinkHandlingEnabled
 * @property {string} [device] - Device type from where the event was triggered.
 * @property {string} platform - From what platform the user is using the Settings
 */
/**
 * @typedef CustodialTransferCompleted
 * @property {number} amount - Amount being transferred, in the given currency. e.g. for 1.23 BTC, the amount is 1.23
 * @property {number} [amount_usd] - Amount (in USD) being transferred. e.g. for 10.23, for $10.23
 * @property {string} currency - What currency is being transferred
 * @property {string} destination - To what account type the funds are coming from. This is usually named as a product SAVINGS or SIMPLEBUY
 * @property {string} [device] - Device type from where the event was triggered.
 * @property {string} origin - From what account type the funds are coming from. This is usually named as the product like SAVINGS or SIMPLEBUY
 * @property {string} platform - What platform the event was started from. WALLET is the only option

 * @property {string} transfer_id - id of the custodial transfer
 */
/**
 * @typedef DappConnectionActioned
 * @property {string} action - What action the user is doing. CONFIRM : when confirming the connection to the app. CANCEL : when cancelling the connection request
 * @property {string} app_name - What is the name of the application being actioned on. Prefer "Proper Case" name rather than snake_case or camelCase
 * @property {string} device - Device the user user is using wallet connect from
 * @property {string} platform - Platform the user is using wallet connect from. Currently it will be only available from the WALLET
 */
/**
 * @typedef DappConnectionConfirmed
 * @property {string} app_name - What is the name of the application being actioned on. Prefer "Proper Case" name rather than snake_case or camelCase
 * @property {string} device - Device the user user is using wallet connect from
 * @property {string} platform - Platform the user is using wallet connect from. Currently it will be only available from the WALLET
 */
/**
 * @typedef DappConnectionRejected
 * @property {string} app_name - What is the name of the application being actioned on. Prefer "Proper Case" name rather than snake_case or camelCase
 * @property {string} device - Device the user user is using wallet connect from
 * @property {string} platform - Platform the user is using wallet connect from. Currently it will be only available from the WALLET
 */
/**
 * @typedef DappRequestActioned
 * @property {string} action - What action is taken by the user
 * @property {string} app_name - What is the name of the application being actioned on. Prefer "Proper Case" name rather than snake_case or camelCase
 * @property {string} device - Device the user user is using wallet connect from
 * @property {string} method - Type of dapp request
 * @property {string} platform - Platform the user is using wallet connect from. Currently it will be only available from the WALLET
 */
/**
 * @typedef DashboardClicked
 * @property {string} device - Device type from where the event was triggered. (mobile only)
 * @property {string} origin - Where does the user come from. 
NAVIGATION : Home on the navigation bar.  
 * @property {string} platform - What platform the user is clicking from
 */
/**
 * @typedef DashboardViewed
 * @property {string} device - Device type from where the event was triggered. (mobile only)
 * @property {string} [path] - Path portion of the URL of the page. Equivalent to canonical path which defaults to location.pathname from the DOM API.
 * @property {string} platform - What platform the page viewed belongs to
 * @property {string} [referrer] - Full URL of the previous page. Equivalent to document.referrer from the DOM API.
 * @property {string} [search] - Query string portion of the URL of the page. Equivalent to location.search from the DOM API.
 * @property {string} [title] - Title of the page. Equivalent to document.title from the DOM API.
 * @property {string} [url] - Full URL of the page. First we look for the canonical url. If the canonical url is not provided, we use location.href from the DOM API.
 */
/**
 * @typedef Campaign
 * @property {string} [medium] - Campaign Medium
 * @property {string} [name] - Campaign Name
 * @property {string} [source] - Campaign Source
 */
/**
 * @typedef DeepLinkClicked
 * @property {Campaign} [campaign] -
 * @property {string} device - Device type from where the event was triggered.
 * @property {string} platfrom -
 * @property {string} [provider] - The deep link provider.
 * @property {string} [url] - The deep link URL clicked.
 */
/**
 * @typedef Campaign1
 * @property {string} [medium] - Campaign Medium
 * @property {string} [name] - Campaign Name
 * @property {string} [source] - Campaign source
 */
/**
 * @typedef DeepLinkOpened
 * @property {Campaign1} [campaign] -
 * @property {string} device - Device type from where the event was triggered.
 * @property {string} platform - Whether the deep link is opened from the Wallet of the Exchange
 * @property {string} platfrom -
 * @property {string} [provider] - The deep link provider.
 * @property {string} [url] - The App URL opened.
 */
/**
 * @typedef DeletedAddressLabel
 * @property {string} [device] - Device type from where the event was triggered.
 * @property {string} platform - From what platform the user is using the Settings
 * @property {string} transaction_format - Segwit format or Legacy format
 */
/**
 * @typedef DepositAmountEntered
 * @property {string} currency - the currency the user wants to deposit
 * @property {string} deposit_method - How the funds will be deposited : 
BANK_ACCOUNT: funds sent from a bank account, this is a classic transfer. 
BANK_TRANSFER : Funds sent from Linked account via Open Banking or ACH. 
 * @property {string} device - Device type from where the event was triggered.
 * @property {number} input_amount - The amount the user will withdraw (before fee applies)
 * @property {number} output_amount - The amount the user will actual get (after fee applies)
 * @property {string} platform - What platform the user is depositing funds to
 */
/**
 * @typedef DepositClicked
 * @property {string} device - Device type from where the event was triggered.
 * @property {string} origin - What button we are referring to. BALANCE : for the exchange, next to the balance (total account value) info on the main trading page. CURRENCY_PAGE : CTA or menu on the coin page next to balance. DEPOSIT: when trying to deposit some funds. LINK_WALLET. PORTFOLIO (exchange) : deposit next to currency balance. RECURRING_BUY : order details or status suggesting to add cash SIGN_UP : when prompted to deposit at sign up SIMPLETRADE : when trying to buy via the Simple Trade product without funds. WITHDRAW: when suggesting to deposit from no funds in withdraw screen. TRADE_TICKET (web only?) : for trade ticket when user has no funds
 * @property {string} platform - What platform the user is clicking from
 */
/**
 * @typedef DepositMethodSelected
 * @property {string} currency - the currency the user wants to deposit
 * @property {string} deposit_method - How the funds will be deposited : 
BANK_ACCOUNT: funds sent from a bank account, this is a classic transfer. 
BANK_TRANSFER : Funds sent from Linked account via Open Banking or ACH. 
 * @property {string} device - Device type from where the event was triggered.
 * @property {string} platform - What platform the user is depositing funds to
 */
/**
 * @typedef DepositViewed
 * @property {string} device - Device type from where the event was triggered.
 * @property {string} [path] - Path portion of the URL of the page. Equivalent to canonical path which defaults to location.pathname from the DOM API.
 * @property {string} [platform] - What platform the page viewed belongs to
 * @property {string} [referrer] - Full URL of the previous page. Equivalent to document.referrer from the DOM API.
 * @property {string} [search] - Query string portion of the URL of the page. Equivalent to location.search from the DOM API.
 * @property {string} [title] - Title of the page. Equivalent to document.title from the DOM API.
 * @property {string} [url] - Full URL of the page. First we look for the canonical url. If the canonical url is not provided, we use location.href from the DOM API.
 */
/**
 * @typedef Exchange6
 * @property {boolean} [two_fa_mode] - Whether the exchange account has 2FA set up
 * @property {string} [user_id] - Exchange user credentials ID
 */
/**
 * @typedef Exchange7
 * @property {Record<string, any>} [two_fa_mode] - Whether the exchange account has 2FA set up
 * @property {Record<string, any>} [user_id] - Exchange user credentials ID
 */
/**
 * @typedef Nabu3
 * @property {boolean} [recovery_eligible] - Whether the nabu user is eligible for recovery. Usually if account has value (> $300 or 1 payment method linked)
 * @property {Record<string, any>} [user_id] - The Nabu User ID. This is from the users table in nabu gateway
 */
/**
 * @typedef Wallet3
 * @property {string} [auth_type] - The wallet 2FA type that is enforced.
 * @property {Exchange7} [exchange] - Parameters about the exchange account
 * @property {string} [guid_first_four] - The first four characters of the wallet.guid field
 * @property {boolean} [has_cloud_backup] - Whether the wallet has cloud backups
 * @property {boolean} [is_mobile_setup] - Whether the wallet has a mobile client set up
 * @property {number} [last_mnemonic_backup] - The last time, in unix timestamp, in which a wallet has their mnemonic backup verified
 * @property {string} [mobile_device_type] - The type of device being verified
 * @property {Nabu3} [nabu] - Parameter about the nabu account
 */
/**
 * @typedef DeviceVerified
 * @property {string} device -
 * @property {Exchange6} [exchange] - Parameters about the exchange account
 * @property {boolean} [mergeable] - Indicates if possible to merge two unlinked accounts
 * @property {string} platform - the platform that received the notification about the device being verified
 * @property {string} [site_redirect] - Whether the user is being redirected to the exchange or wallet
 * @property {boolean} [upgradeable] - Indicates if possible to “upgrade” to a new unified Blockchain.com Account
 * @property {Wallet3} [wallet] - Parameters about the wallet account
 */
/**
 * @typedef EmailChangeClicked
 * @property {string} device - Device type from where the event was triggered.
 * @property {string} platform - From what platform the user is managing Security events
 */
/**
 * @typedef EmailChangeVerificationLinkResent
 * @property {string} [device] - Device type from where the event was triggered.
 * @property {string} platform - From what platform the user is managing Security events
 */
/**
 * @typedef EmailVerificationRequested
 * @property {string} device - Device type from where the event was triggered.
 * @property {string} origin - From what product or flow the request to verify the email was requested. SIGN_UP : just after sign up. VERIFICATION: during a kyc verification process. SECURITY : in the security settings, for example when an email is changed.
 * @property {string} platform - What platform the email verification was requested from
 */
/**
 * @typedef EmailVerificationSkipped
 * @property {string} device - Device type from where the event was triggered.
 * @property {string} origin - From what product or flow the request to verify the email was skipped. SIGN_UP : just after sign up.
 * @property {string} platform - What platform the email verification was requested from
 */
/**
 * @typedef EmailVerified
 * @property {boolean} email_changed - Was there already a verified email?
 * @property {string} platform - What platform the email verification was requested from (if available)
 */
/**
 * @typedef ExchangeHyperlinkClicked
 * @property {Record<string, any>} [] - 
 * @property {string} [currency] - Currency symbol for the currency being selected to trade by the user.
 * @property {string} device - What device the event is tracked from
 * @property {string} origin - From which part of the page was the button clicked
 * @property {string} platform - What platform the event is referring to.
 * @property {string} platform_path - Path portion of the URL of the page from where the button is clicked.
  PRICES: from the explorer general price page with all the coins listed. 
 PRICES_CURRENCY : blockchain.com/prices/[currency] : from the explorer price page about a specific crypto. .COM_EXCHANGE :
blockchain.com/exchange. EXPLORER : https://www.blockchain.com/explorer
 */
/**
 * @typedef ExchangeSignedUp
 * @property {string} device - What device the user created an exchange account from
 * @property {string} platform - What platform the user is creating his exchange account from.
 */
/**
 * @typedef ExplorerSearchClicked
 * @property {string} device - What device the event is tracked from
 * @property {string} platform - What platform the user is searching from. For now, on BLOCKCHAIN_COM, the search is on the navigation bar, while on the explorer the search is just below next to the breadcrumb
 */
/**
 * @typedef ExplorerSearchSubmitted
 * @property {string} device - What device the event is tracked from
 * @property {string} platform - What platform the user is searching from. For now, on BLOCKCHAIN_COM, the search is on the navigation bar, while on the explorer the search is just below next to the breadcrumb
 */
/**
 * @typedef ExplorerSearchWithNoResults
 * @property {string} device - What device the event is tracked from
 * @property {string} platform - What platform the user is searching from. For now, on BLOCKCHAIN_COM, the search is on the navigation bar, while on the explorer the search is just below next to the breadcrumb
 * @property {string} search_query - query with no results
 */
/**
 * @typedef FiatCurrencySelected
 * @property {string} currency - What fiat currency was selected
 * @property {string} device - Device type from where the event was triggered.
 * @property {string} platform - What platform the page viewed belongs to
 */
/**
 * @typedef FooterOptionClicked
 * @property {string} device - What device the event is tracked from
 * @property {string} [download_app] - hyperlink to the app store or google store
 * @property {string} [item] - What option was clicked
 * @property {string} platform - What platform the event is referring to
 * @property {string} [social_media] - Social media hyperlink clicked
 */
/**
 * @typedef HistoryClicked
 * @property {string} device - Device type from where the event was triggered.
 * @property {string} origin - What button we are referring to. NAVIGATION : navigation bar
 * @property {string} platform - What platform the page viewed belongs to
 * @property {string} [type] - what type of history the button will bring the user to.
 */
/**
 * @typedef HistoryViewed
 * @property {string} device - Device type from where the event was triggered.
 * @property {string} [path] - Path portion of the URL of the page. Equivalent to canonical path which defaults to location.pathname from the DOM API.
 * @property {string} platform - What platform the page viewed belongs to
 * @property {string} [referrer] - Full URL of the previous page. Equivalent to document.referrer from the DOM API.
 * @property {string} [search] - Query string portion of the URL of the page. Equivalent to location.search from the DOM API.
 * @property {string} [title] - Title of the page. Equivalent to document.title from the DOM API.
 * @property {string} [type] - What type of history is viewed
 * @property {string} [url] - Full URL of the page. First we look for the canonical url. If the canonical url is not provided, we use location.href from the DOM API.
 */
/**
 * @typedef ImportAddressClicked
 * @property {string} device - Device type from where the event was triggered.
 * @property {string} platform - From what platform the user is using the Settings
 */
/**
 * @typedef ImportWalletCancelled
 * @property {string} device - Device type from where the event was triggered.
 * @property {string} origin - What button we are referring to. CONFIRMATION : "Go Back" In the final confirmation screen after entering a valid passphrase
 * @property {string} platform - What platform the user is is recovering the account from
 * @property {string} site_redirect - Whether the user is being redirected to the exchange or wallet
 */
/**
 * @typedef ImportWalletClicked
 * @property {string} device - Device type from where the event was triggered.
 * @property {string} origin - What button we are referring to. (mobile) LAUNCH_SCREEN. (web) To Be Determined !
 * @property {string} platform - What platform the user is is recovering the account from
 * @property {string} site_redirect - Whether the user is being redirected to the exchange or wallet
 */
/**
 * @typedef ImportWalletConfirmed
 * @property {string} device - Device type from where the event was triggered.
 * @property {string} platform - What platform the user is is recovering the account from
 * @property {string} site_redirect - Whether the user is being redirected to the exchange or wallet
 */
/**
 * @typedef Campaign2
 * @property {string} [ad_creative] - The ad creative name.
 * @property {string} [ad_group] - The ad group name.
 * @property {string} [content] - The content of the campaign.
 * @property {string} [medium] - Identifies what type of link was used.
 * @property {string} [name] - The name of the attributed campaign.
 * @property {string} [source] - Campaign source — attributed ad network
 */
/**
 * @typedef InstallAttributed
 * @property {Campaign2} [campaign] -
 * @property {string} device - Device type from where the event was triggered.
 * @property {string} platform -
 * @property {string} [provider] - The attribution provider.
 */
/**
 * @typedef InterestClicked
 * @property {string} device - Device type from where the event was triggered.
 * @property {string} origin - What button we are referring to. NAVIGATION : navigation bar. DASHBOARD_PROMO : announcement card or promo on dashboard.
 * @property {string} platform - What platform the user is clicking from
 */
/**
 * @typedef InterestDepositAmountEntered
 * @property {number} [amount] - If available, what amount in native fiat currency being entered. e.g. 12.23 if 12.23 USD.
 * @property {string} [amount_currency] - If available,, what is the native fiat currency in which the amount is entered. e.g. USD. Empty if amount only entered in BTC terms
 * @property {string} currency - The currency the user wants to deposit to their savings account. e.g. BTC
 * @property {string} [device] - Device type from where the event was triggered.
 * @property {string} from_account_type - From what account the user wants to deposit funds from
 * @property {number} input_amount - The amount in crypto currency the user sends to their interest savings account. This amount is before any fees are subtracted.
 * @property {number | null} interest_rate - What is in the interest rate in percentage being offered. For example, for 4.5%, enter 4.5
 * @property {number} [output_amount] - The amount in crypto currency the user will actually get in their interest savings account. This amount is after any fees are subtracted
 * @property {string} platform - What platform the user wants to deposit funds from
 */
/**
 * @typedef InterestDepositClicked
 * @property {string} [currency] - What currency the user is about to deposit to their interest savings account (if known)
 * @property {string} device - Device type from where the event was triggered.
 * @property {string} origin - What button we are referring to. CURRENCY_PAGE : CTA or menu on the coin page next to balance. SAVINGS_PAGE: general interest savings overview page or screen (currently Earn Interest Clicked).  SAVINGS_CONFIRMATION : from the confirmation screen of an interest deposit. SEND : from the send product

 * @property {string} platform - What platform the user is clicking from
 */
/**
 * @typedef InterestDepositMaxAmountClicked
 * @property {string} [amount_currency] - If the button explicitly displays the amount in a specific currency, what is the currency being clicked on for the max amount
 * @property {string} currency - The currency the user wants to deposit to their savings account. e.g. BTC
 * @property {string} [device] - Device type from where the event was triggered.
 * @property {string} from_account_type - From what account the user wants to deposit funds from
 * @property {string} platform - What platform the user wants to deposit funds from
 */
/**
 * @typedef InterestDepositMinAmountClicked
 * @property {string} [amount_currency] - If the button explicitly displays the amount in a specific currency, what is the currency being clicked on for the min amount
 * @property {string} currency - The currency the user wants to deposit to their savings account. e.g. BTC
 * @property {string} device - Device type from where the event was triggered.
 * @property {string} from_account_type - From what account the user wants to deposit funds from
 * @property {string} platform - What platform the user wants to deposit funds from
 */
/**
 * @typedef InterestDepositViewed
 * @property {string} [currency] - What currency the user is about to deposit to their interest savings account (if known)
 * @property {string} device - Device type from where the event was triggered.
 * @property {string} [path] - Path portion of the URL of the page. Equivalent to canonical path which defaults to location.pathname from the DOM API.
 * @property {string} platform - What platform the page viewed belongs to
 * @property {string} [referrer] - Full URL of the previous page. Equivalent to document.referrer from the DOM API.
 * @property {string} [search] - Query string portion of the URL of the page. Equivalent to location.search from the DOM API.
 * @property {string} [title] - Title of the page. Equivalent to document.title from the DOM API.
 * @property {string} [url] - Full URL of the page. First we look for the canonical url. If the canonical url is not provided, we use location.href from the DOM API.
 */
/**
 * @typedef InterestSubmitInformationClicked
 * @property {string} device - Device type from where the event was triggered.
 * @property {string} origin - what button we are referring to.  SAVINGS_PAGE: general interest savings overview page or screen. SAVINGS_CONFIRMATION : SAVINGS_PAGE general interest savings overview page or screen
 * @property {string} platform - What platform the user wants to submit information from
 */
/**
 * @typedef InterestViewed
 * @property {string} device - Device type from where the event was triggered.
 * @property {string} [path] - Path portion of the URL of the page. Equivalent to canonical path which defaults to location.pathname from the DOM API.
 * @property {string} platform - What platform the page viewed belongs to
 * @property {string} [referrer] - Full URL of the previous page. Equivalent to document.referrer from the DOM API.
 * @property {string} [search] - Query string portion of the URL of the page. Equivalent to location.search from the DOM API.
 * @property {string} [title] - Title of the page. Equivalent to document.title from the DOM API.
 * @property {string} [url] - Full URL of the page. First we look for the canonical url. If the canonical url is not provided, we use location.href from the DOM API.
 */
/**
 * @typedef InterestWithdrawalClicked
 * @property {string} [currency] - What currency the user is about to withdraw from their interest savings account (if known)
 * @property {string} device - Device type from where the event was triggered.
 * @property {string} origin - What button we are referring to.  CURRENCY_PAGE : CTA or menu on the coin page next to balance. SAVINGS_PAGE: general interest savings overview page or screen
 * @property {string} platform - What platform the user is clicking from
 */
/**
 * @typedef InterestWithdrawalViewed
 * @property {string} [currency] - What currency the user is about to withdraw from their interest savings account (if known)
 * @property {string} device - Device type from where the event was triggered.
 * @property {string} [path] - Path portion of the URL of the page. Equivalent to canonical path which defaults to location.pathname from the DOM API.
 * @property {string} platform - What platform the page viewed belongs to
 * @property {string} [referrer] - Full URL of the previous page. Equivalent to document.referrer from the DOM API.
 * @property {string} [search] - Query string portion of the URL of the page. Equivalent to location.search from the DOM API.
 * @property {string} [title] - Title of the page. Equivalent to document.title from the DOM API.
 * @property {string} [url] - Full URL of the page. First we look for the canonical url. If the canonical url is not provided, we use location.href from the DOM API.
 */
/**
 * @typedef IpWhitelistUpdated
 * @property {string} [device] - Device type from where the event was triggered.
 * @property {boolean} is_empty - True if list is empty
 * @property {string} platform - From what platform the user is managing Security events

 */
/**
 * @typedef LanguageSet
 * @property {string} [device] - Device type from where the event was triggered.
 * @property {string} language - Language in Alpha-2 code (2 letters lower cases)
 * @property {string} platform - From what platform the user is using the Settings
 */
/**
 * @typedef LeftMenuSelectionClicked
 * @property {string} device - What device the event is tracked from
 * @property {string} item - What item is clicked on the navigation header
 * @property {string} platform - What platform the event is referring to
 */
/**
 * @typedef LegalEntityUpdated
 * @property {string} device - What device the user created the account from
 * @property {string} legal_entity - legal entity has been updated to this label
 * @property {string} legal_entity_before_update - the users past legal entity
 * @property {string} legal_entity_reason - legal entity to a user has been updated based on this reason.
 * @property {string} platform - What platform the user signed up for
 */
/**
 * @typedef LinkBankClicked
 * @property {string} device - Device type from where the event was triggered.
 * @property {string} origin - What button we are referring to. DEPOSIT : from depositing funds. SETTINGS : user's settings page. BUY : from the Buy flow.  WITHDRAW : from withdrawing funds.
 * @property {string} platform - What platform the user wants to link a bank for
 */
/**
 * @typedef LinkBankConditionsApproved
 * @property {string} bank_name - Bank name, in camel case, for example "Barclays", "Revolut"
 * @property {string} device - Device type from where the event was triggered.
 * @property {string} partner - What is the bank partner. This will be used to know whether it is ACH or OB
 * @property {string} platform - What platform the user wants to link a bank for
 * @property {string} provider - What provider is used to link the bank
 */
/**
 * @typedef LinkBankSelected
 * @property {string} bank_name - Bank name, in camel case, for example "Barclays", "Revolut"
 * @property {string} device - Device type from where the event was triggered.
 * @property {string} partner - What is the bank partner for the account being linked
 * @property {string} platform - What platform the user wants to link a bank for
 */
/**
 * @typedef LinkCardClicked
 * @property {string} device - Device type from where the event was triggered.
 * @property {string} origin - What button we are referring to. SETTINGS : user's settings page. BUY : from the Buy flow.
 * @property {string} platform - What platform the user wants to link a bank for
 */
/**
 * @typedef LocalCurrencySet
 * @property {string} currency - What fiat currency
 * @property {string} [device] - Device type from where the event was triggered.
 * @property {string} platform - From what platform the user is using the Settings
 */
/**
 * @typedef Exchange8
 * @property {boolean} [two_fa_mode] - Whether the exchange account has 2FA set up
 * @property {string} [user_id] - Exchange user credentials ID
 */
/**
 * @typedef Exchange9
 * @property {Record<string, any>} [two_fa_mode] - Whether the exchange account has 2FA set up
 * @property {Record<string, any>} [user_id] - Exchange user credentials ID
 */
/**
 * @typedef Nabu4
 * @property {boolean} [recovery_eligible] - Whether the nabu user is eligible for recovery. Usually if account has value (> $300 or 1 payment method linked)
 * @property {Record<string, any>} [user_id] - The Nabu User ID. This is from the users table in nabu gateway
 */
/**
 * @typedef Wallet4
 * @property {string} [auth_type] - The wallet 2FA type that is enforced.
 * @property {Exchange9} [exchange] - Parameters about the exchange account
 * @property {string} [guid_first_four] - The first four characters of the wallet.guid field
 * @property {boolean} [has_cloud_backup] - Whether the wallet has cloud backups
 * @property {boolean} [is_mobile_setup] - Whether the wallet has a mobile client set up
 * @property {number} [last_mnemonic_backup] - The last time, in unix timestamp, in which a wallet has their mnemonic backup verified
 * @property {string} [mobile_device_type] - The type of device being verified
 * @property {Nabu4} [nabu] - Parameter about the nabu account
 */
/**
 * @typedef LoginClicked
 * @property {string} device - Device from which the user is signing in 
 * @property {Exchange8} [exchange] - Parameters about the exchange account
 * @property {boolean} [mergeable] - Indicates if possible to merge two unlinked accounts
 * @property {string} origin - What button we are referring to. 
GUEST_LIMITATION (exchange): A specific action from the guest view requires login. HOMEPAGE (dotcom) : from the Blockchain.com or Exchange.blockchain.com home page content. LAUNCH_SCREEN (mobile only) : when login from the launch screen. NAVIGATION (dotcom) : navigation bar. RECOVERY_CLOUD_BACKUP (wallet) : when failing to scan QR code cloud backup and clicking on login. 
 * @property {string} platform - Platform from which the user is signing in
 * @property {string} [site_redirect] - Whether the user is being redirected to the exchange or wallet
 * @property {boolean} [upgradeable] - Indicates if possible to “upgrade” to a new unified Blockchain.com Account
 * @property {Wallet4} [wallet] - Parameters about the wallet account
 */
/**
 * @typedef Exchange10
 * @property {boolean} [two_fa_mode] - Whether the exchange account has 2FA set up
 * @property {string} [user_id] - Exchange user credentials ID
 */
/**
 * @typedef Exchange11
 * @property {Record<string, any>} [two_fa_mode] - Whether the exchange account has 2FA set up
 * @property {Record<string, any>} [user_id] - Exchange user credentials ID
 */
/**
 * @typedef Nabu5
 * @property {boolean} [recovery_eligible] - Whether the nabu user is eligible for recovery. Usually if account has value (> $300 or 1 payment method linked)
 * @property {Record<string, any>} [user_id] - The Nabu User ID. This is from the users table in nabu gateway
 */
/**
 * @typedef Wallet5
 * @property {string} [auth_type] - The wallet 2FA type that is enforced.
 * @property {Exchange11} [exchange] - Parameters about the exchange account
 * @property {string} [guid_first_four] - The first four characters of the wallet.guid field
 * @property {boolean} [has_cloud_backup] - Whether the wallet has cloud backups
 * @property {boolean} [is_mobile_setup] - Whether the wallet has a mobile client set up
 * @property {number} [last_mnemonic_backup] - The last time, in unix timestamp, in which a wallet has their mnemonic backup verified
 * @property {string} [mobile_device_type] - The type of device being verified
 * @property {Nabu5} [nabu] - Parameter about the nabu account
 */
/**
 * @typedef LoginHelpClicked
 * @property {string} device - What device the user is login in from
 * @property {Exchange10} [exchange] - Parameters about the exchange account
 * @property {boolean} [mergeable] - Indicates if possible to merge two unlinked accounts
 * @property {string} origin - what button we are referring to. IDENTIFIER : when failing to provide an identifier. PASSWORD: when failing to provide a correct password. QR_CODE : when failing to scan QR code.
 * @property {string} platform - Platform from which the user is signing in
 * @property {string} [site_redirect] - Whether the user is being redirected to the exchange or wallet
 * @property {boolean} [upgradeable] - Indicates if possible to “upgrade” to a new unified Blockchain.com Account
 * @property {Wallet5} [wallet] - Parameters about the wallet account
 */
/**
 * @typedef Exchange12
 * @property {boolean} [two_fa_mode] - Whether the exchange account has 2FA set up
 * @property {string} [user_id] - Exchange user credentials ID
 */
/**
 * @typedef Exchange13
 * @property {Record<string, any>} [two_fa_mode] - Whether the exchange account has 2FA set up
 * @property {Record<string, any>} [user_id] - Exchange user credentials ID
 */
/**
 * @typedef Nabu6
 * @property {boolean} [recovery_eligible] - Whether the nabu user is eligible for recovery. Usually if account has value (> $300 or 1 payment method linked)
 * @property {Record<string, any>} [user_id] - The Nabu User ID. This is from the users table in nabu gateway
 */
/**
 * @typedef Wallet6
 * @property {string} [auth_type] - The wallet 2FA type that is enforced.
 * @property {Exchange13} [exchange] - Parameters about the exchange account
 * @property {string} [guid_first_four] - The first four characters of the wallet.guid field
 * @property {boolean} [has_cloud_backup] - Whether the wallet has cloud backups
 * @property {boolean} [is_mobile_setup] - Whether the wallet has a mobile client set up
 * @property {number} [last_mnemonic_backup] - The last time, in unix timestamp, in which a wallet has their mnemonic backup verified
 * @property {string} [mobile_device_type] - The type of device being verified
 * @property {Nabu6} [nabu] - Parameter about the nabu account
 */
/**
 * @typedef LoginIdentifierEntered
 * @property {string} device - What device you are viewing the login screen from
 * @property {Exchange12} [exchange] - Parameters about the exchange account
 * @property {string} [identifier_type] - What type of identifier is supplied
 * @property {boolean} [mergeable] - Indicates if possible to merge two unlinked accounts
 * @property {string} platform - Platform from which the user is signing in
 * @property {string} [site_redirect] - Whether the user is being redirected to the exchange or wallet
 * @property {boolean} [upgradeable] - Indicates if possible to “upgrade” to a new unified Blockchain.com Account
 * @property {Wallet6} [wallet] - Parameters about the wallet account
 */
/**
 * @typedef LoginIpRestrictionUpdated
 * @property {string} [device] - Device type from where the event was triggered.
 * @property {boolean} is_restricted - True if only allowing login from IP addresses whitelist.
 * @property {string} platform - From what platform the user is managing Security events

 */
/**
 * @typedef Exchange14
 * @property {boolean} [two_fa_mode] - Whether the exchange account has 2FA set up
 * @property {string} [user_id] - Exchange user credentials ID
 */
/**
 * @typedef Exchange15
 * @property {Record<string, any>} [two_fa_mode] - Whether the exchange account has 2FA set up
 * @property {Record<string, any>} [user_id] - Exchange user credentials ID
 */
/**
 * @typedef Nabu7
 * @property {boolean} [recovery_eligible] - Whether the nabu user is eligible for recovery. Usually if account has value (> $300 or 1 payment method linked)
 * @property {Record<string, any>} [user_id] - The Nabu User ID. This is from the users table in nabu gateway
 */
/**
 * @typedef Wallet7
 * @property {string} [auth_type] - The wallet 2FA type that is enforced.
 * @property {Exchange15} [exchange] - Parameters about the exchange account
 * @property {string} [guid_first_four] - The first four characters of the wallet.guid field
 * @property {boolean} [has_cloud_backup] - Whether the wallet has cloud backups
 * @property {boolean} [is_mobile_setup] - Whether the wallet has a mobile client set up
 * @property {number} [last_mnemonic_backup] - The last time, in unix timestamp, in which a wallet has their mnemonic backup verified
 * @property {string} [mobile_device_type] - The type of device being verified
 * @property {Nabu7} [nabu] - Parameter about the nabu account
 */
/**
 * @typedef LoginMethodSelected
 * @property {string} device - What device you are viewing the login screen from
 * @property {Exchange14} [exchange] - Parameters about the exchange account
 * @property {string} login_method - How the user is trying to log in. APPLE: via Apple ID. GOOGLE : via Google Account. PASSWORD : with a password on mobile or web, PIN : with a PIN on mobile,  SECURE_CHANNEL : by sending a log in request via secure channel to another client.
 * @property {boolean} [mergeable] - Indicates if possible to merge two unlinked accounts
 * @property {string} platform - Platform from which the user is signing in
 * @property {string} [site_redirect] - Whether the user is being redirected to the exchange or wallet
 * @property {boolean} [upgradeable] - Indicates if possible to “upgrade” to a new unified Blockchain.com Account
 * @property {Wallet7} [wallet] - Parameters about the wallet account
 */
/**
 * @typedef LoginRequestApproved
 * @property {string} device - Device type from where the login request is approved
 * @property {string} platform - Whether the request is being approved from the WALLET or the EXCHANGE. Only possible from the WALLET for now
 * @property {string} [request_browser] - The browser being displayed to the user. This is the browser from where the request was sent.
 * @property {string} [request_location_country] - Parsed IP Geolocation displayed to the user. This is the ip from where the request was sent. country format TBD : ideally alpha 2 iso code
 * @property {string} request_platform - The channel opening requester platform (exchange/wallet)
 */
/**
 * @typedef LoginRequestDenied
 * @property {string} device - Device type from where the login request is denied
 * @property {string | null} [error] - The error that was experienced by the user
 * @property {string} [method] - Whether the rejection came for a secure channel opening request OR for a log in with magic link request.
 * @property {string} platform - Whether the request is being denied from the WALLET or the EXCHANGE. Only possible from the WALLET for now
 * @property {string} [request_browser] - The browser being displayed to the user. This is the browser from where the request was sent.
 * @property {string} [request_location_country] - Parsed IP Geolocation displayed to the user. This is the ip from where the request was sent. country format TBD : ideally alpha 2 iso code
 * @property {string} request_platform - Whether the log in request was sent to log in to the WALLET or the. EXCHANGE.
 */
/**
 * @typedef Exchange16
 * @property {boolean} [two_fa_mode] - Whether the exchange account has 2FA set up
 * @property {string} [user_id] - Exchange user credentials ID
 */
/**
 * @typedef Exchange17
 * @property {Record<string, any>} [two_fa_mode] - Whether the exchange account has 2FA set up
 * @property {Record<string, any>} [user_id] - Exchange user credentials ID
 */
/**
 * @typedef Nabu8
 * @property {boolean} [recovery_eligible] - Whether the nabu user is eligible for recovery. Usually if account has value (> $300 or 1 payment method linked)
 * @property {Record<string, any>} [user_id] - The Nabu User ID. This is from the users table in nabu gateway
 */
/**
 * @typedef Wallet8
 * @property {string} [auth_type] - The wallet 2FA type that is enforced.
 * @property {Exchange17} [exchange] - Parameters about the exchange account
 * @property {string} [guid_first_four] - The first four characters of the wallet.guid field
 * @property {boolean} [has_cloud_backup] - Whether the wallet has cloud backups
 * @property {boolean} [is_mobile_setup] - Whether the wallet has a mobile client set up
 * @property {number} [last_mnemonic_backup] - The last time, in unix timestamp, in which a wallet has their mnemonic backup verified
 * @property {string} [mobile_device_type] - The type of device being verified
 * @property {Nabu8} [nabu] - Parameter about the nabu account
 */
/**
 * @typedef LoginTwoStepVerificationDenied
 * @property {string} device - Device type from where the user is trying to log in
 * @property {Exchange16} [exchange] - Parameters about the exchange account
 * @property {boolean} [mergeable] - Indicates if possible to merge two unlinked accounts
 * @property {string} platform - Platform from which the user is signing in
 * @property {string} [site_redirect] - Whether the user is being redirected to the exchange or wallet
 * @property {boolean} [upgradeable] - Indicates if possible to “upgrade” to a new unified Blockchain.com Account
 * @property {Wallet8} [wallet] - Parameters about the wallet account
 */
/**
 * @typedef Exchange18
 * @property {boolean} [two_fa_mode] - Whether the exchange account has 2FA set up
 * @property {string} [user_id] - Exchange user credentials ID
 */
/**
 * @typedef Exchange19
 * @property {Record<string, any>} [two_fa_mode] - Whether the exchange account has 2FA set up
 * @property {Record<string, any>} [user_id] - Exchange user credentials ID
 */
/**
 * @typedef Nabu9
 * @property {boolean} [recovery_eligible] - Whether the nabu user is eligible for recovery. Usually if account has value (> $300 or 1 payment method linked)
 * @property {Record<string, any>} [user_id] - The Nabu User ID. This is from the users table in nabu gateway
 */
/**
 * @typedef Wallet9
 * @property {string} [auth_type] - The wallet 2FA type that is enforced.
 * @property {Exchange19} [exchange] - Parameters about the exchange account
 * @property {string} [guid_first_four] - The first four characters of the wallet.guid field
 * @property {boolean} [has_cloud_backup] - Whether the wallet has cloud backups
 * @property {boolean} [is_mobile_setup] - Whether the wallet has a mobile client set up
 * @property {number} [last_mnemonic_backup] - The last time, in unix timestamp, in which a wallet has their mnemonic backup verified
 * @property {string} [mobile_device_type] - The type of device being verified
 * @property {Nabu9} [nabu] - Parameter about the nabu account
 */
/**
 * @typedef LoginTwoStepVerificationEntered
 * @property {string} device - Device type from where the user is trying to log in
 * @property {Exchange18} [exchange] - Parameters about the exchange account
 * @property {boolean} [mergeable] - Indicates if possible to merge two unlinked accounts
 * @property {string} platform - Platform from which the user is signing in
 * @property {string} [site_redirect] - Whether the user is being redirected to the exchange or wallet
 * @property {boolean} [upgradeable] - Indicates if possible to “upgrade” to a new unified Blockchain.com Account
 * @property {Wallet9} [wallet] - Parameters about the wallet account
 */
/**
 * @typedef LogoClicked
 * @property {string} device - Device type from where the event was triggered.
 * @property {string} platform - What platform the user is clicking from
 */
/**
 * @typedef ManageTabSelectionClicked
 * @property {string} currency - From which currency tab was the event activated. BTC or BCH
 * @property {string} device - Device type from where the event was triggered.
 * @property {string} platform - From what platform the user is using the Settings
 * @property {string} selection - Example: "Show xPub".  Note: "Recover Funds" option only available for Bitcoin Cash drop down menu.
 */
/**
 * @typedef ManualVerificationRequired
 * @property {string} platform - What platform the verification was started from. (WALLET if product=SWAP and EXCHANGE if product=MERCURY in the  kyc verification table from nabu gateway)
 * @property {string} provider - BLOCKCHAIN or VERIFF
 * @property {number} tier - What tier the user is trying to update to. 1 = Silver, 2 = Gold, 3 = SDD, 4 = SDD +, 5 = Platinium
 */
/**
 * @typedef MarginCollateralClicked
 * @property {string} [device] - From what device the user is adding collateral
 * @property {string} pair - What is the trading pair of the position
 * @property {string} platform - From what platform the user is adding collateral
 * @property {string} [position_id] - Id of the margin position for which the collateral is being added/removed
 */
/**
 * @typedef MarginCollateralUpdated
 * @property {string} action - Whether add or remove collateral
 * @property {number} amount - The amount of collateral to be added or removed.
 * @property {string} currency - what collateral currency the user is adding or removing
 * @property {string} [device] - From what device the user is adding collateral
 * @property {string} [gw_order_id] - Id of the gateway order created to add/remove the collateral
 * @property {string} pair - What is the trading pair of the position
 * @property {string} platform - From what platform the user is adding collateral
 * @property {string} [position_id] - Id of the position for which the collateral is being added/removed
 */
/**
 * @typedef MarginOrderCancelled
 * @property {number} amount - The amount of the order.  
 * @property {string} device - Device type from where the event was triggered
 * @property {string} pair - What is the trading pair of the position
 * @property {string} platform - From what platform the event is triggered

 * @property {string} trade_type - what type of trade
 */
/**
 * @typedef MarginOrderSubmitted
 * @property {string} device - What device the user is using. Only available for WEB for now.
 * @property {number} input_amount - Amount of the trade in input currency
 * @property {number} leverage_ratio - leverage ratio
 * @property {number} [limit_price] - Limit price of the trade (empty for market orders)

 * @property {string} pair - The trading instrument
 * @property {string} platform - What platform offers leverage (EXCHANGE only for now)
 * @property {string} side - What side is selected when the leverage button is clicked. BUY when it says "Buy With Leverage" and SELL when it says "Sell With Leverage"
 * @property {string} trade_type - what type of trade
 */
/**
 * @typedef MarginPositionClosed
 * @property {number} amount - The amount of the order placed to close a margin position.
 * @property {string} [device] - From what device the user is adding collateral
 * @property {number} [limit_price] - The limit price when the position closes with a limit order.
 * @property {string} order_type - The type of the order placed to close a margin position.
 * @property {string} platform - From what platform the user is adding collateral
 * @property {Record<string, any>} [position_id] - Id of the margin position for which the collateral is being added/removed
 */
/**
 * @typedef MarginWaitlistActioned
 * @property {string} action - What action the user performed when shown the Margin waitlist announcement. JOINED : Clicked on a button to join. DISMISSED : clicked anywhere else on the screen or clicks on the small cross to close the announcement
 * @property {string} device - What device is used to action on the announcement
 * @property {string} platform - What platform the user is on : EXCHANGE
 */
/**
 * @typedef MarginWaitlistShown
 * @property {string} device - What device the announcement is shown on
 * @property {string} platform - What platform the user is on : EXCHANGE
 */
/**
 * @typedef MobileAppInstallDeviceUpdated
 * @property {string} device - Device type from where the event was triggered.
 * @property {string} device_app - Whether the device was updated to view APP-Android or APP-iOS instructions
 * @property {string} platform - What platform the user is clicking from
 */
/**
 * @typedef MobileAppInstallIconClicked
 * @property {string} device - Device type from where the event was triggered.
 * @property {string} platform - What platform the user is clicking from
 */
/**
 * @typedef MobileAppInstallLinkCopied
 * @property {string} device - Device type from where the event was triggered.
 * @property {string} device_app - Whether the copied app link is APP-iOS or APP-Android
 * @property {string} platform - What platform the user is clicking from
 */
/**
 * @typedef MobileNumberVerified
 * @property {string} country_code - country of the mobile number, in alpha iso 2 code.
 * @property {string} [device] - Device type from where the event was triggered.
 * @property {string} origin - From which page are they verifying the Mobile Number? Settings or Security
 * @property {string} platform - From what platform the user is using the Settings
 */
/**
 * @typedef MobilePinCodeChanged
 * @property {string} device - Device type from where the event was triggered.
 * @property {string} platform - From what platform the user is managing Security events
 */
/**
 * @typedef MoreNftClicked
 * @property {Record<string, any>} [] -
 * @property {string} device - What device the event is tracked from
 * @property {string} platform - What platform the event is referring to
 */
/**
 * @typedef NftHyperlinkClicked
 * @property {Record<string, any>} [] -
 * @property {string} device - What device the event is tracked from
 * @property {string} item - What item is clicked on the navigation header
 * @property {string} platform - What platform the event is referring to
 */
/**
 * @typedef NftOrderCreated
 * @property {string} device - What device the nft order
 * @property {string} platform - what platform the nft order was from. Only in WALLET
 */
/**
 * @typedef NftOrderFailed
 * @property {string} device - What device the nft order
 * @property {string} platform - what platform the nft order was from. Only in WALLET
 */
/**
 * @typedef NftOrderSucceeded
 * @property {string} device - What device the nft order
 * @property {string} platform - what platform the nft order was from. Only in WALLET
 */
/**
 * @typedef NavigationBreadcrumbsClicked
 * @property {string} device - What device the event is tracked from
 * @property {string} item - What item is clicked on the navigation header
 * @property {string} platform - What platform the event is referring to
 * @property {string} sub_item - What sub item in the breadcrumb is clicked on. NONE if the user clicks on the first level item
 */
/**
 * @typedef NavigationOptionClicked
 * @property {string} device - What device the event is tracked from
 * @property {string} [item] - What item is clicked on the navigation header. Explorer: NONE since it has only one level (old navigation bar). Wallet: OVERVIEW, KEYS, SECURITY. Exchange: FEATURES, FEES, MARKETS, PRIME, AFFILIATE, API
 * @property {string} platform - What platform the event is referring to
 * @property {string} [sub_item] - What sub item in the dropdown menu was clicked
 */
/**
 * @typedef NextAddressAdded
 * @property {string} currency -
 * @property {string} [device] - Device type from where the event was triggered.
 * @property {string} platform - From what platform the user is using the Settings
 * @property {string} transaction_format - Segwit format or Legacy format
 */
/**
 * @typedef NotificationPreferencesUpdated
 * @property {string} device - Device type from where the event was triggered.
 * @property {boolean} [email_enabled] - Whether email notifications is enabled (Only available on WEB)
 * @property {string} platform - From what platform the user is using the Settings
 * @property {boolean} [sms_enabled] - Whether sms notifications is enabled
 */
/**
 * @typedef SearchParams
 * @property {string} [from] - unix timestamp used for custom date range in the prices/currency page
 * @property {number} [scale] - linear scale (default) = 0. logarithmic= 1
 * @property {string} [style] - chart style LINE (default) or CANDELSTICK used in the prices/currency page
 * @property {number} [timeSpan] - days parameter used in the prices/currency page
 * @property {string} [to] - unix timestamp used for custom date range in the prices/currency page
 * @property {string} [utm_campaign] - utm parameter
 * @property {string} [view] - which blockchain network is being requested in the home page
 * @property {boolean} [volume] - show volume on used in the prices/currency page
 */
/**
 * @typedef UrlPaths
 * @property {Record<string, any>} [] - 
 * @property {string} [block] - block hash
 * @property {string} [chart] - which chart was selected from the charts page. example: transactions-per-second
 * @property {string} [currency] - Currency symbol for the currency being requested in the prices page by the user. For example USDT

 * @property {string} [network] - which blockchain network is being requested in tx or block page
 * @property {string} [tx] - tx hash
 */
/**
 * @typedef PageViewed
 * @property {string} device - What device the page is viewed from
 * @property {string} [path] - Path portion of the URL of the page. Equivalent to canonical path which defaults to location.pathname from the DOM API.
 * @property {string} platform - What platform the page viewed belongs to
 * @property {string} [referrer] - Full URL of the previous page. Equivalent to document.referrer from the DOM API.
 * @property {string} [search] - Query string portion of the URL of the page. Equivalent to location.search from the DOM API.
 * @property {SearchParams} [search_params] - parameters passed in the link
 * @property {string} [title] - Title of the page. Equivalent to document.title from the DOM API.
 * @property {string} [url] - Full URL of the page. First we look for the canonical url. If the canonical url is not provided, we use location.href from the DOM API.
 * @property {UrlPaths} [url_paths] - example: blockchain.com/btc/tx/hash  paths: currency:btc tx:hash
 */
/**
 * @typedef PasswordStretchingChanged
 * @property {string} [device] - Device type from where the event was triggered.
 * @property {number} pbkdf2 - PBKDF2 must be between 1 and 20000
 * @property {string} platform - From what platform the user is managing Security events

 */
/**
 * @typedef PaymentRuleExecuted
 * @property {string} decision - The decision of the rule
 * @property {string} [device] - Device type from where the event was triggered.
 * @property {string} payment_id - id of the payment (id of the transaction from nabu payments)
 * @property {string} payment_type - The type of payment. (type column from the transaction table in nabu payments db)
 * @property {string} platfrom - What platform the event was started from. (WALLET if product=SIMPLEBUY and EXCHANGE if product=MERCURY
 * @property {string} [product] - Product for which the payment was made for
 * @property {string} rule_type - The rule
 */
/**
 * @typedef PaymentStateTriggered
 * @property {number} amount - Amount (in "currency") being deposited by the user, usually as a float. For BTC, it should be for example 1.23, meaning 1.23 BTC
 * @property {number} [amount_usd] - Amount in USD deposited by the user.
 * @property {string} [currency] - Currency being deposited by the user
 * @property {string} [device] - Device type from where the event was triggered.
 * @property {string | null} [failure_reason] - if failed, Why the payment failed
 * @property {number} [fee_amount] - Fee (in "currency") being charged for the payment.
 * @property {number} fee_amount_usd - Fee in USD being charged for the payment
 * @property {string} [institution_name] - It is the name of the bank the user has used for the payment. Used specifically with open banking for now
 * @property {string} partner - Payment partner. For example HWS, LHV, EVERYPAY
 * @property {string} payment_id - id of the payment (id of the transaction from nabu payments)
 * @property {string} payment_type - The type of payment. (type column from the transaction table in nabu payments db)
 * @property {string} platform - What platform the event was started from. (WALLET if product=SIMPLEBUY and EXCHANGE if product=MERCURY
 * @property {string} [processing_account] - The processing account used for the card payment
 * @property {string} product - Product for which the payment was made for
 * @property {string} state - Payment status. ideal for tracking status transition timings.
 */
/**
 * @typedef PeeksheetDismissed
 * @property {string} current_step_completed - what is the current completed step of the user. 0 = verification pending, 1 = payment method pending or 2 = Buy never started
 * @property {string} device - Device type from where the Peeksheet was dismissed.
 * @property {string} platform - What platform the Peeksheet was dismissed
 */
/**
 * @typedef PeeksheetProcessClicked
 * @property {string} current_step_completed - what is the current completed step of the user. 0 = verification pending, 1 = payment method pending or 2 = Buy never started
 * @property {string} device - Device type from where the Peeksheet was shown.
 * @property {string} platform - What platform the Peeksheet was displayed
 */
/**
 * @typedef PeeksheetSelectionClicked
 * @property {boolean} button_clicked - True if selection was clicking the main button, False if selection was made from the three items (center)
 * @property {string} current_step_completed - what is the current completed step of the user. 0 = verification pending, 1 = payment method pending or 2 = Buy never started
 * @property {string} device - Device type from which the selection was clicked
 * @property {string} item - Peek sheet item selected
 * @property {string} platform - What platform the Peeksheet selection was clicked
 */
/**
 * @typedef PeeksheetViewed
 * @property {string} current_step_completed - what is the current completed step of the user. 0 = verification pending, 1 = payment method pending or 2 = Buy never started
 * @property {string} device - Device type from where the Peeksheet was shown.
 * @property {string} platform - What platform the Peeksheet was displayed
 */
/**
 * @typedef PersonalInformationEntered
 * @property {string} device - Device type from where the event was triggered.
 * @property {string} platform - What platform the user is entering PII from
 */
/**
 * @typedef PortfolioClicked
 * @property {string} device - Device type from where the event was triggered.
 * @property {string} origin - what button we are referring to. BALANCE : next to the balance (total account value) info on the main trading page. NAVIGATION (mobile only) : navigation bar.
 * @property {string} platform - What platform the user is clicking from
 */
/**
 * @typedef PortfolioViewed
 * @property {string} device - Device type from where the event was triggered.
 * @property {string} [path] - Path portion of the URL of the page. Equivalent to canonical path which defaults to location.pathname from the DOM API.
 * @property {string} platform - What platform the page viewed belongs to
 * @property {string} [referrer] - Full URL of the previous page. Equivalent to document.referrer from the DOM API.
 * @property {string} [search] - Query string portion of the URL of the page. Equivalent to location.search from the DOM API.
 * @property {string} [title] - Title of the page. Equivalent to document.title from the DOM API.
 * @property {string} [url] - Full URL of the page. First we look for the canonical url. If the canonical url is not provided, we use location.href from the DOM API.
 */
/**
 * @typedef PrivateKeysShown
 * @property {string} [currency] - current cryptocurrency information being showed by the user. (Ethereum or Stellar for now) Example: ETH for Ethereum.
 * @property {string} device - Device type from where the event was triggered.
 * @property {string} platform - From what platform the user is using the Settings
 */
/**
 * @typedef Campaign3
 * @property {string} [content] - Push notification content.
 * @property {string} [medium] - Identifies what type of link was used (Push Notification).
 * @property {string} [name] - The name of the attributed campaign.
 * @property {string} [source] - Designates the push provider.
 */
/**
 * @typedef PushNotificationBounced
 * @property {Campaign3} [campaign] -
 * @property {string} device - Device type from where the event was triggered.
 * @property {string} platform -
 */
/**
 * @typedef Campaign4
 * @property {string} [content] - Push notification content.
 * @property {string} [medium] - Identifies what type of link was used (Push Notification).

 * @property {string} [name] - The name of the attributed campaign.
 * @property {string} [source] - Designates the push provider.
 */
/**
 * @typedef PushNotificationReceived
 * @property {Campaign4} [campaign] -
 * @property {string} device - Device type from where the event was triggered.
 * @property {string} platform -
 */
/**
 * @typedef PushNotificationSent
 * @property {string} device - Device type from where the event was triggered.
 * @property {string} [name] -
 * @property {string} platform -
 */
/**
 * @typedef Campaign5
 * @property {string} [content] - Push notification content.
 * @property {string} [medium] - Identifies what type of link was used (Push Notification).

 * @property {string} [name] - The name of the attributed campaign.
 * @property {string} [source] - Designates the push provider. 
 */
/**
 * @typedef PushNotificationTapped
 * @property {Campaign5} [campaign] -
 * @property {string} device - Device type from where the event was triggered.
 * @property {string} platform -
 */
/**
 * @typedef QrCodeClicked
 * @property {string} device - Device the user clicked the QR code from
 * @property {string} origin - What button we are referring to. DASHBOARD : from the Home (=DASHBOARD) page
 * @property {string} platform - Platform the user is using wallet connect from. Currently it will be only available from the WALLET
 */
/**
 * @typedef QrCodeScanned
 * @property {string} device - Device the user user is using wallet connect from
 * @property {string} platform - Platform the user is using wallet connect from. Currently it will be only available from the WALLET
 * @property {string} [qr_type] - What type of QR code is scanned, if it is valid. INVALID : the qr_code scanned is not valid. CRYPTO_ADDRESS : address of a crypto currency to send funds to (CryptoTarget in iOS). DAPP : to connect to a dapp with Wallet Connect. DEEPLINK: when scanning a deeplink. LOG_IN : when opening a secure channel to log in via sso
 */
/**
 * @typedef ReceiveCurrencySelected
 * @property {string} account_type - To what type of account the user wants to receive funds to. 
SAVINGS is the interest saving account. 
TRADING is the wallet custodial wallet. 
USERKEY is the Non Custodial, Private Key, wallet
 * @property {string} currency - The currency the user wants to receive (e.g. BTC)
 * @property {string} device - Device type from where the event was triggered.
 * @property {string} platform - What platform the user wants to receive funds to
 */
/**
 * @typedef ReceiveDetailsCopied
 * @property {string} account_type - To what type of account the user wants to receive funds to. 
SAVINGS is the interest saving account. 
TRADING is the wallet custodial wallet. 
USERKEY is the Non Custodial, Private Key, wallet
 * @property {string} currency - The currency the user wants to receive (e.g. BTC)
 * @property {string} device - Device type from where the event was triggered.
 * @property {string} platform - What platform the user wants to receive funds to
 */
/**
 * @typedef RecoveryPhraseBackedUp
 * @property {string} [device] - Device type from where the event was triggered.
 * @property {string} platform - From what platform the user is managing Security events
 */
/**
 * @typedef Exchange20
 * @property {boolean} [two_fa_mode] - Whether the exchange account has 2FA set up
 * @property {string} [user_id] - Exchange user credentials ID
 */
/**
 * @typedef Exchange21
 * @property {Record<string, any>} [two_fa_mode] - Whether the exchange account has 2FA set up
 * @property {Record<string, any>} [user_id] - Exchange user credentials ID
 */
/**
 * @typedef Nabu10
 * @property {boolean} [recovery_eligible] - Whether the nabu user is eligible for recovery. Usually if account has value (> $300 or 1 payment method linked)
 * @property {Record<string, any>} [user_id] - The Nabu User ID. This is from the users table in nabu gateway
 */
/**
 * @typedef Wallet10
 * @property {string} [auth_type] - The wallet 2FA type that is enforced.
 * @property {Exchange21} [exchange] - Parameters about the exchange account
 * @property {string} [guid_first_four] - The first four characters of the wallet.guid field
 * @property {boolean} [has_cloud_backup] - Whether the wallet has cloud backups
 * @property {boolean} [is_mobile_setup] - Whether the wallet has a mobile client set up
 * @property {number} [last_mnemonic_backup] - The last time, in unix timestamp, in which a wallet has their mnemonic backup verified
 * @property {string} [mobile_device_type] - The type of device being verified
 * @property {Nabu10} [nabu] - Parameter about the nabu account
 */
/**
 * @typedef RecoveryPhraseEntered
 * @property {string} device - Device type from where the event was triggered.
 * @property {Exchange20} [exchange] - Parameters about the exchange account
 * @property {boolean} [mergeable] - Indicates if possible to merge two unlinked accounts
 * @property {string} platform - What platform the user is is recovering the account from
 * @property {string} site_redirect - Whether the user is being redirected to the exchange or wallet
 * @property {boolean} [upgradeable] - Indicates if possible to upgrade to a new unified Blockchain.com Account
 * @property {Wallet10} [wallet] - Parameters about the wallet account
 */
/**
 * @typedef RecoveryPhraseShown
 * @property {string} device - Device type from where the event was triggered.
 * @property {string} platform - From what platform the user is managing Security events
 */
/**
 * @typedef RecurringBuyActivated
 * @property {string} frequency - What is the frequency of the recurring buy. Also called period in the backend.
 * @property {number} input_amount - The amount in input_currency being spend by the user
 * @property {number} input_amount_usd - The amount in USD being spend by the user
 * @property {string} input_currency - Currency symbol for the currency being paid in exchange for some crypto. For example USD
 * @property {string} output_currency - Currency symbol for the currency being received. For example BTC
 * @property {string} payment_method - The payment method used for the recurring buy order
 * @property {string} platform - What platform the user is looking at recurring buy from
 * @property {string} recurring_buy_id - What id the id of the recurring buy being cancelled
 */
/**
 * @typedef RecurringBuyCancelled
 * @property {boolean} cancelled_by_user - Whether the order is cancelled by the user or by our backend (for example after many failed reattempts)
 * @property {string | null} frequency - What is the frequency of the recurring buy. Also called period in the backend.
 * @property {number} input_amount - The amount in input_currency being spend by the user
 * @property {number} input_amount_usd - The amount in USD being spend by the user
 * @property {string} input_currency - Currency symbol for the currency being paid in exchange for some crypto. For example USD
 * @property {string} output_currency - Currency symbol for the currency being received. For example BTC
 * @property {string} payment_method - The payment method used for the recurring buy order
 * @property {string} platform - What platform the user is looking at recurring buy from
 * @property {string} recurring_buy_id - What id the id of the recurring buy being cancelled
 */
/**
 * @typedef RecurringBuyClicked
 * @property {string} device - Device type from where the event was triggered.

 * @property {string} origin - What button we are referring to. BUY_CONFIRMATION : at the end of the buy flow (Create Recurring Buy at the suggestion screen).
 * @property {string} platform - What platform the user is looking at recurring buy from
 */
/**
 * @typedef RecurringBuyDetailsClicked
 * @property {string} currency - Currency of the crypto being bought (output currency) for the recurring order
 * @property {string} device - Device type from where the event was triggered.

 * @property {string} origin - What button we are referring to : CURRENCY_PAGE : Currency page (Coin View) of the coin being bought. TRANSACTION_LIST : From the historical transaction list, also called Activity in mobile
 * @property {string} platform - What platform the user is looking at recurring buy from
 */
/**
 * @typedef RecurringBuyInfoViewed
 * @property {string} device - Device type from where the event was triggered.
 * @property {number | null} page - (From 0 to 4) If applicable : what page of the info is being viewed.
 * @property {string} platform - What platform the user is looking at recurring buy from
 * @property {string} [type] - type of info being viewed. e.g. DCA : Dollar Cost Averaging
 */
/**
 * @typedef RecurringBuyLearnMoreClicked
 * @property {string} device - Device type from where the event was triggered.
 * @property {string} origin - What button we are referring to. CURRENCY_PAGE : Currency page (Coin View) of the coin being bought. DASHBOARD_PROMO : announcement card or promo on dashboard.  DCA_DETAILS_LINK : the external link to learn more about the DCA method
 * @property {string} platform - What platform the user is looking at recurring buy from
 * @property {string} [type] - What does the user want to learn more about ? DCA : Dollar Cost Averaging
 */
/**
 * @typedef RecurringBuySuggestionSkipped
 * @property {string} device - Device type from where the event was triggered.
 * @property {string} origin - What recurring buy suggestion we are referring to. BUY_CONFIRMATION : at the end of the buy flow ("Maybe Later" at the suggestion screen)
 * @property {string} [platform] - What platform the user is looking at recurring buy from
 */
/**
 * @typedef RecurringBuyUnavailableShown
 * @property {string} device - Device type from where the event was triggered.
 * @property {string} platform - What platform the user wants to buy from
 * @property {string} reason - Reason for not being able to set up recurring buy. PAYMENT_METHOD_UNAVAILABLE : the current selected payment method is not available. (e.g. if cards payments cannot be used for that client for some reason) SELECT_PAYMENT : the user needs to select the payment method before selecting the frequency of the buy order, mainly shown for first time buyer.
 */
/**
 * @typedef RecurringBuyViewed
 * @property {string} device - Device type from where the event was triggered.

 * @property {string} [path] - Path portion of the URL of the page. Equivalent to canonical path which defaults to location.pathname from the DOM API.
 * @property {string} platform - What platform the page viewed belongs to
 * @property {string} [referrer] - Full URL of the previous page. Equivalent to document.referrer from the DOM API.
 * @property {string} [search] - Query string portion of the URL of the page. Equivalent to location.search from the DOM API.
 * @property {string} [title] - Title of the page. Equivalent to document.title from the DOM API.
 * @property {string} [url] - Full URL of the page. First we look for the canonical url. If the canonical url is not provided, we use location.href from the DOM API.
 */
/**
 * @typedef RememberTwoStepVerificationUpdated
 * @property {string} [device] - Device type from where the event was triggered.
 * @property {boolean} is_enabled - If Enabled, browser will be remembered, allowing user to login again without having to re-authenticate. If Disabled, authentication is needed for every login. 
 * @property {string} platform - From what platform the user is managing Security events

 */
/**
 * @typedef RemoveLinkedCardClicked
 * @property {string} device - Device type from where the event was triggered.
 * @property {string} origin - What button we are referring to. SETTINGS : user's settings page. BUY : from the Buy flow.
 * @property {string} platform - What platform the user wants to link a bank for
 */
/**
 * @typedef Exchange22
 * @property {boolean} [two_fa_mode] - Whether the exchange account has 2FA set up
 * @property {string} [user_id] - Exchange user credentials ID
 */
/**
 * @typedef Exchange23
 * @property {Record<string, any>} [two_fa_mode] - Whether the exchange account has 2FA set up
 * @property {Record<string, any>} [user_id] - Exchange user credentials ID
 */
/**
 * @typedef Nabu11
 * @property {boolean} [recovery_eligible] - Whether the nabu user is eligible for recovery. Usually if account has value (> $300 or 1 payment method linked)
 * @property {Record<string, any>} [user_id] - The Nabu User ID. This is from the users table in nabu gateway
 */
/**
 * @typedef Wallet11
 * @property {string} [auth_type] - The wallet 2FA type that is enforced.
 * @property {Exchange23} [exchange] - Parameters about the exchange account
 * @property {string} [guid_first_four] - The first four characters of the wallet.guid field
 * @property {boolean} [has_cloud_backup] - Whether the wallet has cloud backups
 * @property {boolean} [is_mobile_setup] - Whether the wallet has a mobile client set up
 * @property {number} [last_mnemonic_backup] - The last time, in unix timestamp, in which a wallet has their mnemonic backup verified
 * @property {string} [mobile_device_type] - The type of device being verified
 * @property {Nabu11} [nabu] - Parameter about the nabu account
 */
/**
 * @typedef ResetAccountCancelled
 * @property {string} device - Device type from where the event was triggered.
 * @property {Exchange22} [exchange] - Parameters about the exchange account
 * @property {boolean} [mergeable] - Indicates if possible to merge two unlinked accounts
 * @property {string} origin - What button we are referring to. RESET_CONFIRMATION : when confirming reset in reset flow. RESET_FINAL_WARNING : when confirming reset wish after the final warning
 * @property {string} platform - What platform the user is is recovering the account from
 * @property {string} site_redirect - Whether the user is being redirected to the exchange or wallet
 * @property {boolean} [upgradeable] - Indicates if possible to upgrade to a new unified Blockchain.com Account
 * @property {Wallet11} [wallet] - Parameters about the wallet account
 */
/**
 * @typedef Exchange24
 * @property {boolean} [two_fa_mode] - Whether the exchange account has 2FA set up
 * @property {string} [user_id] - Exchange user credentials ID
 */
/**
 * @typedef Exchange25
 * @property {Record<string, any>} [two_fa_mode] - Whether the exchange account has 2FA set up
 * @property {Record<string, any>} [user_id] - Exchange user credentials ID
 */
/**
 * @typedef Nabu12
 * @property {boolean} [recovery_eligible] - Whether the nabu user is eligible for recovery. Usually if account has value (> $300 or 1 payment method linked)
 * @property {Record<string, any>} [user_id] - The Nabu User ID. This is from the users table in nabu gateway
 */
/**
 * @typedef Wallet12
 * @property {string} [auth_type] - The wallet 2FA type that is enforced.
 * @property {Exchange25} [exchange] - Parameters about the exchange account
 * @property {string} [guid_first_four] - The first four characters of the wallet.guid field
 * @property {boolean} [has_cloud_backup] - Whether the wallet has cloud backups
 * @property {boolean} [is_mobile_setup] - Whether the wallet has a mobile client set up
 * @property {number} [last_mnemonic_backup] - The last time, in unix timestamp, in which a wallet has their mnemonic backup verified
 * @property {string} [mobile_device_type] - The type of device being verified
 * @property {Nabu12} [nabu] - Parameter about the nabu account
 */
/**
 * @typedef ResetAccountClicked
 * @property {string} device - Device type from where the event was triggered.
 * @property {Exchange24} [exchange] - Parameters about the exchange account
 * @property {boolean} [mergeable] - Indicates if possible to merge two unlinked accounts
 * @property {string} origin - What button we are referring to. RECOVERY_OPTIONS : when failing to choose between recovery options. RECOVERY_PHRASE : when failing to enter recovery phrase. RESET_CONFIRMATION : when confirming reset in reset flow. RESET_FINAL_WARNING : when confirming reset wish after the final warning
 * @property {string} platform - What platform the user is is recovering the account from
 * @property {string} site_redirect - Whether the user is being redirected to the exchange or wallet
 * @property {boolean} [upgradeable] - Indicates if possible to upgrade to a new unified Blockchain.com Account
 * @property {Wallet12} [wallet] - Parameters about the wallet account
 */
/**
 * @typedef RevenueGenerated
 * @property {string} product_id - What product the user is buying, it's usually the trading pair of the order (e.g. BTC-EUR)
 * @property {number} profit - The approximated profit in usd that we make from the order. Usually a fixed approximate margin for Buy, Sell & Swap product, and the fee for trades
 * @property {number} revenue - The revenue amount in usd. This is the volume of crypto of fiat traded or bought from a buy, swap, sell or trade order
 * @property {string} revenue_type - What type of revenue this is
 */
/**
 * @typedef SearchCoinOpened
 * @property {string} device - Device type from where the event was triggered.
 * @property {string} platform - What platform the search is initiated from.
 * @property {string} search_type - What elements the user is looking for. TRADING_PAIR : trading pairs containing the coin. CRYPTO_PRICES : from the explorer price page
 */
/**
 * @typedef SecurityTabClicked
 * @property {string} device - Device type from where the event was triggered.
 * @property {string} platform - From what platform the user clicking the Security options
 */
/**
 * @typedef SellAmountEntered
 * @property {string} device - Device type from where the event was triggered.
 * @property {string} from_account_type - What type of account the user wants to sell funds from.
 * @property {number} input_amount - The expected amount for the input currency, usually as a float. For BTC, it should be for example 1.23, meaning 1.23 BTC
 * @property {string} input_currency - Currency symbol for the crypto currency being sent by the user in exchange for some fiat. For example BTC
 * @property {string} output_currency - Currency symbol for the currency being received by the user. For example USD
 * @property {string} platform - What platform the user is to selling from
 */
/**
 * @typedef SellAmountMaxClicked
 * @property {string} device - Device type from where the event was triggered.
 * @property {string} from_account_type - What type of account the user wants to sell funds from.
 * @property {string} input_currency - Currency symbol for the crypto currency being sent by the user in exchange for some fiat. For example BTC
 * @property {string} output_currency - Currency symbol for the currency being received by the user. For example USD
 * @property {string} platform - What platform the user is to selling from
 */
/**
 * @typedef SellAmountMinClicked
 * @property {string} device - Device type from where the event was triggered.
 * @property {string} from_account_type - What type of account the user wants to sell funds from.
 * @property {string} input_currency - Currency symbol for the crypto currency being sent by the user in exchange for some fiat. For example BTC
 * @property {string} output_currency - Currency symbol for the currency being received by the user. For example USD
 * @property {string} platform - What platform the user is to selling from
 */
/**
 * @typedef SellCancelled
 * @property {string} [device] - Device the sell order was made from
 * @property {string} from_account_type - What type of account the user wants to sell funds from. For simple_transactions with paymentType "Funds", it is TRADING. For custodial transactions, it is TRADING for INTERNAL type, or USERKEY for FROM_USERKEY type. 
SAVINGS : interest saving account. 
 * @property {number} [input_amount] - The expected amount for the input currency, usually as a float. For BTC, it should be for example 1.23, meaning 1.23 BTC. Exact amount is only in Buy Completed
 * @property {number} [input_amount_usd] - The amount of crypto sold by the user in USD, usually as a float. it should be for example 10.23, meaning $10.23 worth of crypto was sold
 * @property {string} input_currency - Currency symbol for the crypto currency being sent by the user in exchange for some fiat. For example BTC

 * @property {number} [output_amount] - The expected amount for the output currency, usually as a float. For USD, it should be for example 1.23, meaning 1.23 USD. Exact amount is only in Sell Completed
 * @property {string} output_currency - Currency symbol for the currency being received by the user. For example USD

 * @property {string} paltform - What platform the event was started from. (WALLET if product=SIMPLEBUY and EXCHANGE if product=MERCURY
 * @property {string} [payment_id] - id of the payment (id of the transaction from nabu payments)
 * @property {string} product - The Product for which the sell order is (the product columns of the simple_transactions table, or SIMPLEBUY for custodial transactions since they aren't used in the Exchange Simple Trade product)
 * @property {string} [transaction_id] - The id of the transaction for the sell order (the id of either the  simple_transactions or the custodial_transactions table in nabu gateway)
 */
/**
 * @typedef SellCompleted
 * @property {string} [device] - Device the sell order was made from
 * @property {string} from_account_type - What type of account the user wants to sell funds from. For simple_transactions with paymentType "Funds", it is TRADING. For custodial transactions, it is TRADING for INTERNAL type, or USERKEY for FROM_USERKEY type. 
SAVINGS : interest saving account. 
 * @property {number} [input_amount] - The expected amount for the input currency, usually as a float. For BTC, it should be for example 1.23, meaning 1.23 BTC. Exact amount is only in Buy Completed
 * @property {number} input_amount_usd - The amount of crypto sold by the user in USD, usually as a float. it should be for example 10.23, meaning $10.23 worth of crypto was sold
 * @property {string} input_currency - Currency symbol for the crypto currency being sent by the user in exchange for some fiat. For example BTC

 * @property {number} [output_amount] - The expected amount for the output currency, usually as a float. For USD, it should be for example 1.23, meaning 1.23 USD. Exact amount is only in Sell Completed
 * @property {string} output_currency - Currency symbol for the currency being received by the user. For example USD

 * @property {string} platform - What platform the event was started from. (WALLET if product=SIMPLEBUY and EXCHANGE if product=MERCURY

 * @property {string} product - The Product for which the sell order is (the product columns of the simple_transactions table, or SIMPLEBUY for custodial transactions since they aren't used in the Exchange Simple Trade product)
 * @property {number} spread_percentage - Spread percentage applied to the exchange rate
 * @property {string} [transaction_id] - The id of the transaction for the sell order (the id of either the  simple_transactions or the custodial_transactions table in nabu gateway)
 */
/**
 * @typedef SellCreated
 * @property {string} [device] - Device the sell order was made from
 * @property {string} from_account_type - What type of account the user wants to sell funds from. For simple_transactions with paymentType "Funds", it is TRADING. For custodial transactions, it is TRADING for INTERNAL type, or USERKEY for FROM_USERKEY type. 
SAVINGS : interest saving account. 
 * @property {number} [input_amount] - The expected amount for the input currency, usually as a float. For BTC, it should be for example 1.23, meaning 1.23 BTC. Exact amount is only in Buy Completed
 * @property {number} [input_amount_usd] - The amount of crypto sold by the user in USD, usually as a float. it should be for example 10.23, meaning $10.23 worth of crypto was sold
 * @property {string} input_currency - Currency symbol for the crypto currency being sent by the user in exchange for some fiat. For example BTC

 * @property {number} [output_amount] - The expected amount for the output currency, usually as a float. For USD, it should be for example 1.23, meaning 1.23 USD. Exact amount is only in Sell Completed
 * @property {string} output_currency - Currency symbol for the currency being received by the user. For example USD

 * @property {string} [payment_id] - id of the payment (id of the transaction from nabu payments)
 * @property {string} platform - What platform the event was started from. (WALLET if product=SIMPLEBUY and EXCHANGE if product=MERCURY

 * @property {string} product - The Product for which the sell order is (the product columns of the simple_transactions table, or SIMPLEBUY for custodial transactions since they aren't used in the Exchange Simple Trade product)
 * @property {string} [transaction_id] - The id of the transaction for the sell order (the id of either the  simple_transactions or the custodial_transactions table in nabu gateway)
 */
/**
 * @typedef SellExpired
 * @property {string} [device] - Device the sell order was made from
 * @property {string} from_account_type - What type of account the user wants to sell funds from. For simple_transactions with paymentType "Funds", it is TRADING. For custodial transactions, it is TRADING for INTERNAL type, or USERKEY for FROM_USERKEY type. 
SAVINGS : interest saving account. 
 * @property {number} [input_amount] - The expected amount for the input currency, usually as a float. For BTC, it should be for example 1.23, meaning 1.23 BTC. Exact amount is only in Buy Completed
 * @property {number} [input_amount_usd] - The amount of crypto sold by the user in USD, usually as a float. it should be for example 10.23, meaning $10.23 worth of crypto was sold
 * @property {string} input_currency - Currency symbol for the crypto currency being sent by the user in exchange for some fiat. For example BTC

 * @property {number} [output_amount] - The expected amount for the output currency, usually as a float. For USD, it should be for example 1.23, meaning 1.23 USD. Exact amount is only in Sell Completed
 * @property {string} output_currency - Currency symbol for the currency being received by the user. For example USD

 * @property {string} [payment_id] - id of the payment (id of the transaction from nabu payments)
 * @property {string} platform - What platform the event was started from. (WALLET if product=SIMPLEBUY and EXCHANGE if product=MERCURY

 * @property {string} product - The Product for which the sell order is (the product columns of the simple_transactions table, or SIMPLEBUY for custodial transactions since they aren't used in the Exchange Simple Trade product)
 * @property {string} [transaction_id] - The id of the transaction for the sell order (the id of either the  simple_transactions or the custodial_transactions table in nabu gateway)
 */
/**
 * @typedef SellFailed
 * @property {string} [device] - Device the sell order was made from
 * @property {string} from_account_type - What type of account the user wants to sell funds from. For simple_transactions with paymentType "Funds", it is TRADING. For custodial transactions, it is TRADING for INTERNAL type, or USERKEY for FROM_USERKEY type. 
SAVINGS : interest saving account. 
 * @property {number} [input_amount] - The expected amount for the input currency, usually as a float. For BTC, it should be for example 1.23, meaning 1.23 BTC. Exact amount is only in Buy Completed
 * @property {number} [input_amount_usd] - The amount of crypto sold by the user in USD, usually as a float. it should be for example 10.23, meaning $10.23 worth of crypto was sold
 * @property {string} input_currency - Currency symbol for the crypto currency being sent by the user in exchange for some fiat. For example BTC

 * @property {number} [output_amount] - The expected amount for the output currency, usually as a float. For USD, it should be for example 1.23, meaning 1.23 USD. Exact amount is only in Sell Completed
 * @property {string} output_currency - Currency symbol for the currency being received by the user. For example USD

 * @property {string} [payment_id] - id of the payment (id of the transaction from nabu payments)
 * @property {string} platform - What platform the event was started from. (WALLET if product=SIMPLEBUY and EXCHANGE if product=MERCURY

 * @property {string} product - The Product for which the sell order is (the product columns of the simple_transactions table, or SIMPLEBUY for custodial transactions since they aren't used in the Exchange Simple Trade product)
 * @property {string} [transaction_id] - The id of the transaction for the sell order (the id of either the  simple_transactions or the custodial_transactions table in nabu gateway)
 */
/**
 * @typedef SellFromSelected
 * @property {string} device - Device type from where the event was triggered.
 * @property {string} from_account_type - What type of account the user wants to sell funds from.
 * @property {string} input_currency - Currency symbol for the crypto currency being sent by the user in exchange for some fiat. For example BTC
 * @property {string} platform - What platform the user is to selling from
 */
/**
 * @typedef SellRejected
 * @property {string} [device] - Device the sell order was made from
 * @property {string} [error_reason] - Error message related to the rejection. This is more detailed than the rejection_reason 
 * @property {string} from_account_type - What type of account the user wants to sell funds from. For simple_transactions with paymentType "Funds", it is TRADING. For custodial transactions, it is TRADING for INTERNAL type, or USERKEY for FROM_USERKEY type. 
SAVINGS : interest saving account. 
 * @property {number} [input_amount] - The expected amount for the input currency, usually as a float. For BTC, it should be for example 1.23, meaning 1.23 BTC. Exact amount is only in Buy Completed
 * @property {number} [input_amount_usd] - The amount of crypto sold by the user in USD, usually as a float. it should be for example 10.23, meaning $10.23 worth of crypto was sold
 * @property {string} input_currency - Currency symbol for the crypto currency being sent by the user in exchange for some fiat. For example BTC

 * @property {number} [output_amount] - The expected amount for the output currency, usually as a float. For USD, it should be for example 1.23, meaning 1.23 USD. Exact amount is only in Sell Completed
 * @property {string} output_currency - Currency symbol for the currency being received by the user. For example USD

 * @property {string} [payment_id] - id of the payment (id of the transaction from nabu payments)
 * @property {string} platform - What platform the event was started from. (WALLET if product=SIMPLEBUY and EXCHANGE if product=MERCURY

 * @property {string} product - The Product for which the sell order is (the product columns of the simple_transactions table, or SIMPLEBUY for custodial transactions since they aren't used in the Exchange Simple Trade product)
 * @property {string} [rejection_reason] - Raison of the rejection
 * @property {string} [transaction_id] - The id of the transaction for the sell order (the id of either the  simple_transactions or the custodial_transactions table in nabu gateway)
 */
/**
 * @typedef SendAmountEntered
 * @property {string} currency - The currency the user wants to send (e.g. BTC)
 * @property {string} device - Device type from where the event was triggered.

 * @property {string} fee_rate - What fee rate is used for sending the crypto. The user may or may not have selected it explicitly, for transfers from custodial wallets for example. BACKEND : the backend will chose what fee_rate to apply. CUSTOM : custom priority defined by the user. NORMAL : normal priority for transactions according to our fee estimation.  PRIORITY : high priority for transactions according to our fee estimation.
 * @property {string} from_account_type - To what type of account the user wants to send funds from. 
SAVINGS : interest saving account. 
TRADING : wallet custodial wallet. 
USERKEY : Non Custodial, Private Key, wallet
 * @property {string} platform - From what platform the user is sending crypto from
 * @property {string} to_account_type - To what type of account the user wants to send funds to. EXCHANGE : Blockchain Exchange wallet 
EXTERNAL : external address outside Blockchain.com. 
SAVINGS : interest saving account. 
TRADING : wallet custodial wallet. 
USERKEY : Non Custodial, Private Key, wallet
 */
/**
 * @typedef SendAmountMaxClicked
 * @property {string} currency - The currency the user wants to send (e.g. BTC)
 * @property {string} device - Device type from where the event was triggered.
 * @property {string} from_account_type - To what type of account the user wants to send funds from. 
SAVINGS : interest saving account. 
TRADING : wallet custodial wallet. 
USERKEY : Non Custodial, Private Key, wallet
 * @property {string} platform - From what platform the user is sending crypto from
 * @property {string} to_account_type - To what type of account the user wants to send funds to. EXCHANGE : Blockchain Exchange wallet 
EXTERNAL : external address outside Blockchain.com. 
SAVINGS : interest saving account. 
TRADING : wallet custodial wallet. 
USERKEY : Non Custodial, Private Key, wallet
 */
/**
 * @typedef SendFeeRateSelected
 * @property {string} currency - The currency the user wants to send (e.g. BTC)
 * @property {string} device - Device type from where the event was triggered.
 * @property {string} fee_rate - What fee rate the user has selected
 * @property {string} from_account_type - To what type of account the user wants to send funds from. 
SAVINGS : interest saving account. 
TRADING : wallet custodial wallet. 
USERKEY : Non Custodial, Private Key, wallet
 * @property {string} platform - From what platform the user is sending crypto from
 * @property {string} to_account_type - To what type of account the user wants to send funds to. EXCHANGE : Blockchain Exchange wallet 
EXTERNAL : external address outside Blockchain.com. 
SAVINGS : interest saving account. 
TRADING : wallet custodial wallet. 
USERKEY : Non Custodial, Private Key, wallet
 */
/**
 * @typedef SendFromSelected
 * @property {string} currency - The currency the user wants to send (e.g. BTC)
 * @property {string} device - Device type from where the event was triggered.
 * @property {string} from_account_type - To what type of account the user wants to send funds from. 
SAVINGS is the interest saving account. 
TRADING is the wallet custodial wallet. 
USERKEY is the Non Custodial, Private Key, wallet
 * @property {string} platform - From what platform the user is sending crypto from
 */
/**
 * @typedef SendReceiveClicked
 * @property {string} [currency] - What currency is being viewed. Used only for legacy flow, as the new flow will ask for the currency at a later stage.
 * @property {string} device - Device type from where the event was triggered.
 * @property {string} origin - What button we are referring to. DASHBOARD_PROMO : announcement card or promo on dashboard. 
NAVIGATION: Navigation Bar.

 * @property {string} platform - What platform the user is clicking from
 * @property {string} [type] - Whether the user clicked on a send or receive button specifically. For Android the Send or Receive screen is the same button, so this type will be empty.
 */
/**
 * @typedef SendReceiveViewed
 * @property {string} [currency] - What currency is being viewed. Used only for legacy flow, as the new flow will ask for the currency at a later stage.
 * @property {string} device - Device type from where the event was triggered.
 * @property {string} [path] - Path portion of the URL of the page. Equivalent to canonical path which defaults to location.pathname from the DOM API.
 * @property {string} platform - What platform the page viewed belongs to
 * @property {string} [referrer] - Full URL of the previous page. Equivalent to document.referrer from the DOM API.
 * @property {string} [search] - Query string portion of the URL of the page. Equivalent to location.search from the DOM API.
 * @property {string} [title] - Title of the page. Equivalent to document.title from the DOM API.
 * @property {string} [type] - Whether the user views a send or receive screen specifically. For Android the Send or Receive screen is the same, so this type will be empty.
 * @property {string} [url] - Full URL of the page. First we look for the canonical url. If the canonical url is not provided, we use location.href from the DOM API.
 */
/**
 * @typedef SendSubmitted
 * @property {string} currency - The currency the user wants to send (e.g. BTC)
 * @property {string} device - Device type from where the event was triggered.
 * @property {string} fee_rate - What fee rate is used for sending the crypto. The user may or may not have selected it explicitly, for transfers from custodial wallets for example. BACKEND : the backend will chose what fee_rate to apply. CUSTOM : custom priority defined by the user. NORMAL : normal priority for transactions according to our fee estimation.  PRIORITY : high priority for transactions according to our fee estimation.
 * @property {string} from_account_type - To what type of account the user wants to send funds from. 
SAVINGS : interest saving account. 
TRADING : wallet custodial wallet. 
USERKEY : Non Custodial, Private Key, wallet
 * @property {string} platform - From what platform the user is sending crypto from
 * @property {string} to_account_type - To what type of account the user wants to send funds to. EXCHANGE : Blockchain Exchange wallet 
EXTERNAL : external address outside Blockchain.com. 
SAVINGS : interest saving account. 
TRADING : wallet custodial wallet. 
USERKEY : Non Custodial, Private Key, wallet
 */
/**
 * @typedef SettingsCurrencyClicked
 * @property {string} currency -
 * @property {string} device - Device type from where the event was triggered.
 * @property {string} platform - From what platform the user is using the Settings
 */
/**
 * @typedef SettingsHyperlinkClicked
 * @property {Record<string, any>} [] -
 * @property {string} destination - Destination link. Example: Terms of Service
 * @property {string} device - Device type from where the event was triggered.
 * @property {string} platform - From what platform the user is using the Settings
 */
/**
 * @typedef SettingsTabClicked
 * @property {Record<string, any>} [] -
 * @property {string} device - Device type from where the event was triggered.
 * @property {string} platform - From what platform the user is using the Settings
 * @property {string} settings_tab - General, Trading Limits, Preferences or Wallets & Addresses
 */
/**
 * @typedef SignInSkipped
 * @property {string} device - Device type from where the event was triggered.
 * @property {string} plaform - In the Exchange, the sign in can be skipped to continue as guest
 */
/**
 * @typedef SignUpAddressUnsupported
 * @property {string} country - Country, as iso code alpha 2, provided by the user at sign up
 * @property {string} country_state - country state, as ISO 3166-2 (US-NY for example), provided by the user at sign up
 * @property {string} device - What device the user is signing up from
 * @property {Record<string, any>} email -
 * @property {string} platform - What platform the user is signing up to
 */
/**
 * @typedef SignUpClicked
 * @property {string} device - What device the user is signing up from
 * @property {string} origin - What button we are referring to. NUX_LAUNCH_PROMO_BUY_CRYPTO : (mobile) Buy Crypto button at the bottom of a card announcement  when launching the app and before login in.
 * @property {string} platform - What platform the user is signing up to
 */
/**
 * @typedef SignUpCountrySelected
 * @property {string} country - Country, as iso code alpha 2, provided by the user at sign up
 * @property {string} [country_state] - country state, as ISO 3166-2 (US-NY for example), provided by the user at sign up
 * @property {string} device - What device the user is signing up from
 * @property {string} platform - What platform the user is signing up to
 */
/**
 * @typedef SignedIn
 * @property {string} [authentification_type] - How the user is trying to log in. PASSWORD : with a password on mobile or web, PIN : with a PIN on mobile,  SECURE_CHANNEL : by sending a log in request via secure channel to another client
 * @property {string} device - Device type from where the event was triggered.
 * @property {string} platform - What platform the user logs in to.
 * @property {string} [site_redirect] - Whether the user is being redirected to the WALLET or the EXCHANGE
 */
/**
 * @typedef SignedOut
 * @property {string} device - Device type from where the event was triggered.
 * @property {string} platform - What platform the user logs out from.
 */
/**
 * @typedef SignedUp
 * @property {string} device - What device the user created the account from
 * @property {boolean} [is_from_linking] - Whether the profile is created from linking the account from another product. For now, we record it specifically when an exchange account is created by linking a wallet account.
 * @property {string} legal_entity - every user need to be assigned to a legal entity based on a certain reason.
 * @property {string} legal_entity_reason - legal entity to a user assigned based on this reason.
 * @property {string} platform - What platform the user signed up for
 */
/**
 * @typedef SimpleTradeClicked
 * @property {string} device - Device type from where the event was triggered.
 * @property {string} origin - what button we are referring to. NAVIGATION : navigation bar. 

 * @property {string} platform - What platform the user is clicking from
 */
/**
 * @typedef SimpleTradeViewed
 * @property {string} device - Device type from where the event was triggered.
 * @property {string} [path] - Path portion of the URL of the page. Equivalent to canonical path which defaults to location.pathname from the DOM API.
 * @property {string} platform - What platform the page viewed belongs to
 * @property {string} [referrer] - Full URL of the previous page. Equivalent to document.referrer from the DOM API.
 * @property {string} [search] - Query string portion of the URL of the page. Equivalent to location.search from the DOM API.
 * @property {string} [title] - Title of the page. Equivalent to document.title from the DOM API.
 * @property {string} [url] - Full URL of the page. First we look for the canonical url. If the canonical url is not provided, we use location.href from the DOM API.
 */
/**
 * @typedef SmsMessageSent
 * @property {string} country_code - country of the mobile number, in alpha iso 2 code.
 * @property {string} [device] - Device type from where the event was triggered.
 * @property {string} origin - From which page are they verifying the Mobile Number? Settings or Security
 * @property {string} platform - From what platform the user is using the Settings
 */
/**
 * @typedef SwapAccountsSelected
 * @property {string} device - Device type from where the event was triggered.
 * @property {string} input_currency - Currency symbol for the currency being swap from in exchange for some other currency. For example BTC in a BTC-ETH swap
 * @property {string} input_type - The type of account the swap funds are coming from
 * @property {string} output_currency - Currency symbol for the currency being swap to. For example ETH in a BTC-ETH swap
 * @property {string} output_type - The type of account the swap funds are going to
 * @property {string} platform - From what platform the user wants to Swap from
 * @property {boolean} [was_suggested] - Whether the swap accounts and currency were suggested by the UX and the user clicked on it. Empty if this information is unknown.
 */
/**
 * @typedef SwapAmountEntered
 * @property {number} [amount] - The amount in the native fiat currency that the user selects the amount
 * @property {string} [amount_currency] - The native fiat currency
 * @property {string} device - Device type from where the event was triggered.
 * @property {number} input_amount - The amount for the input currency
 * @property {string} input_currency - Currency symbol for the currency being swap from in exchange for some other currency. For example BTC in a BTC-ETH swap
 * @property {string} input_type - The type of account the swap funds are coming from
 * @property {number} [output_amount] - The amount for the output currency
 * @property {string} output_currency - Currency symbol for the currency being swap to. For example ETH in a BTC-ETH swap
 * @property {string} output_type - The type of account the swap funds are going to
 * @property {string} platform - From what platform the user wants to Swap from
 */
/**
 * @typedef SwapAmountMaxClicked
 * @property {string} [amount_currency] - If the button explicitly displays the amount in a specific currency. what is the currency being clicked on for the max amount ?
 * @property {string} device - Device type from where the event was triggered.
 * @property {string} input_currency - Currency symbol for the currency being swap from in exchange for some other currency. For example BTC in a BTC-ETH swap
 * @property {string} input_type - The type of account the swap funds are coming from
 * @property {string} output_currency - Currency symbol for the currency being swap to. For example ETH in a BTC-ETH swap
 * @property {string} output_type - The type of account the swap funds are going to
 * @property {string} platform - From what platform the user wants to Swap from
 */
/**
 * @typedef SwapAmountMinClicked
 * @property {string} [amount_currency] - If the button explicitly displays the amount in a specific currency. what is the currency being clicked on for the min amount ?
 * @property {string} device - Device type from where the event was triggered.
 * @property {string} input_currency - Currency symbol for the currency being swap from in exchange for some other currency. For example BTC in a BTC-ETH swap
 * @property {string} input_type - The type of account the swap funds are coming from
 * @property {string} output_currency - Currency symbol for the currency being swap to. For example ETH in a BTC-ETH swap
 * @property {string} output_type - The type of account the swap funds are going to
 * @property {string} platform - From what platform the user wants to Swap from
 */
/**
 * @typedef SwapCancelled
 * @property {string} device - Device type from where the event was triggered.
 * @property {string} direction - What type of swap transactions it is, as a direction from/to Custodial or Non Custodial Wallet. INTERNAL is from TRADING to TRADING wallets. ON_CHAIN is from USERKEY to USERKEY. FROM_USERKEY is from USERKEY to TRADING wallets. TO_USERKEY is from TRADING to USERKEY wallets
 * @property {string} from_account_type - The type of account the swap funds are coming from. (USERKEY for ON_CHAIN and FROM_USERKEY directions, TRADING for INTERNAL and TO_USERKEY)
 * @property {number} input_amount - The amount for the input currency
 * @property {number} [input_amount_usd] - Approximate amount in USD sent by the user.
 * @property {string} input_currency - Symbol for the crypto currency being swap from in exchange for some other crypto currency. For example BTC in a BTC-ETH swap
 * @property {number} output_amount - The amount for the output currency
 * @property {string} output_currency - Symbol for the crypto currency being swap to. For example ETH in a BTC-ETH swap
 * @property {string} [payment_id] - id of the payment (id of the transaction from nabu payments)
 * @property {string} platform - What platform the event was started from. (WALLET)

 * @property {string} to_account_type - The type of account the swap funds are coming from. (USERKEY for ON_CHAIN and TO_USERKEY directions, TRADING for INTERNAL and FROM_USERKEY directions)
 * @property {string} transaction_id - id of the transaction from nabu gateway custodial_transaction table
 */
/**
 * @typedef SwapClicked
 * @property {string} device - Device type from where the event was triggered.
 * @property {string} origin - What button we are referring to. 
CURRENCY_PAGE : CTA or menu on the coin page next to balance. 
DASHBOARD_PROMO : announcement card or promo on dashboard. 
DEEP_LINK : any deep linking
NAVIGATION : navigation bar. 
PRICES_PAGE : prices page in wallet. 
SEND: comes from Send product. 
SETTINGS : Settings page

 * @property {string} platform - What platform the user is clicking from
 */
/**
 * @typedef SwapCompleted
 * @property {string} device - Device type from where the event was triggered.
 * @property {string} direction - What type of swap transactions it is, as a direction from/to Custodial or Non Custodial Wallet. INTERNAL is from TRADING to TRADING wallets. ON_CHAIN is from USERKEY to USERKEY. FROM_USERKEY is from USERKEY to TRADING wallets. TO_USERKEY is from TRADING to USERKEY wallets
 * @property {string} from_account_type - The type of account the swap funds are coming from. (USERKEY for ON_CHAIN and FROM_USERKEY directions, TRADING for INTERNAL and TO_USERKEY)
 * @property {number} input_amount - The amount for the input currency
 * @property {number} input_amount_usd - Approximate amount in USD sent by the user.
 * @property {string} input_currency - Symbol for the crypto currency being swap from in exchange for some other crypto currency. For example BTC in a BTC-ETH swap
 * @property {number} output_amount - The amount for the output currency
 * @property {string} output_currency - Symbol for the crypto currency being swap to. For example ETH in a BTC-ETH swap
 * @property {string} [payment_id] - id of the payment (id of the transaction from nabu payments)
 * @property {string} platform - What platform the event was started from. (WALLET)

 * @property {number} spread_percentage - Spread percentage applied to the exchange rate
 * @property {string} to_account_type - The type of account the swap funds are coming from. (USERKEY for ON_CHAIN and TO_USERKEY directions, TRADING for INTERNAL and FROM_USERKEY directions)
 * @property {string} transaction_id - id of the transaction from nabu gateway custodial_transaction table
 */
/**
 * @typedef SwapCreated
 * @property {string} device - Device type from where the event was triggered.
 * @property {string} direction - What type of swap transactions it is, as a direction from/to Custodial or Non Custodial Wallet. INTERNAL is from TRADING to TRADING wallets. ON_CHAIN is from USERKEY to USERKEY. FROM_USERKEY is from USERKEY to TRADING wallets. TO_USERKEY is from TRADING to USERKEY wallets
 * @property {string} from_account_type - The type of account the swap funds are coming from. (USERKEY for ON_CHAIN and FROM_USERKEY directions, TRADING for INTERNAL and TO_USERKEY)
 * @property {number} input_amount - The amount for the input currency
 * @property {number} [input_amount_usd] - Approximate amount in USD sent by the user.
 * @property {string} input_currency - Symbol for the crypto currency being swap from in exchange for some other crypto currency. For example BTC in a BTC-ETH swap
 * @property {number} output_amount - The amount for the output currency
 * @property {string} output_currency - Symbol for the crypto currency being swap to. For example ETH in a BTC-ETH swap
 * @property {string} [payment_id] - id of the payment (id of the transaction from nabu payments)
 * @property {string} platform - What platform the event was started from. (WALLET)

 * @property {string} to_account_type - The type of account the swap funds are coming from. (USERKEY for ON_CHAIN and TO_USERKEY directions, TRADING for INTERNAL and FROM_USERKEY directions)
 * @property {string} transaction_id - id of the transaction from nabu gateway custodial_transaction table
 */
/**
 * @typedef SwapExpired
 * @property {string} device - Device type from where the event was triggered.
 * @property {string} direction - What type of swap transactions it is, as a direction from/to Custodial or Non Custodial Wallet. INTERNAL is from TRADING to TRADING wallets. ON_CHAIN is from USERKEY to USERKEY. FROM_USERKEY is from USERKEY to TRADING wallets. TO_USERKEY is from TRADING to USERKEY wallets
 * @property {string} from_account_type - The type of account the swap funds are coming from. (USERKEY for ON_CHAIN and FROM_USERKEY directions, TRADING for INTERNAL and TO_USERKEY)
 * @property {number} input_amount - The amount for the input currency
 * @property {number} [input_amount_usd] - Approximate amount in USD sent by the user.
 * @property {string} input_currency - Symbol for the crypto currency being swap from in exchange for some other crypto currency. For example BTC in a BTC-ETH swap
 * @property {number} output_amount - The amount for the output currency
 * @property {string} output_currency - Symbol for the crypto currency being swap to. For example ETH in a BTC-ETH swap
 * @property {string} [payment_id] - id of the payment (id of the transaction from nabu payments)
 * @property {string} platform - What platform the event was started from. (WALLET)
 * @property {string} to_account_type - The type of account the swap funds are coming from. (USERKEY for ON_CHAIN and TO_USERKEY directions, TRADING for INTERNAL and FROM_USERKEY directions)
 * @property {string} transaction_id - id of the transaction from nabu gateway custodial_transaction table
 */
/**
 * @typedef SwapFailed
 * @property {string} device - Device type from where the event was triggered.
 * @property {string} direction - What type of swap transactions it is, as a direction from/to Custodial or Non Custodial Wallet. INTERNAL is from TRADING to TRADING wallets. ON_CHAIN is from USERKEY to USERKEY. FROM_USERKEY is from USERKEY to TRADING wallets. TO_USERKEY is from TRADING to USERKEY wallets
 * @property {string} from_account_type - The type of account the swap funds are coming from. (USERKEY for ON_CHAIN and FROM_USERKEY directions, TRADING for INTERNAL and TO_USERKEY)
 * @property {number} input_amount - The amount for the input currency
 * @property {number} [input_amount_usd] - Approximate amount in USD sent by the user.
 * @property {string} input_currency - Symbol for the crypto currency being swap from in exchange for some other crypto currency. For example BTC in a BTC-ETH swap
 * @property {number} output_amount - The amount for the output currency
 * @property {string} output_currency - Symbol for the crypto currency being swap to. For example ETH in a BTC-ETH swap
 * @property {string} [payment_id] - id of the payment (id of the transaction from nabu payments)
 * @property {string} platform - What platform the event was started from. (WALLET)
 * @property {string} to_account_type - The type of account the swap funds are coming from. (USERKEY for ON_CHAIN and TO_USERKEY directions, TRADING for INTERNAL and FROM_USERKEY directions)
 * @property {string} transaction_id - id of the transaction from nabu gateway custodial_transaction table
 */
/**
 * @typedef SwapFromSelected
 * @property {string} device - Device type from where the event was triggered.
 * @property {string} input_currency - Currency symbol for the currency being swap from in exchange for some other currency. For example BTC in a BTC-ETH swap
 * @property {string} input_type - The type of account the swap funds are coming from
 * @property {string} platform - From what platform the user wants to Swap from
 */
/**
 * @typedef SwapReceiveSelected
 * @property {string} device - Device type from where the event was triggered.
 * @property {string} output_currency - Currency symbol for the currency being swap to. For example ETH in a BTC-ETH swap
 * @property {string} output_type - The type of account the swap funds are going to
 * @property {string} platform - From what platform the user wants to Swap from
 */
/**
 * @typedef SwapRejected
 * @property {string} device - Device type from where the event was triggered.
 * @property {string} direction - What type of swap transactions it is, as a direction from/to Custodial or Non Custodial Wallet. INTERNAL is from TRADING to TRADING wallets. ON_CHAIN is from USERKEY to USERKEY. FROM_USERKEY is from USERKEY to TRADING wallets. TO_USERKEY is from TRADING to USERKEY wallets
 * @property {string} [error_message] - error message for the rejection
 * @property {string} from_account_type - The type of account the swap funds are coming from. (USERKEY for ON_CHAIN and FROM_USERKEY directions, TRADING for INTERNAL and TO_USERKEY)
 * @property {number} input_amount - The amount for the input currency
 * @property {number} [input_amount_usd] - Approximate amount in USD sent by the user.
 * @property {string} input_currency - Symbol for the crypto currency being swap from in exchange for some other crypto currency. For example BTC in a BTC-ETH swap
 * @property {number} output_amount - The amount for the output currency
 * @property {string} output_currency - Symbol for the crypto currency being swap to. For example ETH in a BTC-ETH swap
 * @property {string} [payment_id] - id of the payment (id of the transaction from nabu payments)
 * @property {string} platform - What platform the event was started from. (WALLET)
 * @property {string} property - What platform the event was started from. (WALLET)
 * @property {string} rejection_reason - The main reason why creating the swap order was rejected.
 * @property {string} to_account_type - The type of account the swap funds are coming from. (USERKEY for ON_CHAIN and TO_USERKEY directions, TRADING for INTERNAL and FROM_USERKEY directions)
 */
/**
 * @typedef SwapRequested
 * @property {string} device - Device type from where the event was triggered.
 * @property {number} [exchange_rate] - The exchange rate of the swap, how much 1 input_currency is worth in output_currency.. For example, for a BTC-ETH swap, we would have 1 BTC = 31.48 ETH, we would store 31.48
 * @property {number} input_amount - The amount for the input currency
 * @property {string} input_currency - Symbol for the crypto currency being swap from in exchange for some other crypto currency. For example BTC in a BTC-ETH swap
 * @property {string} input_type - The type of account the swap funds are coming from. (USERKEY for ON_CHAIN and FROM_USERKEY directions, TRADING for INTERNAL and TO_USERKEY)
 * @property {number} network_fee_input_amount - Network fee amount for the deposit (input) of the swap transaction. Amount should be for the network_fee_input_currency. Will be 0 for input_type TRADING and > 0 for USERKEY
 * @property {string} network_fee_input_currency - Network fee currency for the deposit (input) of the swap transaction, for the network_fee_input_amount
 * @property {number} network_fee_output_amount - Network fee amount for the destination (output) of the swap transaction. Amount should be for the network_fee_output_currency. Will be 0 for output_type TRADING and > 0 for USERKEY
 * @property {string} network_fee_output_currency - Network fee currency for the destination (output) of the swap transaction, for the network_fee_output_amount
 * @property {number} output_amount - The amount for the output currency
 * @property {string} output_currency - Symbol for the crypto currency being swap to. For example ETH in a BTC-ETH swap
 * @property {string} output_type - The type of account the swap funds are going to. (USERKEY for ON_CHAIN and TO_USERKEY directions, TRADING for INTERNAL and FROM_USERKEY directions)
 * @property {string} platform - From what platform the user wants to Swap from
 */
/**
 * @typedef SwapViewed
 * @property {string} device - Device type from where the event was triggered.
 * @property {string} [path] - Path portion of the URL of the page. Equivalent to canonical path which defaults to location.pathname from the DOM API.
 * @property {string} [platform] - What platform the page viewed belongs to
 * @property {string} [referrer] - Full URL of the previous page. Equivalent to document.referrer from the DOM API.
 * @property {string} [search] - Query string portion of the URL of the page. Equivalent to location.search from the DOM API.
 * @property {string} [title] - Title of the page. Equivalent to document.title from the DOM API.
 * @property {string} [url] - Full URL of the page. First we look for the canonical url. If the canonical url is not provided, we use location.href from the DOM API.
 */
/**
 * @typedef SwipeToReceiveOptionUpdated
 * @property {string} device - Device type from where the event was triggered.
 * @property {boolean} is_enabled - Receiving feature was enabled or disabled.
 * @property {string} platform - From what platform the user is managing Security events
 */
/**
 * @typedef SyncMyWidgetPortfolioUpdated
 * @property {string} device - Device type from where the event was triggered.
 * @property {boolean} is_enabled - My Widget Portafolio Sync option enabled or disabled.
 * @property {string} platform - From what platform the user is managing Security events
 */
/**
 * @typedef ThemeSet
 * @property {string} [device] - Device type from where the event was triggered.
 * @property {string} platform - From what platform the user is using the Settings
 * @property {string} theme -
 */
/**
 * @typedef TradeAmountEntered
 * @property {string} [collateral_type] - Currency for collateral
 * @property {string} device - Device type from where the event was triggered.
 * @property {number} input_amount - Amount of the trade in input currency
 * @property {number | null} [leverage_ratio] - Ratio of leverage. 2 for 2x, 3 for 3x, etc.
 * @property {number} [limit_price] - Limit price of the trade (empty for market orders)
 * @property {string} pair - What is the trading pair of the trade
 * @property {string} platform - From what platform the event is triggered
 * @property {string} side - whether it's a buy or sell trade
 * @property {number} [stop_loss] - Stop loss price for leverage
 * @property {number} [stop_price] - Stop price of the trade (only for stop-limit orders)
 * @property {string} tif - Time In Force (empty for Market trades, required otherwise)
 * @property {string} trade_type - What type of trade is created
 * @property {boolean} with_leverage - Trade with leverage
 */
/**
 * @typedef TradeAmountHelperClicked
 * @property {number} [amount] - What amount in amount_currency the user clicks on (either amount or amount_pct should be specified)
 * @property {string} [amount_currency] - What currency  for the amount selected (empty if the amount is in percentage)
 * @property {number} [amount_pct] - What amount percentage the user clicks on (either amount or amount_pct should be specified) Enter 25 if 25% selected
 * @property {string} device - Device type from where the event was triggered.
 * @property {number} input_amount - Amount of the trade in input currency
 * @property {string} pair - What is the trading pair of the trade
 * @property {string} platform - From what platform the amount is triggered
 * @property {string} side - whether it's a buy or sell trade
 * @property {string} tif - Time In Force (empty for Market trades, required otherwise)
 * @property {string} trade_type - What type of trade is created
 */
/**
 * @typedef TradeCancellationRequested
 * @property {string} device - Device type from where the event was triggered.
 * @property {string} origin - What button the user clicked on to request the cancelation.  OPEN_ORDERS : From the list of open orders. TRADE_HISTORY : from the trade history page. TRADE_DETAILS : bottom of the trade details.
 */
/**
 * @typedef TradeCreated
 * @property {string} device - Device type from where the event was triggered.
 * @property {number} exchange_rate - the exchange rate, If pair is BTC-USD, it is how much 1 BTC is worth in BTC.
 * @property {string | null} [handle_instruction] - Handle instruction. M for margin order, PSF for spot orders that are created in the background to close a margin position, null for spot orders, C not used at the moment.
 * @property {number} input_amount - Amount of the trade in input currency
 * @property {number} input_amount_usd - Amount of the trade in USD
 * @property {string} pair - What is the trading pair of the trade
 * @property {string} side - whether it's a buy or sell trade
 * @property {string} [tif] - Time In Force (empty for Market trades, required otherwise)
 * @property {string} [trade_id] - TBD with Niall
 * @property {string} trade_type - What type of trade is created
 */
/**
 * @typedef TradeFilled
 * @property {string} device - Device type from where the event was triggered.
 * @property {number} exchange_rate - the exchange rate, If pair is BTC-USD, it is how much 1 BTC is worth in BTC.
 * @property {number} fee_amount - Trade fee in native counter currency. (for BTC-ETH pair it would be ETH). For 0.013 ETH fee, enter 0.013.
 * @property {number} fee_amount_usd - IMPORTANT : Trade fee in USD. This will be used for revenue information. For 0.12 USD enter 0.12, NOT 12.
 * @property {string} handle_instruction - Handle instruction. M for margin order, PSF for spot orders that are created in the background to close a margin position, null for spot orders, C not used at the moment.
 * @property {number} input_amount - The amount being filled for the trade, the input currency
 * @property {number} input_amount_usd - The amount being filled for the trade in USD
 * @property {string} liquidity_indicator - Whether the trade fill Adds liquidity (A) = MAKER  or Removes liquidity = TAKER. or NEUTRAL
 * @property {string} pair - What is the trading pair of the trade
 * @property {string} side - Whether it is a Buy or Sell trade
 * @property {string} tif - Time In Force (empty for Market trades, required otherwise)
 * @property {string} [trade_id] - TBD with Niall
 * @property {string} trade_type - What type of trade is created
 * @property {number} volume_usd_last_30d - What is the trading volume of the user in the last 30d, including this input_amount_usd. This is mainly used for Tune integration to reward user based on the user tier.
 */
/**
 * @typedef TradePreviewCancelled
 * @property {string} device - Device type from where the event was triggered.
 * @property {number} input_amount - Amount of the trade in input currency
 * @property {number} [limit_price] - Limit price of the trade (empty for market orders)
 * @property {string} pair - What is the trading pair of the trade
 * @property {string} platform - From what platform the event is triggered
 * @property {string} side - whether it's a buy or sell trade
 * @property {number} [stop_price] - Stop price of the trade (only for stop-limit orders)
 * @property {string} tif - Time In Force (empty for Market trades, required otherwise)
 * @property {string} trade_type - What type of trade is created
 */
/**
 * @typedef TradePreviewRetried
 * @property {string} device - Device type from where the event was triggered.
 * @property {string} [failure_reason] - Why the previously submit trade previous failed
 * @property {number} input_amount - Amount of the trade in input currency
 * @property {number} [limit_price] - Limit price of the trade (empty for market orders)
 * @property {string} pair - What is the trading pair of the trade
 * @property {string} platform - From what platform the event is triggered
 * @property {string} side - whether it's a buy or sell trade
 * @property {number} [stop_price] - Stop price of the trade (only for stop-limit orders)
 * @property {string} tif - Time In Force (empty for Market trades, required otherwise)
 * @property {string} trade_type - What type of trade is created
 */
/**
 * @typedef TradePreviewSubmitted
 * @property {string} device - Device type from where the event was triggered.
 * @property {number} input_amount - Amount of the trade in input currency
 * @property {number} [limit_price] - Limit price of the trade (empty for market orders)
 * @property {string} pair - What is the trading pair of the trade
 * @property {string} platform - From what platform the event is triggered
 * @property {string} side - whether it's a buy or sell trade
 * @property {number} [stop_price] - Stop price of the trade (only for stop-limit orders)
 * @property {string} tif - Time In Force (empty for Market trades, required otherwise)
 * @property {string} trade_type - What type of trade is created
 */
/**
 * @typedef TradingClicked
 * @property {string} device - Device type from where the event was triggered.
 * @property {string} origin - what button we are referring to. NAVIGATION (mobile only) : navigation bar. TOP_MARKETS (mobile only) : click on the trading pair in Top Markets page, HOMEPAGE (web only) : the View Exchange button. PAIR_MENU : the pair selection. When clicking on the tab on web, or on the select from dropdown on mobile

 * @property {string} platform - What platform the user is clicking from
 */
/**
 * @typedef TradingViewed
 * @property {string} device - Device type from where the event was triggered.
 * @property {string} pair - What trading pair is being viewed
 * @property {string} [path] - Path portion of the URL of the page. Equivalent to canonical path which defaults to location.pathname from the DOM API.
 * @property {string} platform - What platform the page viewed belongs to
 * @property {string} [referrer] - Full URL of the previous page. Equivalent to document.referrer from the DOM API.
 * @property {string} [search] - Query string portion of the URL of the page. Equivalent to location.search from the DOM API.
 * @property {string} [title] - Title of the page. Equivalent to document.title from the DOM API.
 * @property {string} [url] - Full URL of the page. First we look for the canonical url. If the canonical url is not provided, we use location.href from the DOM API.
 */
/**
 * @typedef TwoStepVerificationDisabled
 * @property {string} [device] - Device type from where the event was triggered.
 * @property {string} platform - From what platform the user is managing Security events
 * @property {string} two_step_option - Which was the verification option activated before the user disabled two-step security? Authenticator App, Yubikey or Mobile Number
 */
/**
 * @typedef TwoStepVerificationEnabled
 * @property {string} [device] - Device type from where the event was triggered.
 * @property {string} platform - From what platform the user is managing Security events
 * @property {string} two_step_option - Which verification option was activated? Authenticator App, Yubikey or Mobile Number
 */
/**
 * @typedef TwoStepVerificationOptionClicked
 * @property {string} device - Device type from where the event was triggered.
 * @property {string} platform - From what platform the user is managing Security events
 * @property {string} two_step_option - Authenticator App, Yubikey or Mobile Number
 */
/**
 * @typedef UpgradeVerificationClicked
 * @property {Record<string, any>} [] - 
 * @property {string} device - Device type from where the event was triggered.
 * @property {string} origin - From what screen or action the user started the verification. What button we are referring to. 
AIRDROP: . 
DASHBOARD_PROMO : announcement card or promo on dashboard. EDD : when an upgrade is required because an Enhanced Due Diligence required for a high risk user. DEPOSIT : when depositing funds requires upgrading.
FIAT_FUNDS : when trying to deposit fiat. ONBOARDING : during a usual onboarding process.
RESUBMISSION : navigation bar.
SAVINGS (web only) : comes from interest savings product. 
SETTINGS: settings page. SIGN_UP : gold verification prompted at sign up upon account creation.  
SIMPLEBUY : from buy or sell product. SIMPLETRADE : from Simple Trade product in exchange.
SWAP: swap product. UNKNOWN : where origin could not be match to a product or other enums, or is hard to get
 * @property {string} platform - What platform the Upgrade Verification was clicked from
 * @property {number | null} tier - What tier the user is trying to update to. 1 = Silver, 2 = Gold, 3 = SDD + silver, 5 = Platinium
 */
/**
 * @typedef UserProductEligible
 * @property {string | null} currency - Used to check blocked regions and enabled currencies. (e.g. EUR)
 * @property {string} product - Product name that the eligibility is checked for
 */
/**
 * @typedef UserProductNotEligible
 * @property {string | null} currency - Used to check blocked regions and enabled currencies. (e.g. EUR)
 * @property {string} ineligibility_reason - Reason for the inelegibility
 * @property {string} platform - What platform the event was started from. (WALLET for wallet products nd EXCHANGE if product=MERCURY
 * @property {string} product - Product name that the eligibility is checked for
 */
/**
 * @typedef UserSddNotEligible
 * @property {string} ineligibility_reason - Reason for the inelegibility
 */
/**
 * @typedef VerificationCodeSubmitted
 * @property {string} device - Device type from where the event was triggered.
 * @property {string} platform - From what platform the user is managing Security events
 * @property {string} two_step_option - Authenticator App, Yubikey or Mobile Number
 */
/**
 * @typedef VerificationCompleted
 * @property {string} platform - What platform the verification was started from. (WALLET if product=SWAP and EXCHANGE if product=MERCURY in the  kyc verification table from nabu gateway)
 * @property {string} provider - what entity is performing the verification. Typically BLOCKCHAIN or VERIFF
 * @property {number} tier - The tier the verification is about. 1 (Silver) or 2 (Gold) or 3 (SDD)
 */
/**
 * @typedef VerificationRejected
 * @property {string} platform - What platform the verification was started from. (WALLET if product=SWAP and EXCHANGE if product=MERCURY in the  kyc verification table from nabu gateway)
 * @property {string} provider - The entity that verifies the identity
 * @property {number} tier - The tier the verification is about. 1 (Silver) or 2 (Gold) or 3 (SDD)
 */
/**
 * @typedef VerificationStarted
 * @property {string} platform - What platform the verification was started from. (WALLET if product=SWAP and EXCHANGE if product=MERCURY in the  kyc verification table from nabu gateway)
 * @property {string} [provider] - The entity that verifies the identity
 * @property {number} tier - Only available for tier 2 (Gold). Missing for tier 1 (Silver) and 3 (SDD)
 */
/**
 * @typedef VerificationSubmissionFailed
 * @property {string} device - what device the verification submission was sent from
 * @property {string} failure_reason - why the verification submission failed
 * @property {string} platform - What platform the verification was started from. (WALLET if product=SWAP and EXCHANGE if product=MERCURY in the  kyc verification table from nabu gateway)
 * @property {string} provider - The entity that verifies the identity
 * @property {number} tier - The tier the verification is about. 1 (Silver) or 2 (Gold) or 3 (SDD)
 */
/**
 * @typedef WalletAccessViaTorUpdated
 * @property {string} [device] - Device type from where the event was triggered.
 * @property {boolean} is_blocked - True if user only allowed login from IP whitelist.
 * @property {string} platform - From what platform the user is managing Security events

 */
/**
 * @typedef WalletHyperlinkClicked
 * @property {Record<string, any>} [] - 
 * @property {string} device - What device the event is tracked from
 * @property {string} [origin] - From which part of the page was the button clicked
 * @property {string} platform - What platform the event is referring to.
 * @property {string} [platform_path] - Path portion of the URL of the page from where the button is clicked.
  PRICES: from the explorer general price page with all the coins listed. 
 PRICES_CURRENCY : blockchain.com/prices/[currency] : from the explorer price page about a specific crypto. .COM_WALLET :
blockchain.com/wallet. EXPLORER : https://www.blockchain.com/explorer
 */
/**
 * @typedef WalletSignedUp
 * @property {string} [country] - Country, as iso code alpha 2, provided by the user at sign up
 * @property {string} [country_state] - If applicable, country state, as ISO 3166-2 (US-NY for example),  provided by the user at sign up
 * @property {string} device - What device the user created a wallet from
 * @property {string} platform - What platform the user is creating his wallet account from.
 */
/**
 * @typedef WithdrawalAmountEntered
 * @property {number} amount - The amount the user will withdraw (before fee applies)
 * @property {string} currency - the currency the user wants to withdraw
 * @property {string} device - Device type from where the event was triggered.
 * @property {string} platform - What platform the user is withdraw funds from
 * @property {string} withdrawal_method - How the funds will be withdrawn : 
BANK_ACCOUNT: funds sent to a bank account. 
BANK_TRANSFER : Funds sent to Linked account via Open Banking or ACH. CRYPTO : withdrawing to a crypto address
 */
/**
 * @typedef WithdrawalAmountHelperClicked
 * @property {number} [amount_currency] - If the button explicitly displays the amount in a specific currency, what is the currency being clicked on for the max amount
 * @property {number} amount_pct - What amount percentage the user clicks on (either amount or amount_pct should be specified) Enter 25 if 25% selected
 * @property {string} currency - the currency the user wants to withdraw
 * @property {string} device - Device type from where the event was triggered.
 * @property {string} platform - From what platform the amount is triggered
 * @property {string} withdrawal_method - How the funds will be withdrawn : 
BANK_ACCOUNT: funds sent to a bank account. 
BANK_TRANSFER : Funds sent to Linked account via Open Banking or ACH. CRYPTO : withdrawing to a crypto address
 */
/**
 * @typedef WithdrawalAmountMaxClicked
 * @property {number} [amount_currency] - If the button explicitly displays the amount in a specific currency, what is the currency being clicked on for the max amount
 * @property {string} currency - the currency the user wants to withdraw
 * @property {string} device - Device type from where the event was triggered.
 * @property {string} platform - What platform the user is withdraw funds from
 * @property {string} withdrawal_method - How the funds will be withdrawn : 
BANK_ACCOUNT: funds sent to a bank account. 
BANK_TRANSFER : Funds sent to Linked account via Open Banking or ACH. 
 */
/**
 * @typedef WithdrawalAmountMinClicked
 * @property {string} [amount_currency] - If the button explicitly displays the amount in a specific currency, what is the currency being clicked on for the max amount
 * @property {string} currency - the currency the user wants to withdraw
 * @property {string} device - Device type from where the event was triggered.
 * @property {string} platform - What platform the user is withdraw funds from
 * @property {string} withdrawal_method - How the funds will be withdrawn : 
BANK_ACCOUNT: funds sent to a bank account. 
BANK_TRANSFER : Funds sent to Linked account via Open Banking or ACH. 
 */
/**
 * @typedef WithdrawalClicked
 * @property {string} device - Device type from where the event was triggered.
 * @property {string} origin - What Withdrawal button we are referring to. BALANCE : for the exchange, next to the balance (total account value) info on the main trading page. CURRENCY_PAGE : CTA or menu on the coin page next to balance. LINK_BANK : link a bank flow. LINK_WALLET. PORTFOLIO (exchange) : deposit next to currency balance.

 * @property {string} platform - What platform the user clicked on the withdrawal 
 */
/**
 * @typedef WithdrawalMethodSelected
 * @property {string} currency - the currency the user wants to withdraw
 * @property {string} device - Device type from where the event was triggered.
 * @property {string} platform - What platform the user is withdraw funds from
 * @property {string | null} [to_account_type] - To what type of account the user wants to withdraw funds to. Only makes sense for Exchange. Null otherwise. 
EXCHANGE : Blockchain Exchange wallet 
EXTERNAL : external address outside Blockchain.com. 
SAVINGS : interest saving account. 
TRADING : wallet custodial wallet. 
USERKEY : Non Custodial, Private Key, wallet
 * @property {string} withdrawal_method - How the funds will be withdrawn : 
BANK_ACCOUNT: funds sent to a bank account. 
BANK_TRANSFER : Funds sent to Linked account via Open Banking or ACH. CRYPTO : withdrawing to a crypto address
 */
/**
 * @typedef WithdrawalViewed
 * @property {string} device - Device type from where the event was triggered.
 * @property {string} [path] - Path portion of the URL of the page. Equivalent to canonical path which defaults to location.pathname from the DOM API.
 * @property {string} platform - What platform the user wants to withdraw from
 * @property {string} [referrer] - Full URL of the previous page. Equivalent to document.referrer from the DOM API.
 * @property {string} [search] - Query string portion of the URL of the page. Equivalent to location.search from the DOM API.
 * @property {string} [title] - Title of the page. Equivalent to document.title from the DOM API.
 * @property {string} [url] - Full URL of the page. First we look for the canonical url. If the canonical url is not provided, we use location.href from the DOM API.
 */

/**
 * the user's password was changed successfully.
 *
 * @param {AccountPasswordChanged} props - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function accountPasswordChanged(
	props: AccountPasswordChanged,
	options?: Segment.Options,
	callback?: Segment.Callback
): void {
	const schema = {
		$schema: 'http://json-schema.org/draft-07/schema#',
		description: "the user's password was changed successfully.",
		labels: {
			flow: 'security_v1',
			source: ['client', 'backend'],
		},
		properties: {
			context: {},
			properties: {
				properties: {
					account_type: {
						description:
							'What account we are talking about : USERKEY account : the Private Key (non custodial) wallet. CUSTODIAL : the custodial account allowing user to access their Trading, Savings, and/or Exchange wallets',
						enum: ['CUSTODIAL', 'USERKEY'],
						type: 'string',
					},
					device: {
						description: 'Device type from where the event was triggered.',
						enum: ['APP-iOS', 'WEB', 'APP-Android'],
						type: 'string',
					},
					platform: {
						description:
							'From what platform the user is managing Security events\n',
						enum: ['WALLET', 'EXCHANGE'],
						type: 'string',
					},
				},
				required: ['platform', 'account_type'],
				type: 'object',
			},
			traits: {
				type: 'object',
			},
		},
		required: ['properties'],
		title: 'Account Password Changed',
		type: 'object',
	}
	const message = {
		event: 'Account Password Changed',
		properties: props || {},
		options,
	}
	validateAgainstSchema(message, schema)

	const a = analytics()
	if (a) {
		a.track(
			'Account Password Changed',
			props || {},
			withTypewriterContext(options),
			callback
		)
	}
}
/**
 * The user reset their password during a recovery process. This is triggered when the user enters the new password. This is different to the Account Password Changed event which is when user updates it for security reason by providing the old password.
 *
 * @param {AccountPasswordReset} props - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function accountPasswordReset(
	props: AccountPasswordReset,
	options?: Segment.Options,
	callback?: Segment.Callback
): void {
	const schema = {
		$schema: 'http://json-schema.org/draft-07/schema#',
		description:
			'The user reset their password during a recovery process. This is triggered when the user enters the new password. This is different to the Account Password Changed event which is when user updates it for security reason by providing the old password.',
		labels: {
			flow: 'recovery_v1',
			source: ['client', 'backend'],
		},
		properties: {
			context: {},
			properties: {
				properties: {
					account_type: {
						description:
							'What account we are talking about : USERKEY account : the Private Key (non custodial) wallet. CUSTODIAL : the custodial account allowing user to access their Trading, Savings, and/or Exchange wallets',
						enum: ['CUSTODIAL', 'USERKEY'],
						type: 'string',
					},
					device: {
						description: 'Device type from where the event was triggered.',
						enum: ['APP-iOS', 'WEB', 'APP-Android'],
						type: 'string',
					},
					exchange: {
						description: 'Parameters about the exchange account',
						properties: {
							two_fa_mode: {
								description: 'Whether the exchange account has 2FA set up',
								type: 'boolean',
							},
							user_id: {
								description: 'Exchange user credentials ID',
								type: 'string',
							},
						},
						required: [],
						type: 'object',
					},
					mergeable: {
						description: 'Indicates if possible to merge two unlinked accounts',
						type: 'boolean',
					},
					platform: {
						description: 'what platform the account is for',
						enum: ['WALLET', 'EXCHANGE'],
						type: 'string',
					},
					site_redirect: {
						description:
							'In reset : Whether the user is being redirected to the exchange or wallet',
						enum: ['EXCHANGE', 'WALLET'],
						type: 'string',
					},
					upgradeable: {
						description:
							'Indicates if possible to upgrade to a new unified Blockchain.com Account',
						type: 'boolean',
					},
					wallet: {
						description: 'Parameters about the wallet account',
						properties: {
							auth_type: {
								description: 'The wallet 2FA type that is enforced.',
								enum: [
									'0_NONE',
									'1_YUBIKEY',
									'2_EMAIL',
									'3_YUBIKEY_MTGOX',
									'4_GOOGLE_AUTHENTICATOR',
									'5_SMS',
								],
								type: 'string',
							},
							exchange: {
								description: 'Parameters about the exchange account',
								properties: {
									two_fa_mode: {
										description: 'Whether the exchange account has 2FA set up',
										properties: {},
										required: [],
										type: 'object',
									},
									user_id: {
										description: 'Exchange user credentials ID',
										type: 'object',
									},
								},
								required: [],
								type: 'object',
							},
							guid_first_four: {
								description:
									'The first four characters of the wallet.guid field',
								pattern: '^.{4,4}$',
								type: 'string',
							},
							has_cloud_backup: {
								description: 'Whether the wallet has cloud backups',
								type: 'boolean',
							},
							is_mobile_setup: {
								description: 'Whether the wallet has a mobile client set up',
								type: 'boolean',
							},
							last_mnemonic_backup: {
								description:
									'The last time, in unix timestamp, in which a wallet has their mnemonic backup verified',
								type: 'integer',
							},
							mobile_device_type: {
								description: 'The type of device being verified',
								enum: ['APP-Android', 'APP-iOS'],
								type: 'string',
							},
							nabu: {
								description: 'Parameter about the nabu account',
								properties: {
									recovery_eligible: {
										description:
											'Whether the nabu user is eligible for recovery. Usually if account has value (> $300 or 1 payment method linked)',
										type: 'boolean',
									},
									user_id: {
										description:
											'The Nabu User ID. This is from the users table in nabu gateway',
										type: 'object',
									},
								},
								required: [],
								type: 'object',
							},
						},
						required: [],
						type: 'object',
					},
					with_recovery_phrase: {
						description:
							'Whether the resetting the password was after successfully providing the recovery phrase (True). If Not, (False) it is the reset flow without recovery phrase after acknowledging there could be loss of funds',
						type: 'boolean',
					},
				},
				required: [
					'site_redirect',
					'platform',
					'account_type',
					'with_recovery_phrase',
				],
				type: 'object',
			},
			traits: {
				type: 'object',
			},
		},
		required: ['properties'],
		title: 'Account Password Reset',
		type: 'object',
	}
	const message = {
		event: 'Account Password Reset',
		properties: props || {},
		options,
	}
	validateAgainstSchema(message, schema)

	const a = analytics()
	if (a) {
		a.track(
			'Account Password Reset',
			props || {},
			withTypewriterContext(options),
			callback
		)
	}
}
/**
 * The user tried to recover his account by resetting his password but it failed for some reasons. The alternative when it is successful is Account Password Reset.
 *
 * @param {AccountRecoveryFailed} props - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function accountRecoveryFailed(
	props: AccountRecoveryFailed,
	options?: Segment.Options,
	callback?: Segment.Callback
): void {
	const schema = {
		$schema: 'http://json-schema.org/draft-07/schema#',
		description:
			'The user tried to recover his account by resetting his password but it failed for some reasons. The alternative when it is successful is Account Password Reset.',
		labels: {
			flow: 'recovery_v1',
			source: ['client', 'backend'],
		},
		properties: {
			context: {},
			properties: {
				properties: {
					account_type: {
						description:
							'What account we are talking about : USERKEY account : the Private Key (non custodial) wallet. CUSTODIAL : the custodial account allowing user to access their Trading, Savings, and/or Exchange wallets',
						enum: ['CUSTODIAL', 'USERKEY'],
						type: 'string',
					},
					device: {
						description: 'Device type from where the event was triggered.',
						enum: ['APP-iOS', 'WEB', 'APP-Android'],
						type: 'string',
					},
					exchange: {
						description: 'Parameters about the exchange account',
						properties: {
							two_fa_mode: {
								description: 'Whether the exchange account has 2FA set up',
								type: 'boolean',
							},
							user_id: {
								description: 'Exchange user credentials ID',
								type: 'string',
							},
						},
						required: [],
						type: 'object',
					},
					mergeable: {
						description: 'Indicates if possible to merge two unlinked accounts',
						type: 'boolean',
					},
					platform: {
						description: 'what platform the account is for',
						enum: ['WALLET', 'EXCHANGE'],
						type: 'string',
					},
					site_redirect: {
						description:
							'In reset : Whether the user is being redirected to the exchange or wallet',
						enum: ['EXCHANGE', 'WALLET'],
						type: 'string',
					},
					upgradeable: {
						description:
							'Indicates if possible to upgrade to a new unified Blockchain.com Account',
						type: 'boolean',
					},
					wallet: {
						description: 'Parameters about the wallet account',
						properties: {
							auth_type: {
								description: 'The wallet 2FA type that is enforced.',
								enum: [
									'0_NONE',
									'1_YUBIKEY',
									'2_EMAIL',
									'3_YUBIKEY_MTGOX',
									'4_GOOGLE_AUTHENTICATOR',
									'5_SMS',
								],
								type: 'string',
							},
							exchange: {
								description: 'Parameters about the exchange account',
								properties: {
									two_fa_mode: {
										description: 'Whether the exchange account has 2FA set up',
										properties: {},
										required: [],
										type: 'object',
									},
									user_id: {
										description: 'Exchange user credentials ID',
										type: 'object',
									},
								},
								required: [],
								type: 'object',
							},
							guid_first_four: {
								description:
									'The first four characters of the wallet.guid field',
								pattern: '^.{4,4}$',
								type: 'string',
							},
							has_cloud_backup: {
								description: 'Whether the wallet has cloud backups',
								type: 'boolean',
							},
							is_mobile_setup: {
								description: 'Whether the wallet has a mobile client set up',
								type: 'boolean',
							},
							last_mnemonic_backup: {
								description:
									'The last time, in unix timestamp, in which a wallet has their mnemonic backup verified',
								type: 'integer',
							},
							mobile_device_type: {
								description: 'The type of device being verified',
								enum: ['APP-Android', 'APP-iOS'],
								type: 'string',
							},
							nabu: {
								description: 'Parameter about the nabu account',
								properties: {
									recovery_eligible: {
										description:
											'Whether the nabu user is eligible for recovery. Usually if account has value (> $300 or 1 payment method linked)',
										type: 'boolean',
									},
									user_id: {
										description:
											'The Nabu User ID. This is from the users table in nabu gateway',
										type: 'object',
									},
								},
								required: [],
								type: 'object',
							},
						},
						required: [],
						type: 'object',
					},
				},
				required: ['site_redirect', 'platform', 'account_type'],
				type: 'object',
			},
			traits: {
				type: 'object',
			},
		},
		required: ['properties'],
		title: 'Account Recovery Failed',
		type: 'object',
	}
	const message = {
		event: 'Account Recovery Failed',
		properties: props || {},
		options,
	}
	validateAgainstSchema(message, schema)

	const a = analytics()
	if (a) {
		a.track(
			'Account Recovery Failed',
			props || {},
			withTypewriterContext(options),
			callback
		)
	}
}
/**
 * The user clicks on button which shows the widget to input the number.
 *
 * @param {AddMobileNumberClicked} props - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function addMobileNumberClicked(
	props: AddMobileNumberClicked,
	options?: Segment.Options,
	callback?: Segment.Callback
): void {
	const schema = {
		$schema: 'http://json-schema.org/draft-07/schema#',
		description:
			'The user clicks on button which shows the widget to input the number.',
		labels: {
			flow: 'settings_v1',
			source: 'client',
		},
		properties: {
			context: {},
			properties: {
				properties: {
					device: {
						description: 'Device type from where the event was triggered.',
						enum: ['APP-iOS', 'WEB', 'APP-Android'],
						type: 'string',
					},
					platform: {
						description: 'From what platform the user is using the Settings',
						enum: ['EXCHANGE', 'WALLET'],
						type: 'string',
					},
				},
				required: ['device', 'platform'],
				type: 'object',
			},
			traits: {
				type: 'object',
			},
		},
		required: ['properties'],
		title: 'Add Mobile Number Clicked',
		type: 'object',
	}
	const message = {
		event: 'Add Mobile Number Clicked',
		properties: props || {},
		options,
	}
	validateAgainstSchema(message, schema)

	const a = analytics()
	if (a) {
		a.track(
			'Add Mobile Number Clicked',
			props || {},
			withTypewriterContext(options),
			callback
		)
	}
}
/**
 * A user has imported an address to the wallet by adding the PK
 *
 * @param {AddressImported} props - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function addressImported(
	props: AddressImported,
	options?: Segment.Options,
	callback?: Segment.Callback
): void {
	const schema = {
		$schema: 'http://json-schema.org/draft-07/schema#',
		description:
			'A user has imported an address to the wallet by adding the PK',
		labels: {
			flow: 'settings_v1',
			source: 'backend',
		},
		properties: {
			context: {},
			properties: {
				properties: {
					currency: {
						description: '',
						pattern: '^[A-Z]{3,5}$',
						type: 'string',
					},
					device: {
						description: 'Device type from where the event was triggered.',
						enum: ['APP-iOS', 'WEB', 'APP-Android'],
						type: 'string',
					},
					funds_transferred: {
						description:
							'True if user transferred funds from the imported address to an existing wallet.',
						type: 'boolean',
					},
					label_added: {
						description:
							'True if the user added a label when importing address',
						type: 'boolean',
					},
					platform: {
						description: 'From what platform the user is using the Settings',
						enum: ['EXCHANGE', 'WALLET'],
						type: 'string',
					},
				},
				required: ['funds_transferred', 'currency', 'platform', 'label_added'],
				type: 'object',
			},
			traits: {
				type: 'object',
			},
		},
		required: ['properties'],
		title: 'Address Imported',
		type: 'object',
	}
	const message = {
		event: 'Address Imported',
		properties: props || {},
		options,
	}
	validateAgainstSchema(message, schema)

	const a = analytics()
	if (a) {
		a.track(
			'Address Imported',
			props || {},
			withTypewriterContext(options),
			callback
		)
	}
}
/**
 * User enters and submits his address
 *
 * @param {AddressInformationEntered} props - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function addressInformationEntered(
	props: AddressInformationEntered,
	options?: Segment.Options,
	callback?: Segment.Callback
): void {
	const schema = {
		$schema: 'http://json-schema.org/draft-07/schema#',
		description: 'User enters and submits his address',
		labels: {
			flow: 'onboarding_e1',
			source: 'client',
		},
		properties: {
			context: {},
			properties: {
				properties: {
					device: {
						description: 'Device type from where the event was triggered.',
						enum: ['APP-Android', 'APP-iOS', 'WEB'],
						type: 'string',
					},
					platform: {
						description: 'What platform the user is entering PII from',
						enum: ['EXCHANGE', 'WALLET'],
						type: 'string',
					},
				},
				required: ['platform', 'device'],
				type: 'object',
			},
			traits: {
				type: 'object',
			},
		},
		required: ['properties'],
		title: 'Address Information Entered',
		type: 'object',
	}
	const message = {
		event: 'Address Information Entered',
		properties: props || {},
		options,
	}
	validateAgainstSchema(message, schema)

	const a = analytics()
	if (a) {
		a.track(
			'Address Information Entered',
			props || {},
			withTypewriterContext(options),
			callback
		)
	}
}
/**
 * Non custodial address Label was updated.
 *
 * @param {AddressLabelEdited} props - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function addressLabelEdited(
	props: AddressLabelEdited,
	options?: Segment.Options,
	callback?: Segment.Callback
): void {
	const schema = {
		$schema: 'http://json-schema.org/draft-07/schema#',
		description: 'Non custodial address Label was updated.',
		labels: {
			flow: 'settings_v1',
			source: 'backend',
		},
		properties: {
			context: {},
			properties: {
				properties: {
					currency: {
						description: '',
						pattern: '^[A-Z]{3,5}$',
						type: 'string',
					},
					device: {
						description: 'Device type from where the event was triggered.',
						enum: ['APP-iOS', 'WEB', 'APP-Android'],
						type: 'string',
					},
					platform: {
						description: 'From what platform the user is using the Settings',
						enum: ['EXCHANGE', 'WALLET'],
						type: 'string',
					},
					transaction_format: {
						description: 'Segwit format or Legacy format',
						enum: ['LEGACY', 'SEGWIT'],
						type: 'string',
					},
				},
				required: ['transaction_format', 'currency', 'platform'],
				type: 'object',
			},
			traits: {
				type: 'object',
			},
		},
		required: ['properties'],
		title: 'Address Label Edited',
		type: 'object',
	}
	const message = {
		event: 'Address Label Edited',
		properties: props || {},
		options,
	}
	validateAgainstSchema(message, schema)

	const a = analytics()
	if (a) {
		a.track(
			'Address Label Edited',
			props || {},
			withTypewriterContext(options),
			callback
		)
	}
}
/**
 * A messaged signed by address' owner was verified
 *
 * @param {AddressMessageVerified} props - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function addressMessageVerified(
	props: AddressMessageVerified,
	options?: Segment.Options,
	callback?: Segment.Callback
): void {
	const schema = {
		$schema: 'http://json-schema.org/draft-07/schema#',
		description: "A messaged signed by address' owner was verified ",
		labels: {
			flow: 'settings_v1',
			source: 'backend',
		},
		properties: {
			context: {},
			properties: {
				properties: {
					currency: {
						description: '',
						pattern: '^[A-Z]{3,5}$',
						type: 'string',
					},
					device: {
						description: 'Device type from where the event was triggered.',
						enum: ['APP-iOS', 'WEB', 'APP-Android'],
						type: 'string',
					},
					platform: {
						description: 'From what platform the user is using the Settings',
						enum: ['EXCHANGE', 'WALLET'],
						type: 'string',
					},
				},
				required: ['platform', 'currency'],
				type: 'object',
			},
			traits: {
				type: 'object',
			},
		},
		required: ['properties'],
		title: 'Address Message Verified',
		type: 'object',
	}
	const message = {
		event: 'Address Message Verified',
		properties: props || {},
		options,
	}
	validateAgainstSchema(message, schema)

	const a = analytics()
	if (a) {
		a.track(
			'Address Message Verified',
			props || {},
			withTypewriterContext(options),
			callback
		)
	}
}
/**
 * Track each time the user opens the widget to verify a Bitcoin message.
 *
 * @param {AddressVerifyMessageClicked} props - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function addressVerifyMessageClicked(
	props: AddressVerifyMessageClicked,
	options?: Segment.Options,
	callback?: Segment.Callback
): void {
	const schema = {
		$schema: 'http://json-schema.org/draft-07/schema#',
		description:
			'Track each time the user opens the widget to verify a Bitcoin message.',
		labels: {
			flow: 'settings_v1',
			source: 'client',
		},
		properties: {
			context: {},
			properties: {
				properties: {
					device: {
						description: 'Device type from where the event was triggered.',
						enum: ['WEB'],
						type: 'string',
					},
					platform: {
						description: 'From what platform the user is using the Settings',
						enum: ['EXCHANGE', 'WALLET'],
						type: 'string',
					},
				},
				required: ['platform', 'device'],
				type: 'object',
			},
			traits: {
				type: 'object',
			},
		},
		required: ['properties'],
		title: 'Address Verify Message Clicked',
		type: 'object',
	}
	const message = {
		event: 'Address Verify Message Clicked',
		properties: props || {},
		options,
	}
	validateAgainstSchema(message, schema)

	const a = analytics()
	if (a) {
		a.track(
			'Address Verify Message Clicked',
			props || {},
			withTypewriterContext(options),
			callback
		)
	}
}
/**
 * Bitcoin address label edited from the addresses list.
 *
 * @param {AddressesRevealed} props - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function addressesRevealed(
	props: AddressesRevealed,
	options?: Segment.Options,
	callback?: Segment.Callback
): void {
	const schema = {
		$schema: 'http://json-schema.org/draft-07/schema#',
		description: 'Bitcoin address label edited from the addresses list.',
		labels: {
			flow: 'settings_v1',
			source: 'backend',
		},
		properties: {
			context: {},
			properties: {
				properties: {
					currency: {
						description: '',
						pattern: '^[A-Z]{3,5}$',
						type: 'string',
					},
					device: {
						description: 'Device type from where the event was triggered.',
						enum: ['APP-iOS', 'WEB', 'APP-Android'],
						type: 'string',
					},
					platform: {
						description: 'From what platform the user is using the Settings',
						enum: ['EXCHANGE', 'WALLET'],
						type: 'string',
					},
					transaction_format: {
						description: 'Segwit format or Legacy format',
						enum: ['LEGACY', 'SEGWIT'],
						type: 'string',
					},
				},
				required: ['platform', 'transaction_format', 'currency'],
				type: 'object',
			},
			traits: {
				type: 'object',
			},
		},
		required: ['properties'],
		title: 'Addresses Revealed',
		type: 'object',
	}
	const message = {
		event: 'Addresses Revealed',
		properties: props || {},
		options,
	}
	validateAgainstSchema(message, schema)

	const a = analytics()
	if (a) {
		a.track(
			'Addresses Revealed',
			props || {},
			withTypewriterContext(options),
			callback
		)
	}
}
/**
 * The user clicks on the widget or button to switch between native fiat and currency amounts
 *
 * @param {AmountSwitched} props - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function amountSwitched(
	props: AmountSwitched,
	options?: Segment.Options,
	callback?: Segment.Callback
): void {
	const schema = {
		$schema: 'http://json-schema.org/draft-07/schema#',
		description:
			'The user clicks on the widget or button to switch between native fiat and currency amounts',
		labels: {
			flow: 'swap_v1',
			source: 'client',
		},
		properties: {
			context: {},
			properties: {
				properties: {
					device: {
						description: 'Device type from where the event was triggered.',
						enum: ['APP-iOS', 'WEB', 'APP-Android'],
						type: 'string',
					},
					platform: {
						description: 'What platform the amount form is from. ',
						enum: ['EXCHANGE', 'WALLET'],
						type: 'string',
					},
					product: {
						description:
							'for what product the user has switched the amount. BUY: buy crypto with Simplebuy product. SAVINGS : interest savings account product SELL: sell crypto with Simplebuy product. SEND : send product to send or move crypto.  SIMPLEBUY: either buy or sell transaction (prefer BUY or SELL if known). SWAP : swap product',
						enum: ['BUY', 'SAVINGS', 'SELL', 'SEND', 'SIMPLEBUY', 'SWAP'],
						type: 'string',
					},
					switch_to: {
						description:
							'whether the amount switches to FIAT or Crypto. If the users sees $100 and wants to enter amount in BTC, it will click on the button and trigger this event with switch_to = CRYPTO',
						enum: ['CRYPTO', 'FIAT'],
						type: 'string',
					},
				},
				required: ['switch_to', 'product', 'platform', 'device'],
				type: 'object',
			},
			traits: {
				type: 'object',
			},
		},
		required: ['properties'],
		title: 'Amount Switched',
		type: 'object',
	}
	const message = {
		event: 'Amount Switched',
		properties: props || {},
		options,
	}
	validateAgainstSchema(message, schema)

	const a = analytics()
	if (a) {
		a.track(
			'Amount Switched',
			props || {},
			withTypewriterContext(options),
			callback
		)
	}
}
/**
 * User clicks to open site with information about Blockchain.com APIs.
 *
 * @param {ApiAccessLinkClicked} props - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function apiAccessLinkClicked(
	props: ApiAccessLinkClicked,
	options?: Segment.Options,
	callback?: Segment.Callback
): void {
	const schema = {
		$schema: 'http://json-schema.org/draft-07/schema#',
		description:
			'User clicks to open site with information about Blockchain.com APIs.',
		labels: {
			flow: 'security_v1',
			source: 'client',
		},
		properties: {
			context: {},
			properties: {
				properties: {
					device: {
						description: 'Device type from where the event was triggered.',
						enum: ['WEB'],
						type: 'string',
					},
					platform: {
						description:
							'From what platform the user is managing Security events\n',
						enum: ['EXCHANGE', 'WALLET'],
						type: 'string',
					},
				},
				required: ['platform', 'device'],
				type: 'object',
			},
			traits: {
				type: 'object',
			},
		},
		required: ['properties'],
		title: 'Api Access Link Clicked',
		type: 'object',
	}
	const message = {
		event: 'Api Access Link Clicked',
		properties: props || {},
		options,
	}
	validateAgainstSchema(message, schema)

	const a = analytics()
	if (a) {
		a.track(
			'Api Access Link Clicked',
			props || {},
			withTypewriterContext(options),
			callback
		)
	}
}
/**
 * user backgrounds the application
 *
 * @param {ApplicationBackgrounded} props - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function applicationBackgrounded(
	props: ApplicationBackgrounded,
	options?: Segment.Options,
	callback?: Segment.Callback
): void {
	const schema = {
		$schema: 'http://json-schema.org/draft-07/schema#',
		description: 'user backgrounds the application',
		labels: {
			source: 'client',
		},
		properties: {
			context: {},
			properties: {
				properties: {
					device: {
						description: 'Device type from where the event was triggered.',
						enum: ['APP-Android', 'APP-iOS'],
						type: 'string',
					},
					platfrom: {
						description: 'From Which platform (WALLET or EXCHANGE)\n',
						enum: ['EXCHANGE', 'WALLET'],
						type: 'string',
					},
				},
				required: ['device', 'platfrom'],
				type: 'object',
			},
			traits: {
				type: 'object',
			},
		},
		required: ['properties'],
		title: 'Application Backgrounded',
		type: 'object',
	}
	const message = {
		event: 'Application Backgrounded',
		properties: props || {},
		options,
	}
	validateAgainstSchema(message, schema)

	const a = analytics()
	if (a) {
		a.track(
			'Application Backgrounded',
			props || {},
			withTypewriterContext(options),
			callback
		)
	}
}
/**
 * receive a crash notification from your app, but is not meant to supplant traditional crash reporting tools.
 *
 * @param {ApplicationCrashed} props - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function applicationCrashed(
	props: ApplicationCrashed,
	options?: Segment.Options,
	callback?: Segment.Callback
): void {
	const schema = {
		$schema: 'http://json-schema.org/draft-07/schema#',
		description:
			'receive a crash notification from your app, but is not meant to supplant traditional crash reporting tools.',
		labels: {
			source: 'client',
		},
		properties: {
			context: {},
			properties: {
				properties: {
					device: {
						description: 'Device type from where the event was triggered.',
						enum: ['APP-Android', 'APP-iOS'],
						type: 'string',
					},
					platfrom: {
						description: 'From Which platform (WALLET or EXCHANGE)\n',
						enum: [' WALLET', 'EXCHANGE'],
						type: 'string',
					},
				},
				required: ['device', 'platfrom'],
				type: 'object',
			},
			traits: {
				type: 'object',
			},
		},
		required: ['properties'],
		title: 'Application Crashed',
		type: 'object',
	}
	const message = {
		event: 'Application Crashed',
		properties: props || {},
		options,
	}
	validateAgainstSchema(message, schema)

	const a = analytics()
	if (a) {
		a.track(
			'Application Crashed',
			props || {},
			withTypewriterContext(options),
			callback
		)
	}
}
/**
 * This event fires when a user first opens your mobile application. Note, if the user never opens your app after installing, we will not be able to collect this event.
 *
 * @param {ApplicationInstalled} props - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function applicationInstalled(
	props: ApplicationInstalled,
	options?: Segment.Options,
	callback?: Segment.Callback
): void {
	const schema = {
		$schema: 'http://json-schema.org/draft-07/schema#',
		description:
			'This event fires when a user first opens your mobile application. Note, if the user never opens your app after installing, we will not be able to collect this event.',
		labels: {
			source: 'client',
		},
		properties: {
			context: {},
			properties: {
				properties: {
					build: {
						description: 'The build number of the installed app.\n',
						type: 'string',
					},
					device: {
						description: 'Device type from where the event was triggered.',
						enum: ['APP-Android', 'APP-iOS'],
						type: 'string',
					},
					gps_adid: {
						description: 'the google play store advertising identifier',
						type: 'string',
					},
					install_begin_timestamp_server_seconds: {
						description: 'The timestamp in seconds when the install started',
						type: 'number',
					},
					install_referrer: {
						description: 'The referrer from the google play store referrer api',
						type: 'string',
					},
					platform: {
						description: 'From Which platform (WALLET or EXCHANGE)\n',
						enum: [' WALLET', 'EXCHANGE'],
						type: 'string',
					},
					version: {
						description: 'The version installed.',
						type: 'string',
					},
				},
				required: ['platform', 'version', 'build', 'device'],
				type: 'object',
			},
			traits: {
				type: 'object',
			},
		},
		required: ['properties'],
		title: 'Application Installed',
		type: 'object',
	}
	const message = {
		event: 'Application Installed',
		properties: props || {},
		options,
	}
	validateAgainstSchema(message, schema)

	const a = analytics()
	if (a) {
		a.track(
			'Application Installed',
			props || {},
			withTypewriterContext(options),
			callback
		)
	}
}
/**
 * This event fires when a user first opens your mobile application. Note, if the user never opens your app after installing, we will not be able to collect this event.
 *
 * @param {ApplicationOpened} props - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function applicationOpened(
	props: ApplicationOpened,
	options?: Segment.Options,
	callback?: Segment.Callback
): void {
	const schema = {
		$schema: 'http://json-schema.org/draft-07/schema#',
		description:
			'This event fires when a user first opens your mobile application. Note, if the user never opens your app after installing, we will not be able to collect this event.',
		labels: {
			source: 'client',
		},
		properties: {
			context: {},
			properties: {
				properties: {
					build: {
						description: 'The build number of the installed app.\n',
						type: 'string',
					},
					device: {
						description: 'Device type from where the event was triggered.',
						enum: ['APP-Android', 'APP-iOS'],
						type: 'string',
					},
					from_background: {
						description:
							'If application transitioned from “Background” to “Inactive” state prior to foregrounding (as opposed to from “Not Running” state).',
						type: 'boolean',
					},
					platform: {
						description: 'From Which platform (WALLET or EXCHANGE)\n',
						enum: [' EXCHANGE', 'WALLET'],
						type: 'string',
					},
					referring_application: {
						description:
							'The value of UIApplicationLaunchOptionsSourceApplicationKey from launchOptions. Automatically collected on iOS only.',
						type: 'string',
					},
					url: {
						description:
							'The value of UIApplicationLaunchOptionsURLKey from launchOptions. Collected on iOS only.',
						type: 'string',
					},
					version: {
						description: 'The version installed.',
						type: 'string',
					},
				},
				required: ['device', 'from_background', 'version', 'build', 'platform'],
				type: 'object',
			},
			traits: {
				type: 'object',
			},
		},
		required: ['properties'],
		title: 'Application Opened',
		type: 'object',
	}
	const message = {
		event: 'Application Opened',
		properties: props || {},
		options,
	}
	validateAgainstSchema(message, schema)

	const a = analytics()
	if (a) {
		a.track(
			'Application Opened',
			props || {},
			withTypewriterContext(options),
			callback
		)
	}
}
/**
 * user backgrounds the application
 *
 * @param {ApplicationUninstalled} props - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function applicationUninstalled(
	props: ApplicationUninstalled,
	options?: Segment.Options,
	callback?: Segment.Callback
): void {
	const schema = {
		$schema: 'http://json-schema.org/draft-07/schema#',
		description: 'user backgrounds the application',
		labels: {
			source: 'client',
		},
		properties: {
			context: {},
			properties: {
				properties: {
					device: {
						description: 'Device type from where the event was triggered.',
						enum: ['APP-Android', 'APP-iOS'],
						type: 'string',
					},
					platform: {
						description: 'From Which platform (WALLET or EXCHANGE)\n',
						enum: ['EXCHANGE', 'WALLET'],
						type: 'string',
					},
				},
				required: ['device', 'platform'],
				type: 'object',
			},
			traits: {
				type: 'object',
			},
		},
		required: ['properties'],
		title: 'Application Uninstalled',
		type: 'object',
	}
	const message = {
		event: 'Application Uninstalled',
		properties: props || {},
		options,
	}
	validateAgainstSchema(message, schema)

	const a = analytics()
	if (a) {
		a.track(
			'Application Uninstalled',
			props || {},
			withTypewriterContext(options),
			callback
		)
	}
}
/**
 * user updates the application.
 *
 * @param {ApplicationUpdated} props - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function applicationUpdated(
	props: ApplicationUpdated,
	options?: Segment.Options,
	callback?: Segment.Callback
): void {
	const schema = {
		$schema: 'http://json-schema.org/draft-07/schema#',
		description: 'user updates the application.',
		labels: {
			source: 'client',
		},
		properties: {
			context: {},
			properties: {
				properties: {
					build: {
						description: 'The build number of the installed app.\n',
						type: 'string',
					},
					device: {
						description: 'Device type from where the event was triggered.',
						enum: ['APP-Android', 'APP-iOS'],
						type: 'string',
					},
					installed_version: {
						description: 'Which version was installed the first time.',
						type: 'string',
					},
					platfrom: {
						description: 'From Which platform (WALLET or EXCHANGE)\n',
						enum: ['EXCHANGE', 'WALLET'],
						type: 'string',
					},
					previous_build: {
						description: 'The previously recorded build.',
						type: 'string',
					},
					previous_version: {
						description: 'The previously recorded version.',
						type: 'string',
					},
					version: {
						description: 'The version installed.',
						type: 'string',
					},
				},
				required: ['version', 'build', 'device', 'platfrom'],
				type: 'object',
			},
			traits: {
				type: 'object',
			},
		},
		required: ['properties'],
		title: 'Application Updated',
		type: 'object',
	}
	const message = {
		event: 'Application Updated',
		properties: props || {},
		options,
	}
	validateAgainstSchema(message, schema)

	const a = analytics()
	if (a) {
		a.track(
			'Application Updated',
			props || {},
			withTypewriterContext(options),
			callback
		)
	}
}
/**
 * The user sets the time period for the auto log out feature : after n minutes, the user automatically logs out.
 *
 * @param {AutoLogoutPeriodSet} props - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function autoLogoutPeriodSet(
	props: AutoLogoutPeriodSet,
	options?: Segment.Options,
	callback?: Segment.Callback
): void {
	const schema = {
		$schema: 'http://json-schema.org/draft-07/schema#',
		description:
			'The user sets the time period for the auto log out feature : after n minutes, the user automatically logs out.',
		labels: {
			flow: 'settings_v1',
			source: 'backend',
		},
		properties: {
			context: {},
			properties: {
				properties: {
					device: {
						description: 'Device type from where the event was triggered.',
						enum: ['APP-iOS', 'WEB', 'APP-Android'],
						type: 'string',
					},
					minutes: {
						description: 'minutes set for the max inactivity time period',
						type: 'integer',
					},
					platform: {
						description: 'From what platform the user is using the Settings',
						enum: ['EXCHANGE', 'WALLET'],
						type: 'string',
					},
				},
				required: ['minutes', 'platform'],
				type: 'object',
			},
			traits: {
				type: 'object',
			},
		},
		required: ['properties'],
		title: 'Auto Logout Period Set',
		type: 'object',
	}
	const message = {
		event: 'Auto Logout Period Set',
		properties: props || {},
		options,
	}
	validateAgainstSchema(message, schema)

	const a = analytics()
	if (a) {
		a.track(
			'Auto Logout Period Set',
			props || {},
			withTypewriterContext(options),
			callback
		)
	}
}
/**
 * A user's bank account state is updated
 *
 * @param {BankAccountStateTriggered} props - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function bankAccountStateTriggered(
	props: BankAccountStateTriggered,
	options?: Segment.Options,
	callback?: Segment.Callback
): void {
	const schema = {
		$schema: 'http://json-schema.org/draft-07/schema#',
		description: "A user's bank account state is updated",
		labels: {
			flow: ['withdraw_v1', 'settings_v1'],
			source: 'backend',
		},
		properties: {
			context: {},
			properties: {
				properties: {
					bank_name: {
						description:
							"What is the bank name. Found in extra_attributes -> 'bankName'. For example, BARCLAYS BANK PLC. Could be empty",
						pattern: '',
						type: 'string',
					},
					currency: {
						description: 'What fiat currency the bank account is for',
						pattern: '^[A-Z]{3,5}$',
						type: 'string',
					},
					entity: {
						description:
							'Payment Entity. Found in distinct(extra_attributes -> \'entity\') and could be empty (optional). For example, Fintecture(EU) or "Safeconnect(UK)"',
						type: 'string',
					},
					institution_name: {
						description: '',
						type: 'string',
					},
					partner: {
						description:
							'What is the bank partner. Found in partner column. Should be all upper case like in the table',
						pattern: '',
						type: 'string',
					},
					service: {
						description:
							'Whether this is ACH, OPEN_BANK. This does not apply for bank accounts, so set value to BANK_ACCOUNT in that case. You could know this by looking at account_ref which is either "ach_account" -> ACH or "open_banking" -> OPEN_BANKING',
						enum: ['ACH', 'BANK_ACCOUNT', 'OPEN_BANKING'],
						type: 'string',
					},
					state: {
						description: 'The updated state of the bank account',
						enum: ['ACTIVE', 'BLOCKED', 'CREATED', 'FRAUD_REVIEW', 'PENDING'],
						type: 'string',
					},
					type: {
						description:
							'What type of account it is. BANK_TRANSFER_ACCOUNT is renamed into BANK_TRANSFER and is for open banking and ach',
						enum: ['BANK_ACCOUNT', 'BANK_TRANSFER'],
						type: 'string',
					},
				},
				required: ['currency', 'partner', 'type', 'state'],
				type: 'object',
			},
			traits: {
				type: 'object',
			},
		},
		required: ['properties'],
		title: 'Bank Account State Triggered',
		type: 'object',
	}
	const message = {
		event: 'Bank Account State Triggered',
		properties: props || {},
		options,
	}
	validateAgainstSchema(message, schema)

	const a = analytics()
	if (a) {
		a.track(
			'Bank Account State Triggered',
			props || {},
			withTypewriterContext(options),
			callback
		)
	}
}
/**
 * Fires a 'Beneficiary Updated' track call.
 *
 * @param {BeneficiaryUpdated} props - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function beneficiaryUpdated(
	props: BeneficiaryUpdated,
	options?: Segment.Options,
	callback?: Segment.Callback
): void {
	const schema = {
		$schema: 'http://json-schema.org/draft-07/schema#',
		properties: {
			context: {},
			properties: {
				properties: {
					currency: {
						description: '',
						pattern: '^[A-Z0-9]{1,15}$',
						type: 'string',
					},
					institution_name: {
						description: '',
						type: 'string',
					},
					partner: {
						description: '',
						pattern: '^[A-Z0-9_]{1,15}$',
						type: 'string',
					},
					state: {
						description: '',
						enum: ['ACTIVE', 'BLOCKED', 'CREATED', 'FRAUD_REVIEW', 'PENDING'],
						type: 'string',
					},
					type: {
						description: '',
						enum: ['BANK_ACCOUNT', 'BANK_TRANSFER', 'CARD', 'CRYPTO'],
						type: 'string',
					},
				},
				required: ['state', 'type', 'currency', 'partner'],
				type: 'object',
			},
			traits: {
				type: 'object',
			},
		},
		required: ['properties'],
		title: 'Beneficiary Updated',
		type: 'object',
	}
	const message = {
		event: 'Beneficiary Updated',
		properties: props || {},
		options,
	}
	validateAgainstSchema(message, schema)

	const a = analytics()
	if (a) {
		a.track(
			'Beneficiary Updated',
			props || {},
			withTypewriterContext(options),
			callback
		)
	}
}
/**
 * Face Id or fingerprint security layer for mobile app was enabled or disabled.
 *
 * @param {BiometricsUpdated} props - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function biometricsUpdated(
	props: BiometricsUpdated,
	options?: Segment.Options,
	callback?: Segment.Callback
): void {
	const schema = {
		$schema: 'http://json-schema.org/draft-07/schema#',
		description:
			'Face Id or fingerprint security layer for mobile app was enabled or disabled.',
		labels: {
			flow: 'security_v1',
			source: 'client',
		},
		properties: {
			context: {},
			properties: {
				properties: {
					device: {
						description: 'Device type from where the event was triggered.',
						enum: ['APP-iOS', 'WEB', 'APP-Android'],
						type: 'string',
					},
					is_enabled: {
						description: 'Face Id was enabled or disabled.',
						type: 'boolean',
					},
					platform: {
						description:
							'From what platform the user is managing Security events',
						enum: ['WALLET'],
						type: 'string',
					},
				},
				required: ['platform', 'is_enabled', 'device'],
				type: 'object',
			},
			traits: {
				type: 'object',
			},
		},
		required: ['properties'],
		title: 'Biometrics Updated',
		type: 'object',
	}
	const message = {
		event: 'Biometrics Updated',
		properties: props || {},
		options,
	}
	validateAgainstSchema(message, schema)

	const a = analytics()
	if (a) {
		a.track(
			'Biometrics Updated',
			props || {},
			withTypewriterContext(options),
			callback
		)
	}
}
/**
 * The user enters and submits the amount for a buy transaction
 *
 * @param {BuyAmountEntered} props - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function buyAmountEntered(
	props: BuyAmountEntered,
	options?: Segment.Options,
	callback?: Segment.Callback
): void {
	const schema = {
		$schema: 'http://json-schema.org/draft-07/schema#',
		description: 'The user enters and submits the amount for a buy transaction',
		labels: {
			flow: ['simplebuy_v1', 'buy_rec', 'simple_trade_e1'],
			source: 'client',
		},
		properties: {
			context: {},
			properties: {
				properties: {
					device: {
						description: 'Device type from where the event was triggered.',
						enum: ['APP-iOS', 'WEB', 'APP-Android'],
						type: 'string',
					},
					frequency: {
						description:
							'What is the recurring frequency of the buy. Set it as ONE_TIME if it is not a recurring buy',
						enum: ['BI_WEEKLY', 'DAILY', 'MONTHLY', 'ONE_TIME', 'WEEKLY'],
						type: 'string',
					},
					input_amount: {
						description: 'The amount for the input currency ',
						type: 'number',
					},
					input_currency: {
						description:
							'Currency symbol for the currency being paid in exchange for some crypto. For example USD',
						pattern: '^[A-Z]{3,5}$',
						type: 'string',
					},
					max_card_limit: {
						description:
							'What is the maximum amount (in input_currency) being allowed for the Card order. Should be empty for other payment types. Amount usually recorded as a float. If 500 EUR, record 500.',
						type: 'number',
					},
					output_currency: {
						description:
							'Currency symbol for the currency being received. For example BTC',
						pattern: '^[A-Z]{3,5}$',
						type: 'string',
					},
					payment_method: {
						description: 'The payment method used for the order',
						enum: [
							'APPLE_PAY',
							'BANK_TRANSFER',
							'FUNDS',
							'GOOGLE_PAY',
							'PAYMENT_CARD',
						],
						type: 'string',
					},
					platform: {
						description: 'What platform the user wants to buy from',
						enum: ['EXCHANGE', 'WALLET'],
						type: 'string',
					},
				},
				required: [
					'input_currency',
					'input_amount',
					'device',
					'platform',
					'output_currency',
				],
				type: 'object',
			},
			traits: {
				type: 'object',
			},
		},
		required: ['properties'],
		title: 'Buy Amount Entered',
		type: 'object',
	}
	const message = {
		event: 'Buy Amount Entered',
		properties: props || {},
		options,
	}
	validateAgainstSchema(message, schema)

	const a = analytics()
	if (a) {
		a.track(
			'Buy Amount Entered',
			props || {},
			withTypewriterContext(options),
			callback
		)
	}
}
/**
 * The user clicked on the widget or button which sets pre selected amounts to the order

 *
 * @param {BuyAmountHelperClicked} props - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function buyAmountHelperClicked(
	props: BuyAmountHelperClicked,
	options?: Segment.Options,
	callback?: Segment.Callback
): void {
	const schema = {
		$schema: 'http://json-schema.org/draft-07/schema#',
		description:
			'The user clicked on the widget or button which sets pre selected amounts to the order\n',
		labels: {
			flow: 'simple_trade_e1',
			source: 'client',
		},
		properties: {
			context: {},
			properties: {
				properties: {
					amount: {
						description: 'What amount in amount_currency the user clicks on ',
						type: 'number',
					},
					amount_currency: {
						description: 'What currency  for the amount selected',
						pattern: '^[A-Z]{3,5}$',
						type: 'string',
					},
					device: {
						description: 'Device type from where the event was triggered.',
						enum: ['WEB'],
						type: 'string',
					},
					input_currency: {
						description:
							'Currency symbol for the currency being paid in exchange for some crypto. For example USD',
						pattern: '^[A-Z]{3,5}$',
						type: 'string',
					},
					output_currency: {
						description:
							'Currency symbol for the currency being received. For example BTC',
						pattern: '^[A-Z]{3,5}$',
						type: 'string',
					},
					platform: {
						description: 'From what platform the amount is triggered',
						enum: ['EXCHANGE'],
						type: 'string',
					},
				},
				required: [
					'amount_currency',
					'input_currency',
					'output_currency',
					'platform',
					'device',
					'amount',
				],
				type: 'object',
			},
			traits: {
				type: 'object',
			},
		},
		required: ['properties'],
		title: 'Buy Amount Helper Clicked',
		type: 'object',
	}
	const message = {
		event: 'Buy Amount Helper Clicked',
		properties: props || {},
		options,
	}
	validateAgainstSchema(message, schema)

	const a = analytics()
	if (a) {
		a.track(
			'Buy Amount Helper Clicked',
			props || {},
			withTypewriterContext(options),
			callback
		)
	}
}
/**
 * The user clicked on the widget or button which sets the max amount allowed or possible to the order.
 *
 * @param {BuyAmountMaxClicked} props - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function buyAmountMaxClicked(
	props: BuyAmountMaxClicked,
	options?: Segment.Options,
	callback?: Segment.Callback
): void {
	const schema = {
		$schema: 'http://json-schema.org/draft-07/schema#',
		description:
			'The user clicked on the widget or button which sets the max amount allowed or possible to the order.',
		labels: {
			flow: ['simplebuy_v1', 'simple_trade_e1'],
			source: 'client',
		},
		properties: {
			context: {},
			properties: {
				properties: {
					amount_currency: {
						description:
							'If the button explicitly displays the amount in a specific currency, what is the currency being clicked on for the max amount',
						pattern: '^[A-Z]{3,5}$',
						type: 'string',
					},
					device: {
						description: 'Device type from where the event was triggered.',
						enum: ['APP-iOS', 'WEB', 'APP-Android'],
						type: 'string',
					},
					input_currency: {
						description:
							'Currency symbol for the currency being paid in exchange for some crypto. For example USD',
						pattern: '^[A-Z]{3,5}$',
						type: 'string',
					},
					max_card_limit: {
						description:
							'What is the maximum amount (in input_currency) being allowed for the Card order. Should be empty for other payment types. Amount usually recorded as a float. If 500 EUR, record 500.',
						type: 'number',
					},
					output_currency: {
						description:
							'Currency symbol for the currency being received. For example BTC',
						pattern: '^[A-Z]{3,5}$',
						type: 'string',
					},
					platform: {
						description: 'What platform the user wants to buy from',
						enum: ['EXCHANGE', 'WALLET'],
						type: 'string',
					},
				},
				required: ['platform', 'output_currency', 'device', 'input_currency'],
				type: 'object',
			},
			traits: {
				type: 'object',
			},
		},
		required: ['properties'],
		title: 'Buy Amount Max Clicked',
		type: 'object',
	}
	const message = {
		event: 'Buy Amount Max Clicked',
		properties: props || {},
		options,
	}
	validateAgainstSchema(message, schema)

	const a = analytics()
	if (a) {
		a.track(
			'Buy Amount Max Clicked',
			props || {},
			withTypewriterContext(options),
			callback
		)
	}
}
/**
 * The user clicked on the widget or button which sets the min amount allowed or possible to the order.
 *
 * @param {BuyAmountMinClicked} props - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function buyAmountMinClicked(
	props: BuyAmountMinClicked,
	options?: Segment.Options,
	callback?: Segment.Callback
): void {
	const schema = {
		$schema: 'http://json-schema.org/draft-07/schema#',
		description:
			'The user clicked on the widget or button which sets the min amount allowed or possible to the order.',
		labels: {
			flow: 'simplebuy_v1',
			source: 'client',
		},
		properties: {
			context: {},
			properties: {
				properties: {
					amount_currency: {
						description:
							'If the button explicitly displays the amount in a specific currency, what is the currency being clicked on for the min amount',
						pattern: '^[A-Z]{3,5}$',
						type: 'string',
					},
					device: {
						description: 'Device type from where the event was triggered.',
						enum: ['APP-iOS', 'WEB', 'APP-Android'],
						type: 'string',
					},
					input_currency: {
						description:
							'Currency symbol for the currency being paid in exchange for some crypto. For example USD',
						pattern: '^[A-Z]{3,5}$',
						type: 'string',
					},
					output_currency: {
						description:
							'Currency symbol for the currency being received. For example BTC',
						pattern: '^[A-Z]{3,5}$',
						type: 'string',
					},
					platform: {
						description: 'What platform the user wants to buy from',
						enum: ['WALLET'],
						type: 'string',
					},
				},
				required: ['platform', 'device', 'output_currency', 'input_currency'],
				type: 'object',
			},
			traits: {
				type: 'object',
			},
		},
		required: ['properties'],
		title: 'Buy Amount Min Clicked',
		type: 'object',
	}
	const message = {
		event: 'Buy Amount Min Clicked',
		properties: props || {},
		options,
	}
	validateAgainstSchema(message, schema)

	const a = analytics()
	if (a) {
		a.track(
			'Buy Amount Min Clicked',
			props || {},
			withTypewriterContext(options),
			callback
		)
	}
}
/**
 * Buy order submitted by the user was cancelled (when updating a simple transaction with final state CANCELED)
 *
 * @param {BuyCancelled} props - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function buyCancelled(
	props: BuyCancelled,
	options?: Segment.Options,
	callback?: Segment.Callback
): void {
	const schema = {
		$schema: 'http://json-schema.org/draft-07/schema#',
		description:
			'Buy order submitted by the user was cancelled (when updating a simple transaction with final state CANCELED)',
		labels: {
			flow: ['simplebuy_v1', 'buy_rec'],
			source: 'backend',
		},
		properties: {
			context: {},
			properties: {
				properties: {
					device: {
						description: 'Device the payment was made from',
						enum: ['APP-Android', 'APP-iOS', 'WEB'],
						type: 'string',
					},
					fee_amount: {
						description: 'Fee (in "currency") being charged for the payment.',
						type: 'number',
					},
					fee_amount_usd: {
						description: 'Amount in USD payed by the user.',
						type: 'number',
					},
					input_amount: {
						description:
							'The amount for the input currency, usually as a float. For USD, it should be for example 1.23, meaning 1.23 USD',
						type: 'number',
					},
					input_amount_usd: {
						description:
							'The amount paid by the user in USD, usually as a float. it should be for example 10.23, meaning 10.23 USD',
						type: 'number',
					},
					input_currency: {
						description:
							'Currency symbol for the currency being paid by the user in exchange for some crypto. For example USD\n',
						pattern: '^[A-Z]{3,5}$',
						type: 'string',
					},
					is_recurring_buy: {
						description:
							'Whether the buy order was created automatically by a recurring buy order. It is when no "recurringBuyId" is found in input_attributes',
						type: 'boolean',
					},
					output_amount: {
						description:
							'The amount for the output currency, usually as a float. For BTC, it should be for example 1.23, meaning 1.23 BTC\n',
						type: 'number',
					},
					output_currency: {
						description:
							'Currency symbol for the currency being received by the user. For example BTC\n',
						pattern: '^[A-Z]{3,5}$',
						type: 'string',
					},
					payment_id: {
						description:
							'id of the payment (id of the transaction from nabu payments)',
						type: 'string',
					},
					payment_method: {
						description:
							'The payment method used for the buy order. (the paymentType in simple_transactions input_attributes)',
						enum: ['BANK_ACCOUNT', 'BANK_TRANSFER', 'FUNDS', 'PAYMENT_CARD'],
						type: 'string',
					},
					platform: {
						description:
							'What platform the event was started from. (WALLET if product=SIMPLEBUY and EXCHANGE if product=MERCURY\n',
						enum: ['EXCHANGE', 'WALLET'],
						type: 'string',
					},
					product: {
						description:
							'The Product for which the buy order is (the product columns of the simple_transactions table)',
						enum: ['MERCURY', 'SIMPLEBUY'],
						type: 'string',
					},
					quote_id: {
						description: 'The id used for the new pricing fee model (WALLET)',
						type: 'string',
					},
					recurring_buy_id: {
						description:
							'If the buy order was generated from a recurring buy, what is that recurringBuyId. Null otherwise',
						type: ['string', 'null'],
					},
					transaction_id: {
						description:
							'The id of the transaction for the buy order (the id of the simple_transactions table in nabu gateway)',
						type: 'string',
					},
				},
				required: [
					'platform',
					'input_currency',
					'payment_method',
					'product',
					'output_currency',
				],
				type: 'object',
			},
			traits: {
				type: 'object',
			},
		},
		required: ['properties'],
		title: 'Buy Cancelled',
		type: 'object',
	}
	const message = {
		event: 'Buy Cancelled',
		properties: props || {},
		options,
	}
	validateAgainstSchema(message, schema)

	const a = analytics()
	if (a) {
		a.track(
			'Buy Cancelled',
			props || {},
			withTypewriterContext(options),
			callback
		)
	}
}
/**
 * Buy order submitted by the user is completed (when updating a simple transaction with final state FINISHED)
 *
 * @param {BuyCompleted} props - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function buyCompleted(
	props: BuyCompleted,
	options?: Segment.Options,
	callback?: Segment.Callback
): void {
	const schema = {
		$schema: 'http://json-schema.org/draft-07/schema#',
		description:
			'Buy order submitted by the user is completed (when updating a simple transaction with final state FINISHED)',
		labels: {
			flow: ['simplebuy_v1', 'buy_rec'],
			source: 'backend',
		},
		properties: {
			context: {},
			properties: {
				properties: {
					device: {
						description: 'Device the payment was made from',
						enum: ['APP-Android', 'APP-iOS', 'WEB'],
						type: 'string',
					},
					fee_amount: {
						description: 'Fee (in "currency") being charged for the payment.',
						type: 'number',
					},
					fee_amount_usd: {
						description: 'Amount in USD payed by the user.',
						type: 'number',
					},
					input_amount: {
						description:
							'The amount for the input currency, usually as a float. For BTC, it should be for example 1.23, meaning 1.23 BTC',
						type: 'number',
					},
					input_amount_usd: {
						description:
							'The amount paid by the user in USD, usually as a float. it should be for example 10.23, meaning 10.23 USD',
						type: 'number',
					},
					input_currency: {
						description:
							'Currency symbol for the currency being paid by the user in exchange for some crypto. For example USD\n',
						pattern: '^[A-Z]{3,5}$',
						type: 'string',
					},
					is_recurring_buy: {
						description:
							'Whether the buy order was created automatically by a recurring buy order. It is when no "recurringBuyId" is found in input_attributes',
						type: 'boolean',
					},
					output_amount: {
						description:
							'The amount for the output currency, usually as a float. For BTC, it should be for example 1.23, meaning 1.23 BTC\n',
						type: 'number',
					},
					output_currency: {
						description:
							'Currency symbol for the currency being received by the user. For example BTC\n',
						pattern: '^[A-Z]{3,5}$',
						type: 'string',
					},
					payment_id: {
						description:
							'id of the payment (id of the transaction from nabu payments)',
						type: 'string',
					},
					payment_method: {
						description:
							'The payment method used for the buy order. (the paymentType in simple_transactions input_attributes)',
						enum: ['BANK_ACCOUNT', 'BANK_TRANSFER', 'FUNDS', 'PAYMENT_CARD'],
						type: 'string',
					},
					platform: {
						description:
							'What platform the event was started from. (WALLET if product=SIMPLEBUY and EXCHANGE if product=MERCURY\n',
						enum: ['EXCHANGE', 'WALLET'],
						type: 'string',
					},
					product: {
						description:
							'The Product for which the buy order is (the product columns of the simple_transactions table)',
						enum: ['MERCURY', 'SIMPLEBUY'],
						type: 'string',
					},
					quote_id: {
						description: 'The id used for the new pricing fee model (WALLET)',
						type: 'string',
					},
					recurring_buy_id: {
						description:
							'If the buy order was generated from a recurring buy, what is that recurringBuyId. Null otherwise',
						type: ['string', 'null'],
					},
					spread_percentage: {
						description: 'Spread percentage applied to the exchange rate',
						type: 'number',
					},
					transaction_id: {
						description:
							'The id of the transaction for the buy order (the id of the simple_transactions table in nabu gateway)',
						type: 'string',
					},
				},
				required: [
					'input_currency',
					'input_amount_usd',
					'spread_percentage',
					'input_amount',
					'payment_method',
					'product',
					'output_currency',
				],
				type: 'object',
			},
			traits: {
				type: 'object',
			},
		},
		required: ['properties'],
		title: 'Buy Completed',
		type: 'object',
	}
	const message = {
		event: 'Buy Completed',
		properties: props || {},
		options,
	}
	validateAgainstSchema(message, schema)

	const a = analytics()
	if (a) {
		a.track(
			'Buy Completed',
			props || {},
			withTypewriterContext(options),
			callback
		)
	}
}
/**
 * User submits a buy order (when creating a simple transactions with state CREATED)
 *
 * @param {BuyCreated} props - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function buyCreated(
	props: BuyCreated,
	options?: Segment.Options,
	callback?: Segment.Callback
): void {
	const schema = {
		$schema: 'http://json-schema.org/draft-07/schema#',
		description:
			'User submits a buy order (when creating a simple transactions with state CREATED)',
		labels: {
			flow: ['simplebuy_v1', 'buy_rec'],
			source: 'backend',
		},
		properties: {
			context: {},
			properties: {
				properties: {
					device: {
						description: 'Device the payment was made from',
						enum: ['APP-Android', 'APP-iOS', 'WEB'],
						type: 'string',
					},
					fee_amount: {
						description: 'Fee (in "currency") being charged for the payment.',
						type: 'number',
					},
					fee_amount_usd: {
						description: 'Amount in USD payed by the user.',
						type: 'number',
					},
					input_amount: {
						description:
							'The expected amount for the input currency, usually as a float. For BTC, it should be for example 1.23, meaning 1.23 BTC. Exact amount is only in Buy Completed',
						type: 'number',
					},
					input_amount_usd: {
						description:
							'The amount paid by the user in USD, usually as a float. it should be for example 10.23, meaning 10.23 USD',
						type: 'number',
					},
					input_currency: {
						description:
							'Currency symbol for the currency being paid by the user in exchange for some crypto. For example USD\n',
						pattern: '^[A-Z]{3,5}$',
						type: 'string',
					},
					is_recurring_buy: {
						description:
							'Whether the buy order was created automatically by a recurring buy order. It is when no "recurringBuyId" is found in input_attributes',
						type: 'boolean',
					},
					output_amount: {
						description:
							'The expected amount for the output currency, usually as a float. For BTC, it should be for example 1.23, meaning 1.23 BTC. Exact amount is only in Buy Completed',
						type: 'number',
					},
					output_currency: {
						description:
							'Currency symbol for the currency being received by the user. For example BTC\n',
						pattern: '^[A-Z]{3,5}$',
						type: 'string',
					},
					payment_id: {
						description:
							'id of the payment (id of the transaction from nabu payments)',
						type: 'string',
					},
					payment_method: {
						description:
							'The payment method used for the buy order. (the paymentType in simple_transactions input_attributes)',
						enum: ['BANK_ACCOUNT', 'BANK_TRANSFER', 'FUNDS', 'PAYMENT_CARD'],
						type: 'string',
					},
					platform: {
						description:
							'What platform the event was started from. (WALLET if product=SIMPLEBUY and EXCHANGE if product=MERCURY\n',
						enum: ['EXCHANGE', 'WALLET'],
						type: 'string',
					},
					product: {
						description:
							'The Product for which the buy order is (the product columns of the simple_transactions table)',
						enum: ['MERCURY', 'SIMPLEBUY'],
						type: 'string',
					},
					quote_id: {
						description: 'The id used for the new pricing fee model (WALLET)',
						type: 'string',
					},
					recurring_buy_id: {
						description:
							'If the buy order was generated from a recurring buy, what is that recurringBuyId. Null otherwise',
						type: ['string', 'null'],
					},
					transaction_id: {
						description:
							'The id of the transaction for the buy order (the id of the simple_transactions table in nabu gateway)',
						type: 'string',
					},
				},
				required: [
					'payment_method',
					'product',
					'output_currency',
					'platform',
					'input_currency',
				],
				type: 'object',
			},
			traits: {
				type: 'object',
			},
		},
		required: ['properties'],
		title: 'Buy Created',
		type: 'object',
	}
	const message = {
		event: 'Buy Created',
		properties: props || {},
		options,
	}
	validateAgainstSchema(message, schema)

	const a = analytics()
	if (a) {
		a.track(
			'Buy Created',
			props || {},
			withTypewriterContext(options),
			callback
		)
	}
}
/**
 * Buy order submitted by the user had failed (when updating a simple transaction with final state FAILED)
 *
 * @param {BuyExpired} props - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function buyExpired(
	props: BuyExpired,
	options?: Segment.Options,
	callback?: Segment.Callback
): void {
	const schema = {
		$schema: 'http://json-schema.org/draft-07/schema#',
		description:
			'Buy order submitted by the user had failed (when updating a simple transaction with final state FAILED)',
		labels: {
			flow: ['simplebuy_v1', 'buy_rec'],
			source: 'backend',
		},
		properties: {
			context: {},
			properties: {
				properties: {
					device: {
						description: 'Device the payment was made from',
						enum: ['APP-Android', 'APP-iOS', 'WEB'],
						type: 'string',
					},
					fee_amount: {
						description: 'Fee (in "currency") being charged for the payment.',
						type: 'number',
					},
					fee_amount_usd: {
						description: 'Amount in USD payed by the user.',
						type: 'number',
					},
					input_amount: {
						description:
							'The amount for the input currency, usually as a float. For BTC, it should be for example 1.23, meaning 1.23 BTC',
						type: 'number',
					},
					input_amount_usd: {
						description:
							'The amount paid by the user in USD, usually as a float. it should be for example 10.23, meaning 10.23 USD',
						type: 'number',
					},
					input_currency: {
						description:
							'Currency symbol for the currency being paid by the user in exchange for some crypto. For example USD\n',
						pattern: '^[A-Z]{3,5}$',
						type: 'string',
					},
					is_recurring_buy: {
						description:
							'Whether the buy order was created automatically by a recurring buy order. It is when no "recurringBuyId" is found in input_attributes',
						type: 'boolean',
					},
					output_amount: {
						description:
							'The amount for the output currency, usually as a float. For BTC, it should be for example 1.23, meaning 1.23 BTC\n',
						type: 'number',
					},
					output_currency: {
						description:
							'Currency symbol for the currency being received by the user. For example BTC\n',
						pattern: '^[A-Z]{3,5}$',
						type: 'string',
					},
					payment_id: {
						description:
							'id of the payment (id of the transaction from nabu payments)',
						type: 'string',
					},
					payment_method: {
						description:
							'The payment method used for the buy order. (the paymentType in simple_transactions input_attributes)',
						enum: ['BANK_ACCOUNT', 'BANK_TRANSFER', 'FUNDS', 'PAYMENT_CARD'],
						type: 'string',
					},
					platform: {
						description:
							'What platform the event was started from. (WALLET if product=SIMPLEBUY and EXCHANGE if product=MERCURY\n',
						enum: ['EXCHANGE', 'WALLET'],
						type: 'string',
					},
					product: {
						description:
							'The Product for which the buy order is (the product columns of the simple_transactions table)',
						enum: ['MERCURY', 'SIMPLEBUY'],
						type: 'string',
					},
					quote_id: {
						description: 'The id used for the new pricing fee model (WALLET)',
						type: 'string',
					},
					recurring_buy_id: {
						description:
							'If the buy order was generated from a recurring buy, what is that recurringBuyId. Null otherwise',
						type: ['string', 'null'],
					},
					transaction_id: {
						description:
							'The id of the transaction for the buy order (the id of the simple_transactions table in nabu gateway)',
						type: 'string',
					},
				},
				required: [
					'output_currency',
					'input_currency',
					'payment_method',
					'platform',
					'product',
				],
				type: 'object',
			},
			traits: {
				type: 'object',
			},
		},
		required: ['properties'],
		title: 'Buy Expired',
		type: 'object',
	}
	const message = {
		event: 'Buy Expired',
		properties: props || {},
		options,
	}
	validateAgainstSchema(message, schema)

	const a = analytics()
	if (a) {
		a.track(
			'Buy Expired',
			props || {},
			withTypewriterContext(options),
			callback
		)
	}
}
/**
 * Buy order submitted by the user had expired (when updating a simple transaction with final state EXPIRED)
 *
 * @param {BuyFailed} props - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function buyFailed(
	props: BuyFailed,
	options?: Segment.Options,
	callback?: Segment.Callback
): void {
	const schema = {
		$schema: 'http://json-schema.org/draft-07/schema#',
		description:
			'Buy order submitted by the user had expired (when updating a simple transaction with final state EXPIRED)',
		labels: {
			flow: ['simplebuy_v1', 'buy_rec'],
			source: 'backend',
		},
		properties: {
			context: {},
			properties: {
				properties: {
					device: {
						description: 'Device the payment was made from',
						enum: ['APP-Android', 'APP-iOS', 'WEB'],
						type: 'string',
					},
					fee_amount: {
						description: 'Fee (in "currency") being charged for the payment.',
						type: 'number',
					},
					fee_amount_usd: {
						description: 'Amount in USD payed by the user.',
						type: 'number',
					},
					input_amount: {
						description:
							'The amount for the input currency, usually as a float. For BTC, it should be for example 1.23, meaning 1.23 BTC',
						type: 'number',
					},
					input_amount_usd: {
						description:
							'The amount paid by the user in USD, usually as a float. it should be for example 10.23, meaning 10.23 USD',
						type: 'number',
					},
					input_currency: {
						description:
							'Currency symbol for the currency being paid by the user in exchange for some crypto. For example USD\n',
						pattern: '^[A-Z]{3,5}$',
						type: 'string',
					},
					is_recurring_buy: {
						description:
							'Whether the buy order was created automatically by a recurring buy order. It is when no "recurringBuyId" is found in input_attributes',
						type: 'boolean',
					},
					output_amount: {
						description:
							'The amount for the output currency, usually as a float. For BTC, it should be for example 1.23, meaning 1.23 BTC\n',
						type: 'number',
					},
					output_currency: {
						description:
							'Currency symbol for the currency being received by the user. For example BTC\n',
						pattern: '^[A-Z]{3,5}$',
						type: 'string',
					},
					payment_id: {
						description:
							'id of the payment (id of the transaction from nabu payments)',
						type: 'string',
					},
					payment_method: {
						description:
							'The payment method used for the buy order. (the paymentType in simple_transactions input_attributes)',
						enum: ['BANK_ACCOUNT', 'BANK_TRANSFER', 'FUNDS', 'PAYMENT_CARD'],
						type: 'string',
					},
					platform: {
						description:
							'What platform the event was started from. (WALLET if product=SIMPLEBUY and EXCHANGE if product=MERCURY\n',
						enum: [],
						type: 'string',
					},
					product: {
						description:
							'The Product for which the buy order is (the product columns of the simple_transactions table)',
						enum: ['MERCURY', 'SIMPLEBUY'],
						type: 'string',
					},
					quote_id: {
						description: 'The id used for the new pricing fee model (WALLET)',
						type: 'string',
					},
					recurring_buy_id: {
						description:
							'If the buy order was generated from a recurring buy, what is that recurringBuyId. Null otherwise',
						type: ['string', 'null'],
					},
					transaction_id: {
						description:
							'The id of the transaction for the buy order (the id of the simple_transactions table in nabu gateway)',
						type: 'string',
					},
				},
				required: [
					'product',
					'platform',
					'output_currency',
					'input_currency',
					'payment_method',
				],
				type: 'object',
			},
			traits: {
				type: 'object',
			},
		},
		required: ['properties'],
		title: 'Buy Failed',
		type: 'object',
	}
	const message = {
		event: 'Buy Failed',
		properties: props || {},
		options,
	}
	validateAgainstSchema(message, schema)

	const a = analytics()
	if (a) {
		a.track('Buy Failed', props || {}, withTypewriterContext(options), callback)
	}
}
/**
 * The user clicks and submits the frequency he wants to select for the buy order
 *
 * @param {BuyFrequencySelected} props - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function buyFrequencySelected(
	props: BuyFrequencySelected,
	options?: Segment.Options,
	callback?: Segment.Callback
): void {
	const schema = {
		$schema: 'http://json-schema.org/draft-07/schema#',
		description:
			'The user clicks and submits the frequency he wants to select for the buy order',
		labels: {
			flow: ['simplebuy_v1', 'buy_rec'],
			source: 'client',
		},
		properties: {
			context: {},
			properties: {
				properties: {
					device: {
						description: 'Device type from where the event was triggered.',
						enum: ['APP-iOS', 'WEB', 'APP-Android'],
						type: 'string',
					},
					frequency: {
						description:
							'What is the recurring frequency of the buy. Set it as ONE_TIME if it is not a recurring buy',
						enum: ['BI_WEEKLY', 'DAILY', 'MONTHLY', 'ONE_TIME', 'WEEKLY'],
						type: 'string',
					},
					platform: {
						description: 'What platform the user wants to buy from',
						enum: ['EXCHANGE', 'WALLET'],
						type: 'string',
					},
				},
				required: ['platform', 'frequency', 'device'],
				type: 'object',
			},
			traits: {
				type: 'object',
			},
		},
		required: ['properties'],
		title: 'Buy Frequency Selected',
		type: 'object',
	}
	const message = {
		event: 'Buy Frequency Selected',
		properties: props || {},
		options,
	}
	validateAgainstSchema(message, schema)

	const a = analytics()
	if (a) {
		a.track(
			'Buy Frequency Selected',
			props || {},
			withTypewriterContext(options),
			callback
		)
	}
}
/**
 * The user clicked on a Learn More widget in the end of the buy flow
 *
 * @param {BuyLearnMoreClicked} props - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function buyLearnMoreClicked(
	props: BuyLearnMoreClicked,
	options?: Segment.Options,
	callback?: Segment.Callback
): void {
	const schema = {
		$schema: 'http://json-schema.org/draft-07/schema#',
		description:
			'The user clicked on a Learn More widget in the end of the buy flow',
		labels: {
			flow: 'simplebuy_v1',
			source: 'client',
		},
		properties: {
			context: {},
			properties: {
				properties: {
					device: {
						description: 'Device type from where the event was triggered.',
						enum: ['APP-iOS', 'WEB', 'APP-Android'],
						type: 'string',
					},
					platform: {
						description: 'What platform the user wants to buy from',
						enum: ['EXCHANGE', 'WALLET'],
						type: 'string',
					},
					type: {
						description:
							'What does the user want to learn more about ? WITHDRAWAL_LOCK',
						enum: ['WITHDRAWAL_LOCK'],
						type: 'string',
					},
				},
				required: ['device', 'type'],
				type: 'object',
			},
			traits: {
				type: 'object',
			},
		},
		required: ['properties'],
		title: 'Buy Learn More Clicked',
		type: 'object',
	}
	const message = {
		event: 'Buy Learn More Clicked',
		properties: props || {},
		options,
	}
	validateAgainstSchema(message, schema)

	const a = analytics()
	if (a) {
		a.track(
			'Buy Learn More Clicked',
			props || {},
			withTypewriterContext(options),
			callback
		)
	}
}
/**
 * The user has selected the payment method he wants to use for buying crypto.
 *
 * @param {BuyPaymentMethodSelected} props - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function buyPaymentMethodSelected(
	props: BuyPaymentMethodSelected,
	options?: Segment.Options,
	callback?: Segment.Callback
): void {
	const schema = {
		$schema: 'http://json-schema.org/draft-07/schema#',
		description:
			'The user has selected the payment method he wants to use for buying crypto.',
		labels: {
			flow: 'simplebuy_v1',
			source: 'client',
		},
		properties: {
			context: {},
			properties: {
				properties: {
					device: {
						description: 'Device type from where the event was triggered.',
						enum: ['APP-iOS', 'WEB', 'APP-Android'],
						type: 'string',
					},
					payment_type: {
						description:
							'What payment type is selected : \nBANK_ACCOUNT: funds sent from a bank account. \nBANK_TRANSFER : Funds sent from Linked account via Open Banking or ACH. \nFUNDS: Funds taken from available funds in fiat wallet. \nPAYMENT_CARD:  by debit or credit card',
						enum: [
							'APPLE_PAY',
							'BANK_ACCOUNT',
							'BANK_TRANSFER',
							'FUNDS',
							'GOOGLE_PAY',
							'PAYMENT_CARD',
						],
						type: 'string',
					},
					platform: {
						description: 'What platform the user wants to buy from',
						enum: ['EXCHANGE', 'WALLET'],
						type: 'string',
					},
				},
				required: ['device', 'payment_type', 'platform'],
				type: 'object',
			},
			traits: {
				type: 'object',
			},
		},
		required: ['properties'],
		title: 'Buy Payment Method Selected',
		type: 'object',
	}
	const message = {
		event: 'Buy Payment Method Selected',
		properties: props || {},
		options,
	}
	validateAgainstSchema(message, schema)

	const a = analytics()
	if (a) {
		a.track(
			'Buy Payment Method Selected',
			props || {},
			withTypewriterContext(options),
			callback
		)
	}
}
/**
 * Buy order submitted by the user is rejected. it is not being created at all
 *
 * @param {BuyRejected} props - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function buyRejected(
	props: BuyRejected,
	options?: Segment.Options,
	callback?: Segment.Callback
): void {
	const schema = {
		$schema: 'http://json-schema.org/draft-07/schema#',
		description:
			'Buy order submitted by the user is rejected. it is not being created at all',
		labels: {
			flow: ['simplebuy_v1', 'buy_rec'],
			source: 'backend',
		},
		properties: {
			context: {},
			properties: {
				properties: {
					device: {
						description: 'Device the payment was made from',
						enum: ['APP-Android', 'APP-iOS', 'WEB'],
						type: 'string',
					},
					error_reason: {
						description:
							'Error message related to the rejection. This is more detailed than the rejection_reason ',
						type: 'string',
					},
					fee_amount: {
						description: 'Fee (in "currency") being charged for the payment.',
						type: 'number',
					},
					fee_amount_usd: {
						description: 'Amount in USD payed by the user.',
						type: 'number',
					},
					input_amount: {
						description:
							'The expected amount for the input currency, usually as a float. For BTC, it should be for example 1.23, meaning 1.23 BTC. The exact amount might not be known.',
						type: 'number',
					},
					input_amount_usd: {
						description:
							'The amount paid by the user in USD, usually as a float. it should be for example 10.23, meaning 10.23 USD',
						type: 'number',
					},
					input_currency: {
						description:
							'Currency symbol for the currency being paid by the user in exchange for some crypto. For example USD\n',
						pattern: '^[A-Z]{3,5}$',
						type: 'string',
					},
					is_recurring_buy: {
						description:
							'Whether the buy order was created automatically by a recurring buy order. It is when no "recurringBuyId" is found in input_attributes',
						type: 'boolean',
					},
					output_amount: {
						description:
							'The amount for the output currency, usually as a float. For BTC, it should be for example 1.23, meaning 1.23 BTC. The exact amount might not be known.\n',
						type: 'number',
					},
					output_currency: {
						description:
							'Currency symbol for the currency being received by the user. For example BTC\n',
						pattern: '^[A-Z]{3,5}$',
						type: 'string',
					},
					payment_id: {
						description:
							'id of the payment (id of the transaction from nabu payments)',
						type: 'string',
					},
					payment_method: {
						description:
							'The payment method used for the buy order. (the paymentType in simple_transactions input_attributes)',
						enum: ['BANK_ACCOUNT', 'BANK_TRANSFER', 'FUNDS', 'PAYMENT_CARD'],
						type: 'string',
					},
					platform: {
						description:
							'What platform the event was started from. (WALLET if product=SIMPLEBUY and EXCHANGE if product=MERCURY\n',
						enum: ['EXCHANGE', 'WALLET'],
						type: 'string',
					},
					product: {
						description:
							'The Product for which the buy order is (the product columns of the simple_transactions table)',
						enum: ['MERCURY', 'SIMPLEBUY'],
						type: 'string',
					},
					quote_id: {
						description: 'The id used for the new pricing fee model (WALLET)',
						type: 'string',
					},
					recurring_buy_id: {
						description:
							'If the buy order was generated from a recurring buy, what is that recurringBuyId. Null otherwise',
						type: ['string', 'null'],
					},
					rejection_details: {
						description:
							'More details about the rejection, if more context would be useful to know',
						type: 'string',
					},
					rejection_reason: {
						description:
							'The main reason why creating the buy order was rejected.',
						enum: [
							'ARITHMETIC',
							'BAD_QUOTE_SPREAD',
							'FEATURE_DISABLED',
							'INSUFFICIENT_FUNDS',
							'INTERNAL_SERVER_ERROR',
							'INVALID_PAYMENT_METHOD',
							'MISSING_RATE',
							'USER_LIMITS_EXCEEDED',
						],
						type: 'string',
					},
				},
				required: [
					'product',
					'output_currency',
					'input_currency',
					'platform',
					'rejection_reason',
					'payment_method',
				],
				type: 'object',
			},
			traits: {
				type: 'object',
			},
		},
		required: ['properties'],
		title: 'Buy Rejected',
		type: 'object',
	}
	const message = {
		event: 'Buy Rejected',
		properties: props || {},
		options,
	}
	validateAgainstSchema(message, schema)

	const a = analytics()
	if (a) {
		a.track(
			'Buy Rejected',
			props || {},
			withTypewriterContext(options),
			callback
		)
	}
}
/**
 * Buy or Sell button which brings the user to the Buy Sell product (wallet) or SimpleTrade flow (exchange) is clicked.
 *
 * @param {BuySellClicked} props - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function buySellClicked(
	props: BuySellClicked,
	options?: Segment.Options,
	callback?: Segment.Callback
): void {
	const schema = {
		$schema: 'http://json-schema.org/draft-07/schema#',
		description:
			'Buy or Sell button which brings the user to the Buy Sell product (wallet) or SimpleTrade flow (exchange) is clicked.',
		labels: {
			flow: ['simplebuy_v1', 'sell_v1', 'simple_trade_e1'],
			source: 'client',
		},
		properties: {
			context: {},
			properties: {
				properties: {
					device: {
						description: 'Device type from where the event was triggered.',
						enum: ['APP-iOS', 'WEB', 'APP-Android'],
						type: 'string',
					},
					origin: {
						description:
							'What button we are referring to. \nBUY_WIDGET: buy widget from Explorer. \nCURRENCY_PAGE : cta or menu on the coin page next to balance. \nDASHBOARD_PROMO : announcement card or promo on dashboard. \nDCA_EXPLAINER : from the DCA (Dollar Cost Averaging)) Info Viewed.\nDEEP_LINK : any deep link other than BUY_WIDGET\nNAVIGATION : navigation bar.\nPENDING_ORDER : user looks up details about pending order.\nPRICE_CHART (web only). \nSAVINGS (web only) : comes from interest savings product. \nSAVINGS_CONFIRMATION : from the confirmation screen of an interest savings deposit.\nSEND: comes from Send product. \nSELL (web only) : from sell product. \nSIMPLETRADE: from simple trade general product page \nTRANSACTION_DETAILS : from historical transaction details. \nTRANSACTION_LIST : from the historical transaction list\nWELCOME : from the onboarding flow. ',
						enum: [
							'BUY_WIDGET',
							'CURRENCY_PAGE',
							'DASHBOARD_PROMO',
							'DCA_EXPLAINER',
							'DEEP_LINK',
							'EMPTY_FEED',
							'LINK_BANK',
							'NAVIGATION',
							'PENDING_ORDER',
							'PRICE_CHART',
							'SAVINGS',
							'SAVINGS_CONFIRMATION',
							'SELL',
							'SEND',
							'SETTINGS',
							'SIMPLETRADE',
							'TRANSACTION_DETAILS',
							'TRANSACTION_LIST',
							'WELCOME',
						],
						type: 'string',
					},
					platform: {
						description: 'What platform the user is clicking from',
						enum: ['EXCHANGE', 'WALLET'],
						type: 'string',
					},
					type: {
						description:
							'Whether this is a BUY or SELL click. Sometimes it is the same button (e.g. Buy/Sell in navigation bar), in that case leave empty. Otherwise add whether it is Buy or Sell.',
						enum: ['BUY', 'SELL'],
						type: 'string',
					},
				},
				required: ['device', 'origin', 'platform'],
				type: 'object',
			},
			traits: {
				type: 'object',
			},
		},
		required: ['properties'],
		title: 'Buy Sell Clicked',
		type: 'object',
	}
	const message = {
		event: 'Buy Sell Clicked',
		properties: props || {},
		options,
	}
	validateAgainstSchema(message, schema)

	const a = analytics()
	if (a) {
		a.track(
			'Buy Sell Clicked',
			props || {},
			withTypewriterContext(options),
			callback
		)
	}
}
/**
 * Buy or Sell page or screen is viewed. This is the Buy Sell SimpleBuy (wallet) or SimpleTrade (exchange) product flow
 *
 * @param {BuySellViewed} props - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function buySellViewed(
	props: BuySellViewed,
	options?: Segment.Options,
	callback?: Segment.Callback
): void {
	const schema = {
		$schema: 'http://json-schema.org/draft-07/schema#',
		description:
			'Buy or Sell page or screen is viewed. This is the Buy Sell SimpleBuy (wallet) or SimpleTrade (exchange) product flow',
		labels: {
			flow: ['simplebuy_v1', 'simple_trade_e1'],
			source: 'client',
		},
		properties: {
			context: {},
			properties: {
				properties: {
					'': {
						description: '',
						type: 'object',
					},
					device: {
						description: 'Device type from where the event was triggered.\n',
						enum: ['APP-iOS', 'WEB', 'APP-Android'],
						type: 'string',
					},
					path: {
						description:
							'Path portion of the URL of the page. Equivalent to canonical path which defaults to location.pathname from the DOM API.',
						type: 'string',
					},
					platform: {
						description: 'What platform the page viewed belongs to',
						enum: ['EXCHANGE', 'WALLET'],
						type: 'string',
					},
					referrer: {
						description:
							'Full URL of the previous page. Equivalent to document.referrer from the DOM API.',
						type: 'string',
					},
					search: {
						description:
							'Query string portion of the URL of the page. Equivalent to location.search from the DOM API.',
						type: 'string',
					},
					title: {
						description:
							'Title of the page. Equivalent to document.title from the DOM API.',
						type: 'string',
					},
					type: {
						description:
							'Whether this is a BUY or SELL screen or page viewed. Sometimes it is the same button (e.g. Buy/Sell in navigation bar), in that case leave empty. Otherwise add whether it is Buy or Sell.',
						enum: ['BUY', 'SELL'],
						type: 'string',
					},
					url: {
						description:
							'Full URL of the page. First we look for the canonical url. If the canonical url is not provided, we use location.href from the DOM API.',
						type: 'string',
					},
				},
				required: ['platform', 'device'],
				type: 'object',
			},
			traits: {
				type: 'object',
			},
		},
		required: ['properties'],
		title: 'Buy Sell Viewed',
		type: 'object',
	}
	const message = {
		event: 'Buy Sell Viewed',
		properties: props || {},
		options,
	}
	validateAgainstSchema(message, schema)

	const a = analytics()
	if (a) {
		a.track(
			'Buy Sell Viewed',
			props || {},
			withTypewriterContext(options),
			callback
		)
	}
}
/**
 * The user enters and submits the amount he wants to buy on the Buy Widget from the Explorer or Blockchain.com
 *
 * @param {BuyWidgetAmountEntered} props - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function buyWidgetAmountEntered(
	props: BuyWidgetAmountEntered,
	options?: Segment.Options,
	callback?: Segment.Callback
): void {
	const schema = {
		$schema: 'http://json-schema.org/draft-07/schema#',
		description:
			'The user enters and submits the amount he wants to buy on the Buy Widget from the Explorer or Blockchain.com',
		labels: {
			flow: ['explorer', 'dot_com'],
			source: 'client',
		},
		properties: {
			context: {},
			properties: {
				properties: {
					device: {
						description: 'What device the event is tracked from',
						enum: ['WEB'],
						type: 'string',
					},
					input_amount: {
						description: '\n',
						type: 'number',
					},
					input_currency: {
						description:
							'Currency symbol for the currency being paid in exchange for some crypto. For example USD',
						pattern: '^[A-Z]{3,5}$',
						type: 'string',
					},
					output_currency: {
						description:
							'Currency symbol for the currency being received. For example BTC',
						pattern: '^[A-Z]{3,5}$',
						type: 'string',
					},
					platform: {
						description: 'What platform the event is referring to',
						enum: ['BLOCKCHAIN_COM', 'EXPLORER'],
						type: 'string',
					},
				},
				required: [
					'input_currency',
					'input_amount',
					'output_currency',
					'device',
					'platform',
				],
				type: 'object',
			},
			traits: {
				type: 'object',
			},
		},
		required: ['properties'],
		title: 'Buy Widget Amount Entered',
		type: 'object',
	}
	const message = {
		event: 'Buy Widget Amount Entered',
		properties: props || {},
		options,
	}
	validateAgainstSchema(message, schema)

	const a = analytics()
	if (a) {
		a.track(
			'Buy Widget Amount Entered',
			props || {},
			withTypewriterContext(options),
			callback
		)
	}
}
/**
 * The user clicks on a button or cta which opens the buy widget modal.
 *
 * @param {BuyWidgetClicked} props - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function buyWidgetClicked(
	props: BuyWidgetClicked,
	options?: Segment.Options,
	callback?: Segment.Callback
): void {
	const schema = {
		$schema: 'http://json-schema.org/draft-07/schema#',
		description:
			'The user clicks on a button or cta which opens the buy widget modal.',
		labels: {
			flow: ['explorer', 'dot_com'],
			source: 'client',
		},
		properties: {
			context: {},
			properties: {
				properties: {
					currency: {
						description:
							'If available, what is the currency the user wants to buy ? For example in the Explorer crypto prices page, did he click on a specific currency ?',
						pattern: '^[A-Z]{3,5}$',
						type: 'string',
					},
					device: {
						description: 'What device the event is tracked from',
						enum: ['WEB'],
						type: 'string',
					},
					origin: {
						description:
							'From which page was the widget clicked? HOME : Buy Crypto from landing page or explorer home page. CRYPTO_PRICES : from the explorer general price page with all the coins listed. CRYPTO_PRICE_DETAILS : from the explorer price page about a specific crypto',
						enum: [
							'CRYPTO_PRICES',
							'CRYPTO_PRICE_DETAILS',
							'HOME',
							'NAVIGATION',
							'WIDGET',
						],
						type: 'string',
					},
					platform: {
						description: 'What platform the event is referring to',
						enum: ['BLOCKCHAIN_COM', 'EXPLORER'],
						type: 'string',
					},
				},
				required: ['device', 'platform', 'origin'],
				type: 'object',
			},
			traits: {
				type: 'object',
			},
		},
		required: ['properties'],
		title: 'Buy Widget Clicked',
		type: 'object',
	}
	const message = {
		event: 'Buy Widget Clicked',
		properties: props || {},
		options,
	}
	validateAgainstSchema(message, schema)

	const a = analytics()
	if (a) {
		a.track(
			'Buy Widget Clicked',
			props || {},
			withTypewriterContext(options),
			callback
		)
	}
}
/**
 * The device checks whether the camera access is authorised by the user.
 *
 * @param {CameraPermissionChecked} props - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function cameraPermissionChecked(
	props: CameraPermissionChecked,
	options?: Segment.Options,
	callback?: Segment.Callback
): void {
	const schema = {
		$schema: 'http://json-schema.org/draft-07/schema#',
		description:
			'The device checks whether the camera access is authorised by the user.',
		labels: {
			flow: 'wconnect',
			source: 'client',
		},
		properties: {
			context: {},
			properties: {
				properties: {
					device: {
						description:
							'Device the user was requested to access the camera from',
						enum: ['APP-iOS'],
						type: 'string',
					},
					is_authorised: {
						description: 'whether the camera access is authorised',
						type: 'boolean',
					},
					origin: {
						description:
							'Whether the permission was checked during KYC verification or when scanning a QR_CODE',
						enum: ['KYC', 'QR_CODE'],
						type: 'string',
					},
					platform: {
						description:
							'Platform the user is using wallet connect from. Currently it will be only available from the WALLET',
						enum: ['WALLET'],
						type: 'string',
					},
				},
				required: ['device', 'platform', 'is_authorised', 'origin'],
				type: 'object',
			},
			traits: {
				type: 'object',
			},
		},
		required: ['properties'],
		title: 'Camera Permission Checked',
		type: 'object',
	}
	const message = {
		event: 'Camera Permission Checked',
		properties: props || {},
		options,
	}
	validateAgainstSchema(message, schema)

	const a = analytics()
	if (a) {
		a.track(
			'Camera Permission Checked',
			props || {},
			withTypewriterContext(options),
			callback
		)
	}
}
/**
 * The user answers the request to provide access to the camera or not
 *
 * @param {CameraPermissionRequestActioned} props - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function cameraPermissionRequestActioned(
	props: CameraPermissionRequestActioned,
	options?: Segment.Options,
	callback?: Segment.Callback
): void {
	const schema = {
		$schema: 'http://json-schema.org/draft-07/schema#',
		description:
			'The user answers the request to provide access to the camera or not',
		labels: {
			flow: 'wconnect',
			source: 'client',
		},
		properties: {
			context: {},
			properties: {
				properties: {
					action: {
						description:
							'What action the user took on the request. ALLOW : the user allows the device to access the camera. REJECT : the user does not allow the device to access the camera',
						enum: ['ALLOW', 'REJECT'],
						type: 'string',
					},
					device: {
						description: 'Device the user answered the request from',
						enum: ['APP-iOS'],
						type: 'string',
					},
					platform: {
						description:
							'Platform the user is using wallet connect from. Currently it will be only available from the WALLET',
						enum: ['WALLET'],
						type: 'string',
					},
				},
				required: ['device', 'platform', 'action'],
				type: 'object',
			},
			traits: {
				type: 'object',
			},
		},
		required: ['properties'],
		title: 'Camera Permission Request Actioned',
		type: 'object',
	}
	const message = {
		event: 'Camera Permission Request Actioned',
		properties: props || {},
		options,
	}
	validateAgainstSchema(message, schema)

	const a = analytics()
	if (a) {
		a.track(
			'Camera Permission Request Actioned',
			props || {},
			withTypewriterContext(options),
			callback
		)
	}
}
/**
 * The user shows intent to cancel the recurring buy order. it will  require further confirmation later
 *
 * @param {CancelRecurringBuyClicked} props - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function cancelRecurringBuyClicked(
	props: CancelRecurringBuyClicked,
	options?: Segment.Options,
	callback?: Segment.Callback
): void {
	const schema = {
		$schema: 'http://json-schema.org/draft-07/schema#',
		description:
			'The user shows intent to cancel the recurring buy order. it will  require further confirmation later',
		labels: {
			flow: 'buy_rec',
			source: 'client',
		},
		properties: {
			context: {},
			properties: {
				properties: {
					device: {
						description: 'Device type from where the event was triggered.',
						enum: ['APP-iOS', 'WEB', 'APP-Android'],
						type: 'string',
					},
					frequency: {
						description:
							'What is the frequency of the recurring buy. Also called period in the backend.',
						enum: ['BI_WEEKLY', 'DAILY', 'MONTHLY', 'WEEKLY'],
						type: 'string',
					},
					input_amount: {
						description: 'The amount for the input currency',
						type: 'number',
					},
					input_currency: {
						description:
							'Currency symbol for the currency being paid in exchange for some crypto. For example USD',
						pattern: '^[A-Z]{3,5}$',
						type: 'string',
					},
					origin: {
						description:
							'What button we are referring to : RECURRING_BUY_DETAILS : When looking at the details of an active recurring buy. TRANSACTION_DETAILS : When looking at the details of the buy transaction that came from a recurring buy',
						enum: ['RECURRING_BUY_DETAILS', 'TRANSACTION_DETAILS'],
						type: 'string',
					},
					output_currency: {
						description:
							'Currency symbol for the currency being received. For example BTC',
						pattern: '^[A-Z]{3,5}$',
						type: 'string',
					},
					payment_method: {
						description: 'The payment method used for the recurring buy order',
						enum: ['BANK_TRANSFER', 'FUNDS', 'PAYMENT_CARD'],
						type: 'string',
					},
					platform: {
						description:
							'What platform the user wants to set up recurring buy from',
						enum: ['WALLET'],
						type: 'string',
					},
				},
				required: [
					'origin',
					'frequency',
					'input_amount',
					'output_currency',
					'input_currency',
					'device',
					'payment_method',
					'platform',
				],
				type: 'object',
			},
			traits: {
				type: 'object',
			},
		},
		required: ['properties'],
		title: 'Cancel Recurring Buy Clicked',
		type: 'object',
	}
	const message = {
		event: 'Cancel Recurring Buy Clicked',
		properties: props || {},
		options,
	}
	validateAgainstSchema(message, schema)

	const a = analytics()
	if (a) {
		a.track(
			'Cancel Recurring Buy Clicked',
			props || {},
			withTypewriterContext(options),
			callback
		)
	}
}
/**
 * A user's card is activated. (when adding an account state ACTIVE with extra_attributes ->> 'type'  = 'PAYMENT_CARD')
 *
 * @param {CardStateTriggered} props - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function cardStateTriggered(
	props: CardStateTriggered,
	options?: Segment.Options,
	callback?: Segment.Callback
): void {
	const schema = {
		$schema: 'http://json-schema.org/draft-07/schema#',
		description:
			"A user's card is activated. (when adding an account state ACTIVE with extra_attributes ->> 'type'  = 'PAYMENT_CARD') ",
		labels: {
			flow: ['simplebuy_v1', 'settings_v1'],
			source: 'backend',
		},
		properties: {
			context: {},
			properties: {
				properties: {
					country_billing: {
						description:
							"The country used in the billing address. extra_attributes -> 'billing_address' ->> 'country'",
						pattern: '^[A-Z]{2}$',
						type: 'string',
					},
					currency: {
						description: 'Currency of the card',
						pattern: '^[A-Z]{3,5}$',
						type: 'string',
					},
					device: {
						description: 'Device type from where the event was triggered.',
						enum: ['APP-iOS', 'WEB', 'APP-Android'],
						type: 'string',
					},
					institution_name: {
						description: '',
						type: 'string',
					},
					issuer: {
						description:
							"What entity or bank issued the card, such as Barclays, Revolut etc. (extra_attributes -> 'card' ->> 'issuer' from account).",
						type: 'string',
					},
					partner: {
						description:
							'The card partner. From the partner column. Should be all upper case like in the table.',
						type: 'string',
					},
					state: {
						description: 'The updated state of the card',
						enum: ['ACTIVE', 'BLOCKED', 'CREATED', 'FRAUD_REVIEW', 'PENDING'],
						type: 'string',
					},
					type: {
						description:
							"Type of card. from extra_attributes -> 'card' ->> 'type' from account, transformed to upper_case. visa -> VISA. master_card -> MASTER_CARD",
						enum: ['MASTER_CARD', 'VISA'],
						type: 'string',
					},
				},
				required: ['currency', 'partner', 'state', 'type', 'country_billing'],
				type: 'object',
			},
			traits: {
				type: 'object',
			},
		},
		required: ['properties'],
		title: 'Card State Triggered',
		type: 'object',
	}
	const message = {
		event: 'Card State Triggered',
		properties: props || {},
		options,
	}
	validateAgainstSchema(message, schema)

	const a = analytics()
	if (a) {
		a.track(
			'Card State Triggered',
			props || {},
			withTypewriterContext(options),
			callback
		)
	}
}
/**
 * The user clicks on button which shows the widget to input the NEW number. On mobile this event is also activated when entering a number for the first time.
 *
 * @param {ChangeMobileNumberClicked} props - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function changeMobileNumberClicked(
	props: ChangeMobileNumberClicked,
	options?: Segment.Options,
	callback?: Segment.Callback
): void {
	const schema = {
		$schema: 'http://json-schema.org/draft-07/schema#',
		description:
			'The user clicks on button which shows the widget to input the NEW number. On mobile this event is also activated when entering a number for the first time.',
		labels: {
			flow: 'settings_v1',
			source: 'client',
		},
		properties: {
			context: {},
			properties: {
				properties: {
					device: {
						description: 'Device type from where the event was triggered.\n',
						enum: ['APP-iOS', 'WEB', 'APP-Android'],
						type: 'string',
					},
					platform: {
						description: 'From what platform the user is using the Settings',
						enum: ['EXCHANGE', 'WALLET'],
						type: 'string',
					},
				},
				required: ['platform', 'device'],
				type: 'object',
			},
			traits: {
				type: 'object',
			},
		},
		required: ['properties'],
		title: 'Change Mobile Number Clicked',
		type: 'object',
	}
	const message = {
		event: 'Change Mobile Number Clicked',
		properties: props || {},
		options,
	}
	validateAgainstSchema(message, schema)

	const a = analytics()
	if (a) {
		a.track(
			'Change Mobile Number Clicked',
			props || {},
			withTypewriterContext(options),
			callback
		)
	}
}
/**
 * User opens numpad interface to enter new Pin Code.
 *
 * @param {ChangePinClicked} props - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function changePinClicked(
	props: ChangePinClicked,
	options?: Segment.Options,
	callback?: Segment.Callback
): void {
	const schema = {
		$schema: 'http://json-schema.org/draft-07/schema#',
		description: 'User opens numpad interface to enter new Pin Code.',
		labels: {
			flow: 'security_v1',
			source: 'client',
		},
		properties: {
			context: {},
			properties: {
				properties: {
					device: {
						description: 'Device type from where the event was triggered.',
						enum: ['APP-iOS', 'WEB', 'APP-Android'],
						type: 'string',
					},
					platform: {
						description:
							'From what platform the user is managing Security events',
						enum: ['WALLET'],
						type: 'string',
					},
				},
				required: ['platform', 'device'],
				type: 'object',
			},
			traits: {
				type: 'object',
			},
		},
		required: ['properties'],
		title: 'Change Pin Clicked',
		type: 'object',
	}
	const message = {
		event: 'Change Pin Clicked',
		properties: props || {},
		options,
	}
	validateAgainstSchema(message, schema)

	const a = analytics()
	if (a) {
		a.track(
			'Change Pin Clicked',
			props || {},
			withTypewriterContext(options),
			callback
		)
	}
}
/**
 * The user has scanned the QR code to recover the account from the cloud backup. The feature is available on web only. It is triggered on web when the client doing the recovery receives the confirmation, and on the mobile app when the app client scans the code.
 *
 * @param {CloudBackupCodeScanned} props - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function cloudBackupCodeScanned(
	props: CloudBackupCodeScanned,
	options?: Segment.Options,
	callback?: Segment.Callback
): void {
	const schema = {
		$schema: 'http://json-schema.org/draft-07/schema#',
		description:
			'The user has scanned the QR code to recover the account from the cloud backup. The feature is available on web only. It is triggered on web when the client doing the recovery receives the confirmation, and on the mobile app when the app client scans the code.',
		labels: {
			flow: 'recovery_v1',
			source: 'client',
		},
		properties: {
			context: {},
			properties: {
				properties: {
					device: {
						description: 'Device type from where the event was triggered.',
						enum: ['APP-iOS', 'WEB', 'APP-Android'],
						type: 'string',
					},
					exchange: {
						description: 'Parameters about the exchange account',
						properties: {
							two_fa_mode: {
								description: 'Whether the exchange account has 2FA set up',
								type: 'boolean',
							},
							user_id: {
								description: 'Exchange user credentials ID',
								type: 'string',
							},
						},
						required: [],
						type: 'object',
					},
					mergeable: {
						description: 'Indicates if possible to merge two unlinked accounts',
						type: 'boolean',
					},
					platform: {
						description:
							'What platform the user is is recovering the account from',
						enum: ['WALLET', 'EXCHANGE'],
						type: 'string',
					},
					site_redirect: {
						description:
							'Whether the user is being redirected to the exchange or wallet',
						enum: ['EXCHANGE', 'WALLET'],
						type: 'string',
					},
					upgradeable: {
						description:
							'Indicates if possible to upgrade to a new unified Blockchain.com Account',
						type: 'boolean',
					},
					wallet: {
						description: 'Parameters about the wallet account',
						properties: {
							auth_type: {
								description: 'The wallet 2FA type that is enforced.',
								enum: [
									'0_NONE',
									'1_YUBIKEY',
									'2_EMAIL',
									'3_YUBIKEY_MTGOX',
									'4_GOOGLE_AUTHENTICATOR',
									'5_SMS',
								],
								type: 'string',
							},
							exchange: {
								description: 'Parameters about the exchange account',
								properties: {
									two_fa_mode: {
										description: 'Whether the exchange account has 2FA set up',
										properties: {},
										required: [],
										type: 'object',
									},
									user_id: {
										description: 'Exchange user credentials ID',
										type: 'object',
									},
								},
								required: [],
								type: 'object',
							},
							guid_first_four: {
								description:
									'The first four characters of the wallet.guid field',
								pattern: '^.{4,4}$',
								type: 'string',
							},
							has_cloud_backup: {
								description: 'Whether the wallet has cloud backups',
								type: 'boolean',
							},
							is_mobile_setup: {
								description: 'Whether the wallet has a mobile client set up',
								type: 'boolean',
							},
							last_mnemonic_backup: {
								description:
									'The last time, in unix timestamp, in which a wallet has their mnemonic backup verified',
								type: 'integer',
							},
							mobile_device_type: {
								description: 'The type of device being verified',
								enum: ['APP-Android', 'APP-iOS'],
								type: 'string',
							},
							nabu: {
								description: 'Parameter about the nabu account',
								properties: {
									recovery_eligible: {
										description:
											'Whether the nabu user is eligible for recovery. Usually if account has value (> $300 or 1 payment method linked)',
										type: 'boolean',
									},
									user_id: {
										description:
											'The Nabu User ID. This is from the users table in nabu gateway',
										type: 'object',
									},
								},
								required: [],
								type: 'object',
							},
						},
						required: [],
						type: 'object',
					},
				},
				required: ['device', 'site_redirect', 'platform'],
				type: 'object',
			},
			traits: {
				type: 'object',
			},
		},
		required: ['properties'],
		title: 'Cloud Backup Code Scanned',
		type: 'object',
	}
	const message = {
		event: 'Cloud Backup Code Scanned',
		properties: props || {},
		options,
	}
	validateAgainstSchema(message, schema)

	const a = analytics()
	if (a) {
		a.track(
			'Cloud Backup Code Scanned',
			props || {},
			withTypewriterContext(options),
			callback
		)
	}
}
/**
 * A user has submitted a search on the price page for a token or asset.
 *
 * @param {CoinSearchSubmitted} props - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function coinSearchSubmitted(
	props: CoinSearchSubmitted,
	options?: Segment.Options,
	callback?: Segment.Callback
): void {
	const schema = {
		$schema: 'http://json-schema.org/draft-07/schema#',
		description:
			'A user has submitted a search on the price page for a token or asset.',
		labels: {
			flow: ['explorer', 'dot_com'],
			source: 'client',
		},
		properties: {
			context: {},
			properties: {
				properties: {
					currency: {
						description:
							'Currency symbol for the currency being selected to trade by the user.',
						pattern: '^[A-Z]{3,5}$',
						type: 'string',
					},
					device: {
						description: 'What device the event is tracked from',
						enum: ['WEB'],
						type: 'string',
					},
					platform: {
						description:
							'What platform the user is searching from. For now, on BLOCKCHAIN_COM, the search is on the navigation bar, while on the explorer the search is just below next to the breadcrumb',
						enum: ['EXPLORER'],
						type: 'string',
					},
				},
				required: ['platform', 'device'],
				type: 'object',
			},
			traits: {
				type: 'object',
			},
		},
		required: ['properties'],
		title: 'Coin Search Submitted',
		type: 'object',
	}
	const message = {
		event: 'Coin Search Submitted',
		properties: props || {},
		options,
	}
	validateAgainstSchema(message, schema)

	const a = analytics()
	if (a) {
		a.track(
			'Coin Search Submitted',
			props || {},
			withTypewriterContext(options),
			callback
		)
	}
}
/**
 * The user clicks on some actions that the user can take after clicking on an app
 *
 * @param {ConnectedDappActioned} props - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function connectedDappActioned(
	props: ConnectedDappActioned,
	options?: Segment.Options,
	callback?: Segment.Callback
): void {
	const schema = {
		$schema: 'http://json-schema.org/draft-07/schema#',
		description:
			'The user clicks on some actions that the user can take after clicking on an app',
		labels: {
			flow: 'wconnect',
			source: 'client',
		},
		properties: {
			context: {},
			properties: {
				properties: {
					action: {
						description: 'What action the user is doing. LAUNCH or DISCONNECT',
						enum: ['DISCONNECT', 'LAUNCH'],
						type: 'string',
					},
					app_name: {
						description:
							'What is the name of the application being actioned on. Prefer "Proper Case" name rather than snake_case or camelCase',
						type: 'string',
					},
					device: {
						description: 'Device the user user is using wallet connect from',
						enum: ['APP-Android', 'APP-iOS', 'WEB'],
						type: 'string',
					},
					origin: {
						description:
							'What button we are referring to. APPS_LIST : the list of already connected apps',
						enum: ['APPS_LIST'],
						type: 'string',
					},
					platform: {
						description:
							'Platform the user is using wallet connect from. Currently it will be only available from the WALLET',
						enum: ['WALLET'],
						type: 'string',
					},
				},
				required: ['app_name', 'action', 'device', 'platform', 'origin'],
				type: 'object',
			},
			traits: {
				type: 'object',
			},
		},
		required: ['properties'],
		title: 'Connected Dapp Actioned',
		type: 'object',
	}
	const message = {
		event: 'Connected Dapp Actioned',
		properties: props || {},
		options,
	}
	validateAgainstSchema(message, schema)

	const a = analytics()
	if (a) {
		a.track(
			'Connected Dapp Actioned',
			props || {},
			withTypewriterContext(options),
			callback
		)
	}
}
/**
 * A button to view a connected app is clicked.
 *
 * @param {ConnectedDappClicked} props - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function connectedDappClicked(
	props: ConnectedDappClicked,
	options?: Segment.Options,
	callback?: Segment.Callback
): void {
	const schema = {
		$schema: 'http://json-schema.org/draft-07/schema#',
		description: 'A button to view a connected app is clicked.',
		labels: {
			flow: 'wconnect',
			source: 'client',
		},
		properties: {
			context: {},
			properties: {
				properties: {
					app_name: {
						description:
							'What is the name of the application being clicked on. Prefer "Proper Case" name rather than snake_case or camelCase',
						type: 'string',
					},
					device: {
						description: 'Device the user user is using wallet connect from',
						enum: ['APP-Android', 'APP-iOS', 'WEB'],
						type: 'string',
					},
					origin: {
						description:
							'What button we are referring to. APPS_LIST : the list of already connected apps',
						enum: ['APPS_LIST'],
						type: 'string',
					},
					platform: {
						description:
							'Platform the user is using wallet connect from. Currently it will be only available from the WALLET',
						enum: ['WALLET'],
						type: 'string',
					},
				},
				required: ['device', 'platform', 'origin', 'app_name'],
				type: 'object',
			},
			traits: {
				type: 'object',
			},
		},
		required: ['properties'],
		title: 'Connected Dapp Clicked',
		type: 'object',
	}
	const message = {
		event: 'Connected Dapp Clicked',
		properties: props || {},
		options,
	}
	validateAgainstSchema(message, schema)

	const a = analytics()
	if (a) {
		a.track(
			'Connected Dapp Clicked',
			props || {},
			withTypewriterContext(options),
			callback
		)
	}
}
/**
 * The list of connected Apps is clicked
 *
 * @param {ConnectedDappsListClicked} props - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function connectedDappsListClicked(
	props: ConnectedDappsListClicked,
	options?: Segment.Options,
	callback?: Segment.Callback
): void {
	const schema = {
		$schema: 'http://json-schema.org/draft-07/schema#',
		description: 'The list of connected Apps is clicked',
		labels: {
			flow: 'wconnect',
			source: 'client',
		},
		properties: {
			context: {},
			properties: {
				properties: {
					device: {
						description:
							'The device the user clicked on the button to view the list of Apps from',
						enum: ['APP-iOS'],
						type: 'string',
					},
					origin: {
						description:
							'What button we are referring to. QR_CODE : when a link pops up after scanning a QR code. SETTINGS : from the settings',
						enum: ['QR_CODE', 'SETTINGS'],
						type: 'string',
					},
					platform: {
						description:
							'Platform the user is using wallet connect from. Currently it will be only available from the WALLET',
						enum: ['WALLET'],
						type: 'string',
					},
				},
				required: ['device', 'platform', 'origin'],
				type: 'object',
			},
			traits: {
				type: 'object',
			},
		},
		required: ['properties'],
		title: 'Connected Dapps List Clicked',
		type: 'object',
	}
	const message = {
		event: 'Connected Dapps List Clicked',
		properties: props || {},
		options,
	}
	validateAgainstSchema(message, schema)

	const a = analytics()
	if (a) {
		a.track(
			'Connected Dapps List Clicked',
			props || {},
			withTypewriterContext(options),
			callback
		)
	}
}
/**
 * The list of connected Apps is viewed
 *
 * @param {ConnectedDappsListViewed} props - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function connectedDappsListViewed(
	props: ConnectedDappsListViewed,
	options?: Segment.Options,
	callback?: Segment.Callback
): void {
	const schema = {
		$schema: 'http://json-schema.org/draft-07/schema#',
		description: 'The list of connected Apps is viewed',
		labels: {
			flow: 'wconnect',
			source: 'client',
		},
		properties: {
			context: {},
			properties: {
				properties: {
					device: {
						description: 'The device the user viewed the list of Apps from',
						enum: ['APP-iOS'],
						type: 'string',
					},
					platform: {
						description:
							'Platform the user is using wallet connect from. Currently it will be only available from the WALLET',
						enum: ['WALLET'],
						type: 'string',
					},
				},
				required: ['device', 'platform'],
				type: 'object',
			},
			traits: {
				type: 'object',
			},
		},
		required: ['properties'],
		title: 'Connected Dapps List Viewed',
		type: 'object',
	}
	const message = {
		event: 'Connected Dapps List Viewed',
		properties: props || {},
		options,
	}
	validateAgainstSchema(message, schema)

	const a = analytics()
	if (a) {
		a.track(
			'Connected Dapps List Viewed',
			props || {},
			withTypewriterContext(options),
			callback
		)
	}
}
/**
 * Allows user to handle crypto payment links in the web browser.
 *
 * @param {CryptoLinkHandlingClicked} props - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function cryptoLinkHandlingClicked(
	props: CryptoLinkHandlingClicked,
	options?: Segment.Options,
	callback?: Segment.Callback
): void {
	const schema = {
		$schema: 'http://json-schema.org/draft-07/schema#',
		description:
			'Allows user to handle crypto payment links in the web browser.',
		labels: {
			flow: 'settings_v1',
			source: 'client',
		},
		properties: {
			context: {},
			properties: {
				properties: {
					device: {
						description: 'Device type from where the event was triggered.',
						enum: ['APP-iOS', 'WEB', 'APP-Android'],
						type: 'string',
					},
					platform: {
						description: 'From what platform the user is using the Settings',
						enum: ['EXCHANGE', 'WALLET'],
						type: 'string',
					},
				},
				required: ['platform', 'device'],
				type: 'object',
			},
			traits: {
				type: 'object',
			},
		},
		required: ['properties'],
		title: 'Crypto Link Handling Clicked',
		type: 'object',
	}
	const message = {
		event: 'Crypto Link Handling Clicked',
		properties: props || {},
		options,
	}
	validateAgainstSchema(message, schema)

	const a = analytics()
	if (a) {
		a.track(
			'Crypto Link Handling Clicked',
			props || {},
			withTypewriterContext(options),
			callback
		)
	}
}
/**
 * Enables user Wallet to handle crypto payment links in the web browser.
 *
 * @param {CryptoLinkHandlingEnabled} props - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function cryptoLinkHandlingEnabled(
	props: CryptoLinkHandlingEnabled,
	options?: Segment.Options,
	callback?: Segment.Callback
): void {
	const schema = {
		$schema: 'http://json-schema.org/draft-07/schema#',
		description:
			'Enables user Wallet to handle crypto payment links in the web browser.',
		labels: {
			flow: 'settings_v1',
			source: 'backend',
		},
		properties: {
			context: {},
			properties: {
				properties: {
					device: {
						description: 'Device type from where the event was triggered.',
						enum: ['APP-iOS', 'WEB', 'APP-Android'],
						type: 'string',
					},
					platform: {
						description: 'From what platform the user is using the Settings',
						enum: ['EXCHANGE', 'WALLET'],
						type: 'string',
					},
				},
				required: ['platform'],
				type: 'object',
			},
			traits: {
				type: 'object',
			},
		},
		required: ['properties'],
		title: 'Crypto Link Handling Enabled',
		type: 'object',
	}
	const message = {
		event: 'Crypto Link Handling Enabled',
		properties: props || {},
		options,
	}
	validateAgainstSchema(message, schema)

	const a = analytics()
	if (a) {
		a.track(
			'Crypto Link Handling Enabled',
			props || {},
			withTypewriterContext(options),
			callback
		)
	}
}
/**
 * A custodial transfer is completed. (when adding an entry to custodial_transfers from nabu gateway). This is done when moving funds between custodial accounts.
 *
 * @param {CustodialTransferCompleted} props - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function custodialTransferCompleted(
	props: CustodialTransferCompleted,
	options?: Segment.Options,
	callback?: Segment.Callback
): void {
	const schema = {
		$schema: 'http://json-schema.org/draft-07/schema#',
		description:
			'A custodial transfer is completed. (when adding an entry to custodial_transfers from nabu gateway). This is done when moving funds between custodial accounts.',
		labels: {
			flow: 'interest_v1',
			source: 'backend',
		},
		properties: {
			context: {},
			properties: {
				properties: {
					amount: {
						description:
							'Amount being transferred, in the given currency. e.g. for 1.23 BTC, the amount is 1.23',
						type: 'number',
					},
					amount_usd: {
						description:
							'Amount (in USD) being transferred. e.g. for 10.23, for $10.23',
						type: 'number',
					},
					currency: {
						description: 'What currency is being transferred',
						pattern: '^[A-Z]{3,5}$',
						type: 'string',
					},
					destination: {
						description:
							'To what account type the funds are coming from. This is usually named as a product SAVINGS or SIMPLEBUY',
						enum: ['SAVINGS', 'SIMPLEBUY'],
						type: 'string',
					},
					device: {
						description: 'Device type from where the event was triggered.',
						enum: ['APP-iOS', 'WEB', 'APP-Android'],
						type: 'string',
					},
					origin: {
						description:
							'From what account type the funds are coming from. This is usually named as the product like SAVINGS or SIMPLEBUY',
						enum: ['SAVINGS', 'SIMPLEBUY'],
						type: 'string',
					},
					platform: {
						description:
							'What platform the event was started from. WALLET is the only option\n',
						enum: ['WALLET'],
						type: 'string',
					},
					transfer_id: {
						description: 'id of the custodial transfer',
						type: 'string',
					},
				},
				required: [
					'platform',
					'currency',
					'amount',
					'origin',
					'destination',
					'transfer_id',
				],
				type: 'object',
			},
			traits: {
				type: 'object',
			},
		},
		required: ['properties'],
		title: 'Custodial Transfer Completed',
		type: 'object',
	}
	const message = {
		event: 'Custodial Transfer Completed',
		properties: props || {},
		options,
	}
	validateAgainstSchema(message, schema)

	const a = analytics()
	if (a) {
		a.track(
			'Custodial Transfer Completed',
			props || {},
			withTypewriterContext(options),
			callback
		)
	}
}
/**
 * The user takes some actions in the dapp connection promp.
 *
 * @param {DappConnectionActioned} props - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function dappConnectionActioned(
	props: DappConnectionActioned,
	options?: Segment.Options,
	callback?: Segment.Callback
): void {
	const schema = {
		$schema: 'http://json-schema.org/draft-07/schema#',
		description: 'The user takes some actions in the dapp connection promp.',
		labels: {
			flow: 'wconnect',
			source: 'client',
		},
		properties: {
			context: {},
			properties: {
				properties: {
					action: {
						description:
							'What action the user is doing. CONFIRM : when confirming the connection to the app. CANCEL : when cancelling the connection request',
						enum: ['CANCEL', 'CONFIRM'],
						type: 'string',
					},
					app_name: {
						description:
							'What is the name of the application being actioned on. Prefer "Proper Case" name rather than snake_case or camelCase',
						type: 'string',
					},
					device: {
						description: 'Device the user user is using wallet connect from',
						enum: ['APP-Android', 'APP-iOS', 'WEB'],
						type: 'string',
					},
					platform: {
						description:
							'Platform the user is using wallet connect from. Currently it will be only available from the WALLET',
						enum: ['WALLET'],
						type: 'string',
					},
				},
				required: ['platform', 'app_name', 'action', 'device'],
				type: 'object',
			},
			traits: {
				type: 'object',
			},
		},
		required: ['properties'],
		title: 'Dapp Connection Actioned',
		type: 'object',
	}
	const message = {
		event: 'Dapp Connection Actioned',
		properties: props || {},
		options,
	}
	validateAgainstSchema(message, schema)

	const a = analytics()
	if (a) {
		a.track(
			'Dapp Connection Actioned',
			props || {},
			withTypewriterContext(options),
			callback
		)
	}
}
/**
 * The app connection to a new app was confirmed. This means the app is now connected to the blockchain wallet
 *
 * @param {DappConnectionConfirmed} props - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function dappConnectionConfirmed(
	props: DappConnectionConfirmed,
	options?: Segment.Options,
	callback?: Segment.Callback
): void {
	const schema = {
		$schema: 'http://json-schema.org/draft-07/schema#',
		description:
			'The app connection to a new app was confirmed. This means the app is now connected to the blockchain wallet',
		labels: {
			flow: 'wconnect',
			source: 'client',
		},
		properties: {
			context: {},
			properties: {
				properties: {
					app_name: {
						description:
							'What is the name of the application being actioned on. Prefer "Proper Case" name rather than snake_case or camelCase',
						type: 'string',
					},
					device: {
						description: 'Device the user user is using wallet connect from',
						enum: ['APP-Android', 'APP-iOS', 'WEB'],
						type: 'string',
					},
					platform: {
						description:
							'Platform the user is using wallet connect from. Currently it will be only available from the WALLET',
						enum: ['WALLET'],
						type: 'string',
					},
				},
				required: ['device', 'platform', 'app_name'],
				type: 'object',
			},
			traits: {
				type: 'object',
			},
		},
		required: ['properties'],
		title: 'Dapp Connection Confirmed',
		type: 'object',
	}
	const message = {
		event: 'Dapp Connection Confirmed',
		properties: props || {},
		options,
	}
	validateAgainstSchema(message, schema)

	const a = analytics()
	if (a) {
		a.track(
			'Dapp Connection Confirmed',
			props || {},
			withTypewriterContext(options),
			callback
		)
	}
}
/**
 * The app connection to a new app was rejected
 *
 * @param {DappConnectionRejected} props - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function dappConnectionRejected(
	props: DappConnectionRejected,
	options?: Segment.Options,
	callback?: Segment.Callback
): void {
	const schema = {
		$schema: 'http://json-schema.org/draft-07/schema#',
		description: 'The app connection to a new app was rejected',
		labels: {
			flow: 'wconnect',
			source: 'client',
		},
		properties: {
			context: {},
			properties: {
				properties: {
					app_name: {
						description:
							'What is the name of the application being actioned on. Prefer "Proper Case" name rather than snake_case or camelCase',
						type: 'string',
					},
					device: {
						description: 'Device the user user is using wallet connect from',
						enum: ['APP-Android', 'APP-iOS', 'WEB'],
						type: 'string',
					},
					platform: {
						description:
							'Platform the user is using wallet connect from. Currently it will be only available from the WALLET',
						enum: ['WALLET'],
						type: 'string',
					},
				},
				required: ['device', 'platform', 'app_name'],
				type: 'object',
			},
			traits: {
				type: 'object',
			},
		},
		required: ['properties'],
		title: 'Dapp Connection Rejected',
		type: 'object',
	}
	const message = {
		event: 'Dapp Connection Rejected',
		properties: props || {},
		options,
	}
	validateAgainstSchema(message, schema)

	const a = analytics()
	if (a) {
		a.track(
			'Dapp Connection Rejected',
			props || {},
			withTypewriterContext(options),
			callback
		)
	}
}
/**
 * The user actions on a request from a connected dapp. it could be for example for signing a transaction
 *
 * @param {DappRequestActioned} props - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function dappRequestActioned(
	props: DappRequestActioned,
	options?: Segment.Options,
	callback?: Segment.Callback
): void {
	const schema = {
		$schema: 'http://json-schema.org/draft-07/schema#',
		description:
			'The user actions on a request from a connected dapp. it could be for example for signing a transaction',
		labels: {
			flow: 'wconnect',
			source: 'client',
		},
		properties: {
			context: {},
			properties: {
				properties: {
					action: {
						description: 'What action is taken by the user',
						enum: ['CANCEL', 'CONFIRM'],
						type: 'string',
					},
					app_name: {
						description:
							'What is the name of the application being actioned on. Prefer "Proper Case" name rather than snake_case or camelCase',
						type: 'string',
					},
					device: {
						description: 'Device the user user is using wallet connect from',
						enum: ['APP-Android', 'APP-iOS', 'WEB'],
						type: 'string',
					},
					method: {
						description: 'Type of dapp request ',
						enum: [
							'ETH_SEND_RAW_TRANSACTION',
							'ETH_SEND_TRANSACTION',
							'ETH_SIGN',
							'ETH_SIGN_TRANSACTION',
							'ETH_SIGN_TYPED_DATA',
							'PERSONAL_SIGN',
						],
						type: 'string',
					},
					platform: {
						description:
							'Platform the user is using wallet connect from. Currently it will be only available from the WALLET',
						enum: ['WALLET'],
						type: 'string',
					},
				},
				required: ['app_name', 'action', 'method', 'device', 'platform'],
				type: 'object',
			},
			traits: {
				type: 'object',
			},
		},
		required: ['properties'],
		title: 'Dapp Request Actioned',
		type: 'object',
	}
	const message = {
		event: 'Dapp Request Actioned',
		properties: props || {},
		options,
	}
	validateAgainstSchema(message, schema)

	const a = analytics()
	if (a) {
		a.track(
			'Dapp Request Actioned',
			props || {},
			withTypewriterContext(options),
			callback
		)
	}
}
/**
 * Button which brings the user to the general overview of the wallet or the Home page on the exchange mobile app. Logo will be recorded as separate event.
 *
 * @param {DashboardClicked} props - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function dashboardClicked(
	props: DashboardClicked,
	options?: Segment.Options,
	callback?: Segment.Callback
): void {
	const schema = {
		$schema: 'http://json-schema.org/draft-07/schema#',
		description:
			'Button which brings the user to the general overview of the wallet or the Home page on the exchange mobile app. Logo will be recorded as separate event.',
		labels: {
			flow: 'trade_e1',
			source: 'client',
		},
		properties: {
			context: {},
			properties: {
				properties: {
					device: {
						description:
							'Device type from where the event was triggered. (mobile only)',
						enum: ['APP-Android', 'APP-iOS', 'WEB'],
						type: 'string',
					},
					origin: {
						description:
							'Where does the user come from. \nNAVIGATION : Home on the navigation bar.  ',
						enum: ['NAVIGATION', 'SIGN_IN'],
						type: 'string',
					},
					platform: {
						description: 'What platform the user is clicking from',
						enum: ['EXCHANGE', 'WALLET'],
						type: 'string',
					},
				},
				required: ['device', 'origin', 'platform'],
				type: 'object',
			},
			traits: {
				type: 'object',
			},
		},
		required: ['properties'],
		title: 'Dashboard Clicked',
		type: 'object',
	}
	const message = {
		event: 'Dashboard Clicked',
		properties: props || {},
		options,
	}
	validateAgainstSchema(message, schema)

	const a = analytics()
	if (a) {
		a.track(
			'Dashboard Clicked',
			props || {},
			withTypewriterContext(options),
			callback
		)
	}
}
/**
 * Product Dashboard or Home is viewed. It is the general overview of the wallet or the Home page on the exchange mobile app
 *
 * @param {DashboardViewed} [props] - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function dashboardViewed(
	props?: DashboardViewed,
	options?: Segment.Options,
	callback?: Segment.Callback
): void {
	const schema = {
		$schema: 'http://json-schema.org/draft-07/schema#',
		description:
			'Product Dashboard or Home is viewed. It is the general overview of the wallet or the Home page on the exchange mobile app ',
		labels: {
			flow: 'trade_e1',
			source: 'client',
		},
		properties: {
			context: {},
			properties: {
				properties: {
					device: {
						description:
							'Device type from where the event was triggered. (mobile only)',
						enum: ['APP-Android', 'APP-iOS', 'WEB'],
						type: 'string',
					},
					path: {
						description:
							'Path portion of the URL of the page. Equivalent to canonical path which defaults to location.pathname from the DOM API.',
						type: 'string',
					},
					platform: {
						description: 'What platform the page viewed belongs to',
						enum: ['EXCHANGE', 'WALLET'],
						type: 'string',
					},
					referrer: {
						description:
							'Full URL of the previous page. Equivalent to document.referrer from the DOM API.',
						type: 'string',
					},
					search: {
						description:
							'Query string portion of the URL of the page. Equivalent to location.search from the DOM API.',
						type: 'string',
					},
					title: {
						description:
							'Title of the page. Equivalent to document.title from the DOM API.',
						type: 'string',
					},
					url: {
						description:
							'Full URL of the page. First we look for the canonical url. If the canonical url is not provided, we use location.href from the DOM API.',
						type: 'string',
					},
				},
				required: ['device', 'platform'],
				type: 'object',
			},
			traits: {
				type: 'object',
			},
		},
		title: 'Dashboard Viewed',
		type: 'object',
	}
	const message = {
		event: 'Dashboard Viewed',
		properties: props || {},
		options,
	}
	validateAgainstSchema(message, schema)

	const a = analytics()
	if (a) {
		a.track(
			'Dashboard Viewed',
			props || {},
			withTypewriterContext(options),
			callback
		)
	}
}
/**
 * When application is opened using a referring link, Segment or your packaged deep link partner can fire this event on our behalf
 *
 * @param {DeepLinkClicked} props - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function deepLinkClicked(
	props: DeepLinkClicked,
	options?: Segment.Options,
	callback?: Segment.Callback
): void {
	const schema = {
		$schema: 'http://json-schema.org/draft-07/schema#',
		description:
			'When application is opened using a referring link, Segment or your packaged deep link partner can fire this event on our behalf',
		labels: {
			source: 'client',
		},
		properties: {
			context: {},
			properties: {
				properties: {
					campaign: {
						description: '',
						properties: {
							medium: {
								description: 'Campaign Medium',
								type: 'string',
							},
							name: {
								description: 'Campaign Name',
								type: 'string',
							},
							source: {
								description: 'Campaign Source',
								type: 'string',
							},
						},
						required: [],
						type: 'object',
					},
					device: {
						description: 'Device type from where the event was triggered.',
						enum: ['APP-Android', 'APP-iOS'],
						type: 'string',
					},
					platfrom: {
						description: '',
						enum: ['EXCHANGE', 'WALLET'],
						type: 'string',
					},
					provider: {
						description: 'The deep link provider.',
						type: 'string',
					},
					url: {
						description: 'The deep link URL clicked.',
						type: 'string',
					},
				},
				required: ['device', 'platfrom'],
				type: 'object',
			},
			traits: {
				type: 'object',
			},
		},
		required: ['properties'],
		title: 'Deep Link Clicked',
		type: 'object',
	}
	const message = {
		event: 'Deep Link Clicked',
		properties: props || {},
		options,
	}
	validateAgainstSchema(message, schema)

	const a = analytics()
	if (a) {
		a.track(
			'Deep Link Clicked',
			props || {},
			withTypewriterContext(options),
			callback
		)
	}
}
/**
 * When application is opened using a referring link, Segment or your packaged deep link partner can fire this event on our behalf
 *
 * @param {DeepLinkOpened} props - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function deepLinkOpened(
	props: DeepLinkOpened,
	options?: Segment.Options,
	callback?: Segment.Callback
): void {
	const schema = {
		$schema: 'http://json-schema.org/draft-07/schema#',
		description:
			'When application is opened using a referring link, Segment or your packaged deep link partner can fire this event on our behalf',
		labels: {
			source: 'client',
		},
		properties: {
			context: {},
			properties: {
				properties: {
					campaign: {
						description: '',
						properties: {
							medium: {
								description: 'Campaign Medium',
								type: 'string',
							},
							name: {
								description: 'Campaign Name',
								type: 'string',
							},
							source: {
								description: 'Campaign source',
								type: 'string',
							},
						},
						required: [],
						type: 'object',
					},
					device: {
						description: 'Device type from where the event was triggered.',
						enum: ['APP-Android', 'APP-iOS'],
						type: 'string',
					},
					platform: {
						description:
							'Whether the deep link is opened from the Wallet of the Exchange',
						enum: ['EXCHANGE', 'WALLET'],
						type: 'string',
					},
					platfrom: {
						description: '',
						enum: ['EXCHANGE', 'WALLET'],
						type: 'string',
					},
					provider: {
						description: 'The deep link provider.',
						type: 'string',
					},
					url: {
						description: 'The App URL opened.',
						type: 'string',
					},
				},
				required: ['device', 'platform', 'platfrom'],
				type: 'object',
			},
			traits: {
				type: 'object',
			},
		},
		required: ['properties'],
		title: 'Deep Link Opened',
		type: 'object',
	}
	const message = {
		event: 'Deep Link Opened',
		properties: props || {},
		options,
	}
	validateAgainstSchema(message, schema)

	const a = analytics()
	if (a) {
		a.track(
			'Deep Link Opened',
			props || {},
			withTypewriterContext(options),
			callback
		)
	}
}
/**
 * Bitcoin address removed from the addresses list.
 *
 * @param {DeletedAddressLabel} props - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function deletedAddressLabel(
	props: DeletedAddressLabel,
	options?: Segment.Options,
	callback?: Segment.Callback
): void {
	const schema = {
		$schema: 'http://json-schema.org/draft-07/schema#',
		description: 'Bitcoin address removed from the addresses list.',
		labels: {
			flow: 'settings_v1',
			source: 'backend',
		},
		properties: {
			context: {},
			properties: {
				properties: {
					device: {
						description: 'Device type from where the event was triggered.',
						enum: ['APP-iOS', 'WEB', 'APP-Android'],
						type: 'string',
					},
					platform: {
						description: 'From what platform the user is using the Settings',
						enum: ['EXCHANGE', 'WALLET'],
						type: 'string',
					},
					transaction_format: {
						description: 'Segwit format or Legacy format',
						enum: ['LEGACY', 'SEGWIT'],
						type: 'string',
					},
				},
				required: ['transaction_format', 'platform'],
				type: 'object',
			},
			traits: {
				type: 'object',
			},
		},
		required: ['properties'],
		title: 'Deleted Address Label',
		type: 'object',
	}
	const message = {
		event: 'Deleted Address Label',
		properties: props || {},
		options,
	}
	validateAgainstSchema(message, schema)

	const a = analytics()
	if (a) {
		a.track(
			'Deleted Address Label',
			props || {},
			withTypewriterContext(options),
			callback
		)
	}
}
/**
 * The user selects and submits the amount to be deposited. The user will still have to validate or do action at a later stage. (confirm transfer or send funds from bank)
 *
 * @param {DepositAmountEntered} props - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function depositAmountEntered(
	props: DepositAmountEntered,
	options?: Segment.Options,
	callback?: Segment.Callback
): void {
	const schema = {
		$schema: 'http://json-schema.org/draft-07/schema#',
		description:
			'The user selects and submits the amount to be deposited. The user will still have to validate or do action at a later stage. (confirm transfer or send funds from bank)',
		labels: {
			flow: 'deposit_v1',
			source: 'client',
		},
		properties: {
			context: {},
			properties: {
				properties: {
					currency: {
						description: 'the currency the user wants to deposit',
						pattern: '^[A-Z]{3,5}$',
						type: 'string',
					},
					deposit_method: {
						description:
							'How the funds will be deposited : \nBANK_ACCOUNT: funds sent from a bank account, this is a classic transfer. \nBANK_TRANSFER : Funds sent from Linked account via Open Banking or ACH. ',
						enum: ['BANK_ACCOUNT', 'BANK_TRANSFER'],
						type: 'string',
					},
					device: {
						description: 'Device type from where the event was triggered.',
						enum: ['APP-iOS', 'WEB', 'APP-Android'],
						type: 'string',
					},
					input_amount: {
						description:
							'The amount the user will withdraw (before fee applies)',
						type: 'number',
					},
					output_amount: {
						description:
							'The amount the user will actual get (after fee applies)',
						type: 'number',
					},
					platform: {
						description: 'What platform the user is depositing funds to',
						enum: ['EXCHANGE', 'WALLET'],
						type: 'string',
					},
				},
				required: [
					'deposit_method',
					'device',
					'input_amount',
					'output_amount',
					'platform',
					'currency',
				],
				type: 'object',
			},
			traits: {
				type: 'object',
			},
		},
		required: ['properties'],
		title: 'Deposit Amount Entered',
		type: 'object',
	}
	const message = {
		event: 'Deposit Amount Entered',
		properties: props || {},
		options,
	}
	validateAgainstSchema(message, schema)

	const a = analytics()
	if (a) {
		a.track(
			'Deposit Amount Entered',
			props || {},
			withTypewriterContext(options),
			callback
		)
	}
}
/**
 * Button which brings the user to the Deposit flyover or screen is clicked.
 *
 * @param {DepositClicked} props - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function depositClicked(
	props: DepositClicked,
	options?: Segment.Options,
	callback?: Segment.Callback
): void {
	const schema = {
		$schema: 'http://json-schema.org/draft-07/schema#',
		description:
			'Button which brings the user to the Deposit flyover or screen is clicked.',
		labels: {
			flow: ['deposit_v1', 'trade_e1', 'buy_rec'],
			source: 'client',
		},
		properties: {
			context: {},
			properties: {
				properties: {
					device: {
						description: 'Device type from where the event was triggered.',
						enum: ['APP-iOS', 'WEB', 'APP-Android'],
						type: 'string',
					},
					origin: {
						description:
							'What button we are referring to. BALANCE : for the exchange, next to the balance (total account value) info on the main trading page. CURRENCY_PAGE : CTA or menu on the coin page next to balance. DEPOSIT: when trying to deposit some funds. LINK_WALLET. PORTFOLIO (exchange) : deposit next to currency balance. RECURRING_BUY : order details or status suggesting to add cash SIGN_UP : when prompted to deposit at sign up SIMPLETRADE : when trying to buy via the Simple Trade product without funds. WITHDRAW: when suggesting to deposit from no funds in withdraw screen. TRADE_TICKET (web only?) : for trade ticket when user has no funds ',
						enum: [
							'BALANCE',
							'CURRENCY_PAGE',
							'DEPOSIT',
							'LINK_WALLET',
							'PORTFOLIO',
							'RECURRING_BUY',
							'SIGN_UP',
							'SIMPLETRADE',
							'TRADE_TICKET',
							'WITHDRAW',
						],
						type: 'string',
					},
					platform: {
						description: 'What platform the user is clicking from',
						enum: ['EXCHANGE', 'WALLET'],
						type: 'string',
					},
				},
				required: ['platform', 'device', 'origin'],
				type: 'object',
			},
			traits: {
				type: 'object',
			},
		},
		required: ['properties'],
		title: 'Deposit Clicked',
		type: 'object',
	}
	const message = {
		event: 'Deposit Clicked',
		properties: props || {},
		options,
	}
	validateAgainstSchema(message, schema)

	const a = analytics()
	if (a) {
		a.track(
			'Deposit Clicked',
			props || {},
			withTypewriterContext(options),
			callback
		)
	}
}
/**
 * The user selects how the funds will be deposited, either linked bank or transfer
 *
 * @param {DepositMethodSelected} props - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function depositMethodSelected(
	props: DepositMethodSelected,
	options?: Segment.Options,
	callback?: Segment.Callback
): void {
	const schema = {
		$schema: 'http://json-schema.org/draft-07/schema#',
		description:
			'The user selects how the funds will be deposited, either linked bank or transfer',
		labels: {
			flow: ['deposit_v1', 'trade_e1'],
			source: 'client',
		},
		properties: {
			context: {},
			properties: {
				properties: {
					currency: {
						description: 'the currency the user wants to deposit',
						pattern: '^[A-Z]{3,5}$',
						type: 'string',
					},
					deposit_method: {
						description:
							'How the funds will be deposited : \nBANK_ACCOUNT: funds sent from a bank account, this is a classic transfer. \nBANK_TRANSFER : Funds sent from Linked account via Open Banking or ACH. ',
						enum: ['BANK_ACCOUNT', 'BANK_TRANSFER'],
						type: 'string',
					},
					device: {
						description: 'Device type from where the event was triggered.',
						enum: ['APP-iOS', 'WEB', 'APP-Android'],
						type: 'string',
					},
					platform: {
						description: 'What platform the user is depositing funds to',
						enum: ['EXCHANGE', 'WALLET'],
						type: 'string',
					},
				},
				required: ['deposit_method', 'platform', 'device', 'currency'],
				type: 'object',
			},
			traits: {
				type: 'object',
			},
		},
		required: ['properties'],
		title: 'Deposit Method Selected',
		type: 'object',
	}
	const message = {
		event: 'Deposit Method Selected',
		properties: props || {},
		options,
	}
	validateAgainstSchema(message, schema)

	const a = analytics()
	if (a) {
		a.track(
			'Deposit Method Selected',
			props || {},
			withTypewriterContext(options),
			callback
		)
	}
}
/**
 * Deposit flyover or screen viewed
 *
 * @param {DepositViewed} [props] - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function depositViewed(
	props?: DepositViewed,
	options?: Segment.Options,
	callback?: Segment.Callback
): void {
	const schema = {
		$schema: 'http://json-schema.org/draft-07/schema#',
		description: 'Deposit flyover or screen viewed',
		labels: {
			flow: ['deposit_v1', 'trade_e1'],
			source: 'client',
		},
		properties: {
			context: {},
			properties: {
				properties: {
					device: {
						description: 'Device type from where the event was triggered.',
						enum: ['APP-iOS', 'WEB', 'APP-Android'],
						type: 'string',
					},
					path: {
						description:
							'Path portion of the URL of the page. Equivalent to canonical path which defaults to location.pathname from the DOM API.',
						type: 'string',
					},
					platform: {
						description: 'What platform the page viewed belongs to',
						enum: ['EXCHANGE', 'WALLET'],
						type: 'string',
					},
					referrer: {
						description:
							'Full URL of the previous page. Equivalent to document.referrer from the DOM API.',
						type: 'string',
					},
					search: {
						description:
							'Query string portion of the URL of the page. Equivalent to location.search from the DOM API.',
						type: 'string',
					},
					title: {
						description:
							'Title of the page. Equivalent to document.title from the DOM API.',
						type: 'string',
					},
					url: {
						description:
							'Full URL of the page. First we look for the canonical url. If the canonical url is not provided, we use location.href from the DOM API.',
						type: 'string',
					},
				},
				required: ['device'],
				type: 'object',
			},
			traits: {
				type: 'object',
			},
		},
		title: 'Deposit Viewed',
		type: 'object',
	}
	const message = {
		event: 'Deposit Viewed',
		properties: props || {},
		options,
	}
	validateAgainstSchema(message, schema)

	const a = analytics()
	if (a) {
		a.track(
			'Deposit Viewed',
			props || {},
			withTypewriterContext(options),
			callback
		)
	}
}
/**
 * The user pressed the magic link in the email to verify a new device, and he got back to the sign in flow. We record here when the client receives the device verified confirmation.
 *
 * @param {DeviceVerified} props - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function deviceVerified(
	props: DeviceVerified,
	options?: Segment.Options,
	callback?: Segment.Callback
): void {
	const schema = {
		$schema: 'http://json-schema.org/draft-07/schema#',
		description:
			'The user pressed the magic link in the email to verify a new device, and he got back to the sign in flow. We record here when the client receives the device verified confirmation.',
		labels: {
			flow: 'sso_v1',
			source: 'client',
		},
		properties: {
			context: {},
			properties: {
				properties: {
					device: {
						description: '',
						enum: ['APP-Android', 'APP-iOS', 'WEB'],
						type: 'string',
					},
					exchange: {
						description: 'Parameters about the exchange account',
						properties: {
							two_fa_mode: {
								description: 'Whether the exchange account has 2FA set up',
								type: 'boolean',
							},
							user_id: {
								description: 'Exchange user credentials ID',
								type: 'string',
							},
						},
						required: [],
						type: 'object',
					},
					mergeable: {
						description: 'Indicates if possible to merge two unlinked accounts',
						type: 'boolean',
					},
					platform: {
						description:
							'the platform that received the notification about the device being verified',
						enum: ['WALLET'],
						type: 'string',
					},
					site_redirect: {
						description:
							'Whether the user is being redirected to the exchange or wallet',
						enum: ['EXCHANGE', 'WALLET'],
						type: 'string',
					},
					upgradeable: {
						description:
							'Indicates if possible to “upgrade” to a new unified Blockchain.com Account',
						type: 'boolean',
					},
					wallet: {
						description: 'Parameters about the wallet account',
						properties: {
							auth_type: {
								description: 'The wallet 2FA type that is enforced.',
								enum: [
									'0_NONE',
									'1_YUBIKEY',
									'2_EMAIL',
									'3_YUBIKEY_MTGOX',
									'4_GOOGLE_AUTHENTICATOR',
									'5_SMS',
								],
								type: 'string',
							},
							exchange: {
								description: 'Parameters about the exchange account',
								properties: {
									two_fa_mode: {
										description: 'Whether the exchange account has 2FA set up',
										properties: {},
										required: [],
										type: 'object',
									},
									user_id: {
										description: 'Exchange user credentials ID',
										type: 'object',
									},
								},
								required: [],
								type: 'object',
							},
							guid_first_four: {
								description:
									'The first four characters of the wallet.guid field',
								pattern: '^.{4,4}$',
								type: 'string',
							},
							has_cloud_backup: {
								description: 'Whether the wallet has cloud backups',
								type: 'boolean',
							},
							is_mobile_setup: {
								description: 'Whether the wallet has a mobile client set up',
								type: 'boolean',
							},
							last_mnemonic_backup: {
								description:
									'The last time, in unix timestamp, in which a wallet has their mnemonic backup verified',
								type: 'integer',
							},
							mobile_device_type: {
								description: 'The type of device being verified',
								enum: ['APP-Android', 'APP-iOS'],
								type: 'string',
							},
							nabu: {
								description: 'Parameter about the nabu account',
								properties: {
									recovery_eligible: {
										description:
											'Whether the nabu user is eligible for recovery. Usually if account has value (> $300 or 1 payment method linked)',
										type: 'boolean',
									},
									user_id: {
										description:
											'The Nabu User ID. This is from the users table in nabu gateway',
										type: 'object',
									},
								},
								required: [],
								type: 'object',
							},
						},
						required: [],
						type: 'object',
					},
				},
				required: ['platform', 'device'],
				type: 'object',
			},
			traits: {
				type: 'object',
			},
		},
		required: ['properties'],
		title: 'Device Verified',
		type: 'object',
	}
	const message = {
		event: 'Device Verified',
		properties: props || {},
		options,
	}
	validateAgainstSchema(message, schema)

	const a = analytics()
	if (a) {
		a.track(
			'Device Verified',
			props || {},
			withTypewriterContext(options),
			callback
		)
	}
}
/**
 * User clicks change email button.
 *
 * @param {EmailChangeClicked} props - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function emailChangeClicked(
	props: EmailChangeClicked,
	options?: Segment.Options,
	callback?: Segment.Callback
): void {
	const schema = {
		$schema: 'http://json-schema.org/draft-07/schema#',
		description: 'User clicks change email button.',
		labels: {
			flow: 'security_v1',
			source: 'client',
		},
		properties: {
			context: {},
			properties: {
				properties: {
					device: {
						description: 'Device type from where the event was triggered.',
						enum: ['APP-iOS', 'WEB', 'APP-Android'],
						type: 'string',
					},
					platform: {
						description:
							'From what platform the user is managing Security events',
						enum: ['EXCHANGE', 'WALLET'],
						type: 'string',
					},
				},
				required: ['platform', 'device'],
				type: 'object',
			},
			traits: {
				type: 'object',
			},
		},
		required: ['properties'],
		title: 'Email Change Clicked',
		type: 'object',
	}
	const message = {
		event: 'Email Change Clicked',
		properties: props || {},
		options,
	}
	validateAgainstSchema(message, schema)

	const a = analytics()
	if (a) {
		a.track(
			'Email Change Clicked',
			props || {},
			withTypewriterContext(options),
			callback
		)
	}
}
/**
 * The user requested the verification link to be sent again to change the wallet’s email address.
 *
 * @param {EmailChangeVerificationLinkResent} props - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function emailChangeVerificationLinkResent(
	props: EmailChangeVerificationLinkResent,
	options?: Segment.Options,
	callback?: Segment.Callback
): void {
	const schema = {
		$schema: 'http://json-schema.org/draft-07/schema#',
		description:
			'The user requested the verification link to be sent again to change the wallet’s email address.',
		labels: {
			flow: 'security_v1',
			source: 'backend',
		},
		properties: {
			context: {},
			properties: {
				properties: {
					device: {
						description: 'Device type from where the event was triggered.',
						enum: ['APP-iOS', 'WEB', 'APP-Android'],
						type: 'string',
					},
					platform: {
						description:
							'From what platform the user is managing Security events',
						enum: ['EXCHANGE', 'WALLET'],
						type: 'string',
					},
				},
				required: ['platform'],
				type: 'object',
			},
			traits: {
				type: 'object',
			},
		},
		required: ['properties'],
		title: 'Email Change Verification Link Resent',
		type: 'object',
	}
	const message = {
		event: 'Email Change Verification Link Resent',
		properties: props || {},
		options,
	}
	validateAgainstSchema(message, schema)

	const a = analytics()
	if (a) {
		a.track(
			'Email Change Verification Link Resent',
			props || {},
			withTypewriterContext(options),
			callback
		)
	}
}
/**
 * An email verification is requested. This is triggered (with or without explicit consent of the user). Note that some email verification emails are sent without request from the client.
 *
 * @param {EmailVerificationRequested} [props] - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function emailVerificationRequested(
	props?: EmailVerificationRequested,
	options?: Segment.Options,
	callback?: Segment.Callback
): void {
	const schema = {
		$schema: 'http://json-schema.org/draft-07/schema#',
		description:
			'An email verification is requested. This is triggered (with or without explicit consent of the user). Note that some email verification emails are sent without request from the client.',
		labels: {
			flow: ['onboarding_v1', 'security_v1', 'onboarding_e1'],
			source: 'client',
		},
		properties: {
			context: {},
			properties: {
				properties: {
					device: {
						description: 'Device type from where the event was triggered.',
						enum: ['APP-iOS', 'WEB', 'APP-Android'],
						type: 'string',
					},
					origin: {
						description:
							'From what product or flow the request to verify the email was requested. SIGN_UP : just after sign up. VERIFICATION: during a kyc verification process. SECURITY : in the security settings, for example when an email is changed.',
						enum: ['SECURITY', 'SIGN_UP', 'VERIFICATION'],
						type: 'string',
					},
					platform: {
						description:
							'What platform the email verification was requested from',
						enum: ['EXCHANGE', 'WALLET'],
						type: 'string',
					},
				},
				required: ['origin', 'platform', 'device'],
				type: 'object',
			},
			traits: {
				type: 'object',
			},
		},
		title: 'Email Verification Requested',
		type: 'object',
	}
	const message = {
		event: 'Email Verification Requested',
		properties: props || {},
		options,
	}
	validateAgainstSchema(message, schema)

	const a = analytics()
	if (a) {
		a.track(
			'Email Verification Requested',
			props || {},
			withTypewriterContext(options),
			callback
		)
	}
}
/**
 * An email verification was skipped by the user. This could also lead to an entire onboarding or verification flow being skipped.
 *
 * @param {EmailVerificationSkipped} props - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function emailVerificationSkipped(
	props: EmailVerificationSkipped,
	options?: Segment.Options,
	callback?: Segment.Callback
): void {
	const schema = {
		$schema: 'http://json-schema.org/draft-07/schema#',
		description:
			'An email verification was skipped by the user. This could also lead to an entire onboarding or verification flow being skipped.',
		labels: {
			flow: 'onboarding_v1',
			source: 'client',
		},
		properties: {
			context: {},
			properties: {
				properties: {
					device: {
						description: 'Device type from where the event was triggered.',
						enum: ['APP-iOS', 'WEB', 'APP-Android'],
						type: 'string',
					},
					origin: {
						description:
							'From what product or flow the request to verify the email was skipped. SIGN_UP : just after sign up.',
						enum: ['SIGN_UP'],
						type: 'string',
					},
					platform: {
						description:
							'What platform the email verification was requested from',
						enum: ['WALLET'],
						type: 'string',
					},
				},
				required: ['platform', 'device', 'origin'],
				type: 'object',
			},
			traits: {
				type: 'object',
			},
		},
		required: ['properties'],
		title: 'Email Verification Skipped',
		type: 'object',
	}
	const message = {
		event: 'Email Verification Skipped',
		properties: props || {},
		options,
	}
	validateAgainstSchema(message, schema)

	const a = analytics()
	if (a) {
		a.track(
			'Email Verification Skipped',
			props || {},
			withTypewriterContext(options),
			callback
		)
	}
}
/**
 * Email has been verified by the user
 *
 * @param {EmailVerified} [props] - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function emailVerified(
	props?: EmailVerified,
	options?: Segment.Options,
	callback?: Segment.Callback
): void {
	const schema = {
		$schema: 'http://json-schema.org/draft-07/schema#',
		description: 'Email has been verified by the user',
		labels: {
			flow: ['onboarding_v1', 'security_v1'],
			source: 'backend',
		},
		properties: {
			context: {},
			properties: {
				properties: {
					email_changed: {
						description: 'Was there already a verified email?',
						type: 'boolean',
					},
					platform: {
						description:
							'What platform the email verification was requested from (if available)',
						enum: ['EXCHANGE', 'WALLET'],
						type: 'string',
					},
				},
				required: ['email_changed', 'platform'],
				type: 'object',
			},
			traits: {
				type: 'object',
			},
		},
		title: 'Email Verified',
		type: 'object',
	}
	const message = {
		event: 'Email Verified',
		properties: props || {},
		options,
	}
	validateAgainstSchema(message, schema)

	const a = analytics()
	if (a) {
		a.track(
			'Email Verified',
			props || {},
			withTypewriterContext(options),
			callback
		)
	}
}
/**
 * A button inviting the user to discover our exchange product is clicked. Note that this does not include the navigation part of the header.
 *
 * @param {ExchangeHyperlinkClicked} props - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function exchangeHyperlinkClicked(
	props: ExchangeHyperlinkClicked,
	options?: Segment.Options,
	callback?: Segment.Callback
): void {
	const schema = {
		$schema: 'http://json-schema.org/draft-07/schema#',
		description:
			'A button inviting the user to discover our exchange product is clicked. Note that this does not include the navigation part of the header.',
		labels: {
			flow: ['explorer', 'dot_com'],
			source: 'client',
		},
		properties: {
			context: {},
			properties: {
				properties: {
					'': {
						description: '',
						type: 'object',
					},
					currency: {
						description:
							'Currency symbol for the currency being selected to trade by the user.',
						pattern: '^[A-Z]{3,5}$\n',
						type: 'string',
					},
					device: {
						description: 'What device the event is tracked from',
						enum: ['WEB'],
						type: 'string',
					},
					origin: {
						description: 'From which part of the page was the button clicked',
						enum: ['BANNER', 'BODY', 'LOWER_BANNER'],
						type: 'string',
					},
					platform: {
						description: 'What platform the event is referring to.',
						enum: ['BLOCKCHAIN_COM', 'EXPLORER'],
						type: 'string',
					},
					platform_path: {
						description:
							'Path portion of the URL of the page from where the button is clicked.\n  PRICES: from the explorer general price page with all the coins listed. \n PRICES_CURRENCY : blockchain.com/prices/[currency] : from the explorer price page about a specific crypto. .COM_EXCHANGE :\nblockchain.com/exchange. EXPLORER : https://www.blockchain.com/explorer',
						enum: ['.COM_EXCHANGE', 'EXPLORER', 'PRICES', 'PRICES_CURRENCY'],
						type: 'string',
					},
				},
				required: ['platform_path', 'device', 'platform', 'origin'],
				type: 'object',
			},
			traits: {
				type: 'object',
			},
		},
		required: ['properties'],
		title: 'Exchange Hyperlink Clicked',
		type: 'object',
	}
	const message = {
		event: 'Exchange Hyperlink Clicked',
		properties: props || {},
		options,
	}
	validateAgainstSchema(message, schema)

	const a = analytics()
	if (a) {
		a.track(
			'Exchange Hyperlink Clicked',
			props || {},
			withTypewriterContext(options),
			callback
		)
	}
}
/**
 * A user signs up for n Exchange account. Note that this is different from Signed Up which is triggered when a nabu user profile is created. An Exchange without a nabu user will be seen as an Anonymous User.
 *
 * @param {ExchangeSignedUp} props - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function exchangeSignedUp(
	props: ExchangeSignedUp,
	options?: Segment.Options,
	callback?: Segment.Callback
): void {
	const schema = {
		$schema: 'http://json-schema.org/draft-07/schema#',
		description:
			'A user signs up for n Exchange account. Note that this is different from Signed Up which is triggered when a nabu user profile is created. An Exchange without a nabu user will be seen as an Anonymous User.',
		labels: {
			flow: 'sign_up',
			source: 'client',
		},
		properties: {
			context: {},
			properties: {
				properties: {
					device: {
						description:
							'What device the user created an exchange account from',
						enum: ['APP-Android', 'APP-iOS', 'WEB'],
						type: 'string',
					},
					platform: {
						description:
							'What platform the user is creating his exchange account from.',
						enum: ['EXCHANGE'],
						type: 'string',
					},
				},
				required: ['platform', 'device'],
				type: 'object',
			},
			traits: {
				type: 'object',
			},
		},
		required: ['properties'],
		title: 'Exchange Signed Up',
		type: 'object',
	}
	const message = {
		event: 'Exchange Signed Up',
		properties: props || {},
		options,
	}
	validateAgainstSchema(message, schema)

	const a = analytics()
	if (a) {
		a.track(
			'Exchange Signed Up',
			props || {},
			withTypewriterContext(options),
			callback
		)
	}
}
/**
 * A user has clicked on the search bar to look for address, transaction, block or any explorer related information
 *
 * @param {ExplorerSearchClicked} props - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function explorerSearchClicked(
	props: ExplorerSearchClicked,
	options?: Segment.Options,
	callback?: Segment.Callback
): void {
	const schema = {
		$schema: 'http://json-schema.org/draft-07/schema#',
		description:
			'A user has clicked on the search bar to look for address, transaction, block or any explorer related information',
		labels: {
			flow: ['explorer', 'dot_com'],
			source: 'client',
		},
		properties: {
			context: {},
			properties: {
				properties: {
					device: {
						description: 'What device the event is tracked from',
						enum: ['WEB'],
						type: 'string',
					},
					platform: {
						description:
							'What platform the user is searching from. For now, on BLOCKCHAIN_COM, the search is on the navigation bar, while on the explorer the search is just below next to the breadcrumb',
						enum: ['BLOCKCHAIN_COM', 'EXPLORER'],
						type: 'string',
					},
				},
				required: ['platform', 'device'],
				type: 'object',
			},
			traits: {
				type: 'object',
			},
		},
		required: ['properties'],
		title: 'Explorer Search Clicked',
		type: 'object',
	}
	const message = {
		event: 'Explorer Search Clicked',
		properties: props || {},
		options,
	}
	validateAgainstSchema(message, schema)

	const a = analytics()
	if (a) {
		a.track(
			'Explorer Search Clicked',
			props || {},
			withTypewriterContext(options),
			callback
		)
	}
}
/**
 * A user has submitted a search on the search bar to look for address, transaction, block or any explorer related information.
 *
 * @param {ExplorerSearchSubmitted} props - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function explorerSearchSubmitted(
	props: ExplorerSearchSubmitted,
	options?: Segment.Options,
	callback?: Segment.Callback
): void {
	const schema = {
		$schema: 'http://json-schema.org/draft-07/schema#',
		description:
			'A user has submitted a search on the search bar to look for address, transaction, block or any explorer related information.',
		labels: {
			flow: ['explorer', 'dot_com'],
			source: 'client',
		},
		properties: {
			context: {},
			properties: {
				properties: {
					device: {
						description: 'What device the event is tracked from',
						enum: ['WEB'],
						type: 'string',
					},
					platform: {
						description:
							'What platform the user is searching from. For now, on BLOCKCHAIN_COM, the search is on the navigation bar, while on the explorer the search is just below next to the breadcrumb',
						enum: ['BLOCKCHAIN_COM', 'EXPLORER'],
						type: 'string',
					},
				},
				required: ['platform', 'device'],
				type: 'object',
			},
			traits: {
				type: 'object',
			},
		},
		required: ['properties'],
		title: 'Explorer Search Submitted',
		type: 'object',
	}
	const message = {
		event: 'Explorer Search Submitted',
		properties: props || {},
		options,
	}
	validateAgainstSchema(message, schema)

	const a = analytics()
	if (a) {
		a.track(
			'Explorer Search Submitted',
			props || {},
			withTypewriterContext(options),
			callback
		)
	}
}
/**
 * A user has submitted a search on the search bar which resulted in no results.
 *
 * @param {ExplorerSearchWithNoResults} props - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function explorerSearchWithNoResults(
	props: ExplorerSearchWithNoResults,
	options?: Segment.Options,
	callback?: Segment.Callback
): void {
	const schema = {
		$schema: 'http://json-schema.org/draft-07/schema#',
		description:
			'A user has submitted a search on the search bar which resulted in no results.',
		labels: {
			flow: ['explorer', 'dot_com'],
			source: 'client',
		},
		properties: {
			context: {},
			properties: {
				properties: {
					device: {
						description: 'What device the event is tracked from',
						enum: ['WEB'],
						type: 'string',
					},
					platform: {
						description:
							'What platform the user is searching from. For now, on BLOCKCHAIN_COM, the search is on the navigation bar, while on the explorer the search is just below next to the breadcrumb',
						enum: ['BLOCKCHAIN_COM', 'EXPLORER'],
						type: 'string',
					},
					search_query: {
						description: 'query with no results',
						type: 'string',
					},
				},
				required: ['platform', 'device', 'search_query'],
				type: 'object',
			},
			traits: {
				type: 'object',
			},
		},
		required: ['properties'],
		title: 'Explorer Search With No Results',
		type: 'object',
	}
	const message = {
		event: 'Explorer Search With No Results',
		properties: props || {},
		options,
	}
	validateAgainstSchema(message, schema)

	const a = analytics()
	if (a) {
		a.track(
			'Explorer Search With No Results',
			props || {},
			withTypewriterContext(options),
			callback
		)
	}
}
/**
 * user selects fiat currency for trade. https://www.figma.com/file/IXwonpgbc67ho6uvPX7O74/NUX---New-User-Experience?node-id=445%3A30141
 *
 * @param {FiatCurrencySelected} props - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function fiatCurrencySelected(
	props: FiatCurrencySelected,
	options?: Segment.Options,
	callback?: Segment.Callback
): void {
	const schema = {
		$schema: 'http://json-schema.org/draft-07/schema#',
		description:
			'user selects fiat currency for trade. https://www.figma.com/file/IXwonpgbc67ho6uvPX7O74/NUX---New-User-Experience?node-id=445%3A30141',
		labels: {
			flow: 'simplebuy_v1',
			source: 'client',
		},
		properties: {
			context: {},
			properties: {
				properties: {
					currency: {
						description: 'What fiat currency was selected',
						pattern: '^[A-Z]{3,5}$',
						type: 'string',
					},
					device: {
						description: 'Device type from where the event was triggered.',
						enum: ['APP-iOS', 'WEB', 'APP-Android'],
						type: 'string',
					},
					platform: {
						description: 'What platform the page viewed belongs to',
						enum: ['WALLET'],
						type: 'string',
					},
				},
				required: ['currency', 'platform', 'device'],
				type: 'object',
			},
			traits: {
				type: 'object',
			},
		},
		required: ['properties'],
		title: 'Fiat Currency Selected',
		type: 'object',
	}
	const message = {
		event: 'Fiat Currency Selected',
		properties: props || {},
		options,
	}
	validateAgainstSchema(message, schema)

	const a = analytics()
	if (a) {
		a.track(
			'Fiat Currency Selected',
			props || {},
			withTypewriterContext(options),
			callback
		)
	}
}
/**
 * An item of the footer is clicked
 *
 * @param {FooterOptionClicked} props - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function footerOptionClicked(
	props: FooterOptionClicked,
	options?: Segment.Options,
	callback?: Segment.Callback
): void {
	const schema = {
		$schema: 'http://json-schema.org/draft-07/schema#',
		description: 'An item of the footer is clicked',
		labels: {
			flow: ['explorer', 'dot_com'],
			source: 'client',
		},
		properties: {
			context: {},
			properties: {
				properties: {
					device: {
						description: 'What device the event is tracked from',
						enum: ['WEB'],
						type: 'string',
					},
					download_app: {
						description: 'hyperlink to the app store or google store',
						enum: ['ANDROID', 'IOS'],
						type: 'string',
					},
					item: {
						description: 'What option was clicked',
						enum: [
							'APIS',
							'BLOG',
							'CAREERS',
							'CHARTS',
							'COMPANY',
							'EXCHANGE',
							'EXCHANGE_SUPPORT',
							'EXPLORER',
							'INSTITUTIONAL',
							'LEARN',
							'OPEN_SOURCE',
							'PRESS_CENTER',
							'PRICES',
							'PRIME',
							'PRIVACY',
							'RESEARCH',
							'STATUS',
							'VENTURES',
							'WALLET',
							'WALLET_SUPPORT',
						],
						type: 'string',
					},
					platform: {
						description: 'What platform the event is referring to',
						enum: ['BLOCKCHAIN_COM', 'EXCHANGE', 'EXPLORER', 'WALLET'],
						type: 'string',
					},
					social_media: {
						description: 'Social media hyperlink clicked',
						enum: ['INSTAGRAM', 'MEDIUM', 'TWITTER'],
						type: 'string',
					},
				},
				required: ['platform', 'device'],
				type: 'object',
			},
			traits: {
				type: 'object',
			},
		},
		required: ['properties'],
		title: 'Footer Option Clicked',
		type: 'object',
	}
	const message = {
		event: 'Footer Option Clicked',
		properties: props || {},
		options,
	}
	validateAgainstSchema(message, schema)

	const a = analytics()
	if (a) {
		a.track(
			'Footer Option Clicked',
			props || {},
			withTypewriterContext(options),
			callback
		)
	}
}
/**
 * Button which brings the user to the activity history page or screen is clicked
 *
 * @param {HistoryClicked} props - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function historyClicked(
	props: HistoryClicked,
	options?: Segment.Options,
	callback?: Segment.Callback
): void {
	const schema = {
		$schema: 'http://json-schema.org/draft-07/schema#',
		description:
			'Button which brings the user to the activity history page or screen is clicked',
		labels: {
			flow: ['trade_e1', 'margin'],
			source: 'client',
		},
		properties: {
			context: {},
			properties: {
				properties: {
					device: {
						description: 'Device type from where the event was triggered.',
						enum: ['APP-iOS', 'WEB', 'APP-Android'],
						type: 'string',
					},
					origin: {
						description:
							'What button we are referring to. NAVIGATION : navigation bar',
						enum: ['NAVIGATION'],
						type: 'string',
					},
					platform: {
						description: 'What platform the page viewed belongs to',
						enum: ['EXCHANGE', 'WALLET'],
						type: 'string',
					},
					type: {
						description:
							'what type of history the button will bring the user to.',
						enum: [
							'DEPOSIT',
							'MARGIN_POSITION',
							'SIMPLETRADE',
							'TRADE',
							'WITHDRAW',
						],
						type: 'string',
					},
				},
				required: ['device', 'platform', 'origin'],
				type: 'object',
			},
			traits: {
				type: 'object',
			},
		},
		required: ['properties'],
		title: 'History Clicked',
		type: 'object',
	}
	const message = {
		event: 'History Clicked',
		properties: props || {},
		options,
	}
	validateAgainstSchema(message, schema)

	const a = analytics()
	if (a) {
		a.track(
			'History Clicked',
			props || {},
			withTypewriterContext(options),
			callback
		)
	}
}
/**
 * Activity history page or screen is viewed
 *
 * @param {HistoryViewed} props - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function historyViewed(
	props: HistoryViewed,
	options?: Segment.Options,
	callback?: Segment.Callback
): void {
	const schema = {
		$schema: 'http://json-schema.org/draft-07/schema#',
		description: 'Activity history page or screen is viewed',
		labels: {
			flow: ['trade_e1', 'margin'],
			source: 'client',
		},
		properties: {
			context: {},
			properties: {
				properties: {
					device: {
						description: 'Device type from where the event was triggered.',
						enum: ['APP-iOS', 'WEB', 'APP-Android'],
						type: 'string',
					},
					path: {
						description:
							'Path portion of the URL of the page. Equivalent to canonical path which defaults to location.pathname from the DOM API.',
						type: 'string',
					},
					platform: {
						description: 'What platform the page viewed belongs to',
						enum: ['EXCHANGE'],
						type: 'string',
					},
					referrer: {
						description:
							'Full URL of the previous page. Equivalent to document.referrer from the DOM API.',
						type: 'string',
					},
					search: {
						description:
							'Query string portion of the URL of the page. Equivalent to location.search from the DOM API.',
						type: 'string',
					},
					title: {
						description:
							'Title of the page. Equivalent to document.title from the DOM API.',
						type: 'string',
					},
					type: {
						description: 'What type of history is viewed',
						enum: [
							'DEPOSIT',
							'MARGIN_POSITION',
							'SIMPLETRADE',
							'TRADE',
							'WITHDRAW',
						],
						type: 'string',
					},
					url: {
						description:
							'Full URL of the page. First we look for the canonical url. If the canonical url is not provided, we use location.href from the DOM API.',
						type: 'string',
					},
				},
				required: ['device', 'platform'],
				type: 'object',
			},
			traits: {
				type: 'object',
			},
		},
		required: ['properties'],
		title: 'History Viewed',
		type: 'object',
	}
	const message = {
		event: 'History Viewed',
		properties: props || {},
		options,
	}
	validateAgainstSchema(message, schema)

	const a = analytics()
	if (a) {
		a.track(
			'History Viewed',
			props || {},
			withTypewriterContext(options),
			callback
		)
	}
}
/**
 * Track each time the user opens the widget to input the address data.
 *
 * @param {ImportAddressClicked} props - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function importAddressClicked(
	props: ImportAddressClicked,
	options?: Segment.Options,
	callback?: Segment.Callback
): void {
	const schema = {
		$schema: 'http://json-schema.org/draft-07/schema#',
		description:
			'Track each time the user opens the widget to input the address data.',
		labels: {
			flow: 'settings_v1',
			source: 'client',
		},
		properties: {
			context: {},
			properties: {
				properties: {
					device: {
						description: 'Device type from where the event was triggered.',
						enum: ['WEB'],
						type: 'string',
					},
					platform: {
						description: 'From what platform the user is using the Settings',
						enum: ['EXCHANGE', 'WALLET'],
						type: 'string',
					},
				},
				required: ['platform', 'device'],
				type: 'object',
			},
			traits: {
				type: 'object',
			},
		},
		required: ['properties'],
		title: 'Import Address Clicked',
		type: 'object',
	}
	const message = {
		event: 'Import Address Clicked',
		properties: props || {},
		options,
	}
	validateAgainstSchema(message, schema)

	const a = analytics()
	if (a) {
		a.track(
			'Import Address Clicked',
			props || {},
			withTypewriterContext(options),
			callback
		)
	}
}
/**
 * When the user gives up  to import or restore his wallet and create an account. This is after entering his wallet recovery phrase.
 *
 * @param {ImportWalletCancelled} props - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function importWalletCancelled(
	props: ImportWalletCancelled,
	options?: Segment.Options,
	callback?: Segment.Callback
): void {
	const schema = {
		$schema: 'http://json-schema.org/draft-07/schema#',
		description:
			'When the user gives up  to import or restore his wallet and create an account. This is after entering his wallet recovery phrase.',
		labels: {
			flow: 'recovery_v1',
			source: 'client',
		},
		properties: {
			context: {},
			properties: {
				properties: {
					device: {
						description: 'Device type from where the event was triggered.',
						enum: ['APP-iOS', 'WEB', 'APP-Android'],
						type: 'string',
					},
					origin: {
						description:
							'What button we are referring to. CONFIRMATION : "Go Back" In the final confirmation screen after entering a valid passphrase',
						enum: ['CONFIRMATIOM'],
						type: 'string',
					},
					platform: {
						description:
							'What platform the user is is recovering the account from',
						enum: ['WALLET', 'EXCHANGE'],
						type: 'string',
					},
					site_redirect: {
						description:
							'Whether the user is being redirected to the exchange or wallet',
						enum: ['EXCHANGE', 'WALLET'],
						type: 'string',
					},
				},
				required: ['site_redirect', 'platform', 'device', 'origin'],
				type: 'object',
			},
			traits: {
				type: 'object',
			},
		},
		required: ['properties'],
		title: 'Import Wallet Cancelled',
		type: 'object',
	}
	const message = {
		event: 'Import Wallet Cancelled',
		properties: props || {},
		options,
	}
	validateAgainstSchema(message, schema)

	const a = analytics()
	if (a) {
		a.track(
			'Import Wallet Cancelled',
			props || {},
			withTypewriterContext(options),
			callback
		)
	}
}
/**
 * When clicking on a button to go to the Restore Wallet flow (also Called Import Wallet) flow. At that stage, we have no information about the wallet or user.
 *
 * @param {ImportWalletClicked} props - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function importWalletClicked(
	props: ImportWalletClicked,
	options?: Segment.Options,
	callback?: Segment.Callback
): void {
	const schema = {
		$schema: 'http://json-schema.org/draft-07/schema#',
		description:
			'When clicking on a button to go to the Restore Wallet flow (also Called Import Wallet) flow. At that stage, we have no information about the wallet or user.',
		labels: {
			flow: 'recovery_v1',
			source: 'client',
		},
		properties: {
			context: {},
			properties: {
				properties: {
					device: {
						description: 'Device type from where the event was triggered.',
						enum: ['APP-iOS', 'WEB', 'APP-Android'],
						type: 'string',
					},
					origin: {
						description:
							'What button we are referring to. (mobile) LAUNCH_SCREEN. (web) To Be Determined !',
						enum: ['LAUNCH_SCREEN'],
						type: 'string',
					},
					platform: {
						description:
							'What platform the user is is recovering the account from',
						enum: ['WALLET', 'EXCHANGE'],
						type: 'string',
					},
					site_redirect: {
						description:
							'Whether the user is being redirected to the exchange or wallet',
						enum: ['EXCHANGE', 'WALLET'],
						type: 'string',
					},
				},
				required: ['site_redirect', 'platform', 'origin', 'device'],
				type: 'object',
			},
			traits: {
				type: 'object',
			},
		},
		required: ['properties'],
		title: 'Import Wallet Clicked',
		type: 'object',
	}
	const message = {
		event: 'Import Wallet Clicked',
		properties: props || {},
		options,
	}
	validateAgainstSchema(message, schema)

	const a = analytics()
	if (a) {
		a.track(
			'Import Wallet Clicked',
			props || {},
			withTypewriterContext(options),
			callback
		)
	}
}
/**
 * When confirming that the user wants to import or restore his wallet and create an account. This is after entering his wallet recovery phrase.
 *
 * @param {ImportWalletConfirmed} props - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function importWalletConfirmed(
	props: ImportWalletConfirmed,
	options?: Segment.Options,
	callback?: Segment.Callback
): void {
	const schema = {
		$schema: 'http://json-schema.org/draft-07/schema#',
		description:
			'When confirming that the user wants to import or restore his wallet and create an account. This is after entering his wallet recovery phrase.',
		labels: {
			flow: 'recovery_v1',
			source: 'client',
		},
		properties: {
			context: {},
			properties: {
				properties: {
					device: {
						description: 'Device type from where the event was triggered.',
						enum: ['APP-iOS', 'WEB', 'APP-Android'],
						type: 'string',
					},
					platform: {
						description:
							'What platform the user is is recovering the account from',
						enum: ['WALLET', 'EXCHANGE'],
						type: 'string',
					},
					site_redirect: {
						description:
							'Whether the user is being redirected to the exchange or wallet',
						enum: ['EXCHANGE', 'WALLET'],
						type: 'string',
					},
				},
				required: ['site_redirect', 'platform', 'device'],
				type: 'object',
			},
			traits: {
				type: 'object',
			},
		},
		required: ['properties'],
		title: 'Import Wallet Confirmed',
		type: 'object',
	}
	const message = {
		event: 'Import Wallet Confirmed',
		properties: props || {},
		options,
	}
	validateAgainstSchema(message, schema)

	const a = analytics()
	if (a) {
		a.track(
			'Import Wallet Confirmed',
			props || {},
			withTypewriterContext(options),
			callback
		)
	}
}
/**
 * the source of the install https://segment.com/docs/connections/spec/mobile/#install-attributed
 *
 * @param {InstallAttributed} props - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function installAttributed(
	props: InstallAttributed,
	options?: Segment.Options,
	callback?: Segment.Callback
): void {
	const schema = {
		$schema: 'http://json-schema.org/draft-07/schema#',
		description:
			'the source of the install https://segment.com/docs/connections/spec/mobile/#install-attributed',
		labels: {
			source: 'client',
		},
		properties: {
			context: {},
			properties: {
				properties: {
					campaign: {
						description: '',
						properties: {
							ad_creative: {
								description: 'The ad creative name.',
								type: 'string',
							},
							ad_group: {
								description: 'The ad group name.',
								type: 'string',
							},
							content: {
								description: 'The content of the campaign.',
								type: 'string',
							},
							medium: {
								description: 'Identifies what type of link was used.',
								type: 'string',
							},
							name: {
								description: 'The name of the attributed campaign.',
								type: 'string',
							},
							source: {
								description: 'Campaign source — attributed ad network',
								type: 'string',
							},
						},
						required: [],
						type: 'object',
					},
					device: {
						description: 'Device type from where the event was triggered.',
						enum: ['APP-iOS', 'APP-Android'],
						type: 'string',
					},
					platform: {
						description: '',
						enum: ['EXCHANGE', 'WALLET'],
						type: 'string',
					},
					provider: {
						description: 'The attribution provider.',
						type: 'string',
					},
				},
				required: ['device', 'platform'],
				type: 'object',
			},
			traits: {
				type: 'object',
			},
		},
		required: ['properties'],
		title: 'Install Attributed',
		type: 'object',
	}
	const message = {
		event: 'Install Attributed',
		properties: props || {},
		options,
	}
	validateAgainstSchema(message, schema)

	const a = analytics()
	if (a) {
		a.track(
			'Install Attributed',
			props || {},
			withTypewriterContext(options),
			callback
		)
	}
}
/**
 * Button which brings the user to the general Interest page or screen is clicked. General Interest page possibly only available on web.
 *
 * @param {InterestClicked} props - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function interestClicked(
	props: InterestClicked,
	options?: Segment.Options,
	callback?: Segment.Callback
): void {
	const schema = {
		$schema: 'http://json-schema.org/draft-07/schema#',
		description:
			'Button which brings the user to the general Interest page or screen is clicked. General Interest page possibly only available on web. ',
		labels: {
			flow: 'interest_v1',
			source: 'client',
		},
		properties: {
			context: {},
			properties: {
				properties: {
					device: {
						description: 'Device type from where the event was triggered.',
						enum: ['APP-iOS', 'WEB', 'APP-Android'],
						type: 'string',
					},
					origin: {
						description:
							'What button we are referring to. NAVIGATION : navigation bar. DASHBOARD_PROMO : announcement card or promo on dashboard. ',
						enum: ['DASHBOARD_PROMO', 'NAVIGATION'],
						type: 'string',
					},
					platform: {
						description: 'What platform the user is clicking from',
						enum: ['WALLET'],
						type: 'string',
					},
				},
				required: ['platform', 'device', 'origin'],
				type: 'object',
			},
			traits: {
				type: 'object',
			},
		},
		required: ['properties'],
		title: 'Interest Clicked',
		type: 'object',
	}
	const message = {
		event: 'Interest Clicked',
		properties: props || {},
		options,
	}
	validateAgainstSchema(message, schema)

	const a = analytics()
	if (a) {
		a.track(
			'Interest Clicked',
			props || {},
			withTypewriterContext(options),
			callback
		)
	}
}
/**
 * User enters and submits the amount for a deposit to their interest saving account. Unlike other amount screens, the client will send a transfer requests as soon as the amount is submitted.
 *
 * @param {InterestDepositAmountEntered} props - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function interestDepositAmountEntered(
	props: InterestDepositAmountEntered,
	options?: Segment.Options,
	callback?: Segment.Callback
): void {
	const schema = {
		$schema: 'http://json-schema.org/draft-07/schema#',
		description:
			'User enters and submits the amount for a deposit to their interest saving account. Unlike other amount screens, the client will send a transfer requests as soon as the amount is submitted.',
		labels: {
			flow: 'interest_v1',
			source: 'client',
		},
		properties: {
			context: {},
			properties: {
				properties: {
					amount: {
						description:
							'If available, what amount in native fiat currency being entered. e.g. 12.23 if 12.23 USD.',
						type: 'number',
					},
					amount_currency: {
						description:
							'If available,, what is the native fiat currency in which the amount is entered. e.g. USD. Empty if amount only entered in BTC terms',
						pattern: '^[A-Z]{3,5}$',
						type: 'string',
					},
					currency: {
						description:
							'The currency the user wants to deposit to their savings account. e.g. BTC',
						pattern: '^[A-Z]{3,5}$',
						type: 'string',
					},
					device: {
						description: 'Device type from where the event was triggered.',
						enum: ['APP-iOS', 'WEB', 'APP-Android'],
						type: 'string',
					},
					from_account_type: {
						description:
							'From what account the user wants to deposit funds from',
						enum: ['TRADING', 'USERKEY'],
						type: 'string',
					},
					input_amount: {
						description:
							'The amount in crypto currency the user sends to their interest savings account. This amount is before any fees are subtracted.',
						type: 'number',
					},
					interest_rate: {
						description:
							'What is in the interest rate in percentage being offered. For example, for 4.5%, enter 4.5',
						type: ['number', 'null'],
					},
					output_amount: {
						description:
							'The amount in crypto currency the user will actually get in their interest savings account. This amount is after any fees are subtracted',
						type: 'number',
					},
					platform: {
						description: 'What platform the user wants to deposit funds from',
						enum: ['WALLET'],
						type: 'string',
					},
				},
				required: [
					'interest_rate',
					'from_account_type',
					'currency',
					'input_amount',
					'platform',
				],
				type: 'object',
			},
			traits: {
				type: 'object',
			},
		},
		required: ['properties'],
		title: 'Interest Deposit Amount Entered',
		type: 'object',
	}
	const message = {
		event: 'Interest Deposit Amount Entered',
		properties: props || {},
		options,
	}
	validateAgainstSchema(message, schema)

	const a = analytics()
	if (a) {
		a.track(
			'Interest Deposit Amount Entered',
			props || {},
			withTypewriterContext(options),
			callback
		)
	}
}
/**
 * Button which brings the user to the interest deposit flyover or screen is clicked. It is sometimes called Transfer and is where the user can add funds to their interest savings wallet
 *
 * @param {InterestDepositClicked} props - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function interestDepositClicked(
	props: InterestDepositClicked,
	options?: Segment.Options,
	callback?: Segment.Callback
): void {
	const schema = {
		$schema: 'http://json-schema.org/draft-07/schema#',
		description:
			'Button which brings the user to the interest deposit flyover or screen is clicked. It is sometimes called Transfer and is where the user can add funds to their interest savings wallet',
		labels: {
			flow: 'interest_v1',
			source: 'client',
		},
		properties: {
			context: {},
			properties: {
				properties: {
					currency: {
						description:
							'What currency the user is about to deposit to their interest savings account (if known)',
						pattern: '^[A-Z]{3,5}$',
						type: 'string',
					},
					device: {
						description: 'Device type from where the event was triggered.',
						enum: ['APP-iOS', 'WEB', 'APP-Android'],
						type: 'string',
					},
					origin: {
						description:
							'What button we are referring to. CURRENCY_PAGE : CTA or menu on the coin page next to balance. SAVINGS_PAGE: general interest savings overview page or screen (currently Earn Interest Clicked).  SAVINGS_CONFIRMATION : from the confirmation screen of an interest deposit. SEND : from the send product\n',
						enum: [
							'CURRENCY_PAGE',
							'SAVINGS_CONFIRMATION',
							'SAVINGS_PAGE',
							'SEND',
						],
						type: 'string',
					},
					platform: {
						description: 'What platform the user is clicking from',
						enum: ['WALLET'],
						type: 'string',
					},
				},
				required: ['platform', 'origin', 'device'],
				type: 'object',
			},
			traits: {
				type: 'object',
			},
		},
		required: ['properties'],
		title: 'Interest Deposit Clicked',
		type: 'object',
	}
	const message = {
		event: 'Interest Deposit Clicked',
		properties: props || {},
		options,
	}
	validateAgainstSchema(message, schema)

	const a = analytics()
	if (a) {
		a.track(
			'Interest Deposit Clicked',
			props || {},
			withTypewriterContext(options),
			callback
		)
	}
}
/**
 * The user clicked on the widget or button which sets the max amount allowed to deposit to their interest savings account
 *
 * @param {InterestDepositMaxAmountClicked} props - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function interestDepositMaxAmountClicked(
	props: InterestDepositMaxAmountClicked,
	options?: Segment.Options,
	callback?: Segment.Callback
): void {
	const schema = {
		$schema: 'http://json-schema.org/draft-07/schema#',
		description:
			'The user clicked on the widget or button which sets the max amount allowed to deposit to their interest savings account',
		labels: {
			flow: 'interest_v1',
			source: 'client',
		},
		properties: {
			context: {},
			properties: {
				properties: {
					amount_currency: {
						description:
							'If the button explicitly displays the amount in a specific currency, what is the currency being clicked on for the max amount',
						pattern: '^[A-Z]{3,5}$',
						type: 'string',
					},
					currency: {
						description:
							'The currency the user wants to deposit to their savings account. e.g. BTC',
						pattern: '^[A-Z]{3,5}$',
						type: 'string',
					},
					device: {
						description: 'Device type from where the event was triggered.',
						enum: ['APP-iOS', 'WEB', 'APP-Android'],
						type: 'string',
					},
					from_account_type: {
						description:
							'From what account the user wants to deposit funds from',
						enum: ['TRADING', 'USERKEY'],
						type: 'string',
					},
					platform: {
						description: 'What platform the user wants to deposit funds from',
						enum: ['WALLET'],
						type: 'string',
					},
				},
				required: ['currency', 'platform', 'from_account_type'],
				type: 'object',
			},
			traits: {
				type: 'object',
			},
		},
		required: ['properties'],
		title: 'Interest Deposit Max Amount Clicked',
		type: 'object',
	}
	const message = {
		event: 'Interest Deposit Max Amount Clicked',
		properties: props || {},
		options,
	}
	validateAgainstSchema(message, schema)

	const a = analytics()
	if (a) {
		a.track(
			'Interest Deposit Max Amount Clicked',
			props || {},
			withTypewriterContext(options),
			callback
		)
	}
}
/**
 * The user clicked on the widget or button which sets the min amount allowed to deposit to their interest savings account
 *
 * @param {InterestDepositMinAmountClicked} props - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function interestDepositMinAmountClicked(
	props: InterestDepositMinAmountClicked,
	options?: Segment.Options,
	callback?: Segment.Callback
): void {
	const schema = {
		$schema: 'http://json-schema.org/draft-07/schema#',
		description:
			'The user clicked on the widget or button which sets the min amount allowed to deposit to their interest savings account',
		labels: {
			flow: 'interest_v1',
			source: 'client',
		},
		properties: {
			context: {},
			properties: {
				properties: {
					amount_currency: {
						description:
							'If the button explicitly displays the amount in a specific currency, what is the currency being clicked on for the min amount',
						pattern: '^[A-Z]{3,5}$',
						type: 'string',
					},
					currency: {
						description:
							'The currency the user wants to deposit to their savings account. e.g. BTC',
						pattern: '^[A-Z]{3,5}$',
						type: 'string',
					},
					device: {
						description: 'Device type from where the event was triggered.',
						enum: ['WEB', 'APP-Android'],
						type: 'string',
					},
					from_account_type: {
						description:
							'From what account the user wants to deposit funds from',
						enum: ['TRADING', 'USERKEY'],
						type: 'string',
					},
					platform: {
						description: 'What platform the user wants to deposit funds from',
						enum: ['WALLET'],
						type: 'string',
					},
				},
				required: ['currency', 'platform', 'from_account_type', 'device'],
				type: 'object',
			},
			traits: {
				type: 'object',
			},
		},
		required: ['properties'],
		title: 'Interest Deposit Min Amount Clicked',
		type: 'object',
	}
	const message = {
		event: 'Interest Deposit Min Amount Clicked',
		properties: props || {},
		options,
	}
	validateAgainstSchema(message, schema)

	const a = analytics()
	if (a) {
		a.track(
			'Interest Deposit Min Amount Clicked',
			props || {},
			withTypewriterContext(options),
			callback
		)
	}
}
/**
 * Interest deposit page viewed. It is also called transfer and is where the user can add funds to their interest saving wallet
 *
 * @param {InterestDepositViewed} [props] - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function interestDepositViewed(
	props?: InterestDepositViewed,
	options?: Segment.Options,
	callback?: Segment.Callback
): void {
	const schema = {
		$schema: 'http://json-schema.org/draft-07/schema#',
		description:
			'Interest deposit page viewed. It is also called transfer and is where the user can add funds to their interest saving wallet',
		labels: {
			flow: 'interest_v1',
			source: 'client',
		},
		properties: {
			context: {},
			properties: {
				properties: {
					currency: {
						description:
							'What currency the user is about to deposit to their interest savings account (if known)',
						pattern: '^[A-Z]{3,5}$',
						type: 'string',
					},
					device: {
						description: 'Device type from where the event was triggered.',
						enum: ['APP-iOS', 'WEB', 'APP-Android'],
						type: 'string',
					},
					path: {
						description:
							'Path portion of the URL of the page. Equivalent to canonical path which defaults to location.pathname from the DOM API.',
						type: 'string',
					},
					platform: {
						description: 'What platform the page viewed belongs to',
						enum: ['WALLET'],
						type: 'string',
					},
					referrer: {
						description:
							'Full URL of the previous page. Equivalent to document.referrer from the DOM API.',
						type: 'string',
					},
					search: {
						description:
							'Query string portion of the URL of the page. Equivalent to location.search from the DOM API.',
						type: 'string',
					},
					title: {
						description:
							'Title of the page. Equivalent to document.title from the DOM API.',
						type: 'string',
					},
					url: {
						description:
							'Full URL of the page. First we look for the canonical url. If the canonical url is not provided, we use location.href from the DOM API.',
						type: 'string',
					},
				},
				required: ['platform', 'device'],
				type: 'object',
			},
			traits: {
				type: 'object',
			},
		},
		title: 'Interest Deposit Viewed',
		type: 'object',
	}
	const message = {
		event: 'Interest Deposit Viewed',
		properties: props || {},
		options,
	}
	validateAgainstSchema(message, schema)

	const a = analytics()
	if (a) {
		a.track(
			'Interest Deposit Viewed',
			props || {},
			withTypewriterContext(options),
			callback
		)
	}
}
/**
 * User clicks on a button to submit information. Submitting these , are required by compliance after hitting a certain volume.
 *
 * @param {InterestSubmitInformationClicked} props - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function interestSubmitInformationClicked(
	props: InterestSubmitInformationClicked,
	options?: Segment.Options,
	callback?: Segment.Callback
): void {
	const schema = {
		$schema: 'http://json-schema.org/draft-07/schema#',
		description:
			'User clicks on a button to submit information. Submitting these , are required by compliance after hitting a certain volume.',
		labels: {
			flow: 'interest_v1',
			source: 'client',
		},
		properties: {
			context: {},
			properties: {
				properties: {
					device: {
						description: 'Device type from where the event was triggered.',
						enum: ['APP-iOS', 'WEB', 'APP-Android'],
						type: 'string',
					},
					origin: {
						description:
							'what button we are referring to.  SAVINGS_PAGE: general interest savings overview page or screen. SAVINGS_CONFIRMATION : SAVINGS_PAGE general interest savings overview page or screen ',
						enum: ['SAVINGS_CONFIRMATION', 'SAVINGS_PAGE'],
						type: 'string',
					},
					platform: {
						description:
							'What platform the user wants to submit information from',
						enum: ['WALLET'],
						type: 'string',
					},
				},
				required: ['origin', 'platform', 'device'],
				type: 'object',
			},
			traits: {
				type: 'object',
			},
		},
		required: ['properties'],
		title: 'Interest Submit Information Clicked',
		type: 'object',
	}
	const message = {
		event: 'Interest Submit Information Clicked',
		properties: props || {},
		options,
	}
	validateAgainstSchema(message, schema)

	const a = analytics()
	if (a) {
		a.track(
			'Interest Submit Information Clicked',
			props || {},
			withTypewriterContext(options),
			callback
		)
	}
}
/**
 * General Interest page viewed. It is usually the landing page with the list of savings accounts
 *
 * @param {InterestViewed} [props] - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function interestViewed(
	props?: InterestViewed,
	options?: Segment.Options,
	callback?: Segment.Callback
): void {
	const schema = {
		$schema: 'http://json-schema.org/draft-07/schema#',
		description:
			'General Interest page viewed. It is usually the landing page with the list of savings accounts',
		labels: {
			flow: 'interest_v1',
			source: 'client',
		},
		properties: {
			context: {},
			properties: {
				properties: {
					device: {
						description: 'Device type from where the event was triggered.',
						enum: ['APP-iOS', 'WEB', 'APP-Android'],
						type: 'string',
					},
					path: {
						description:
							'Path portion of the URL of the page. Equivalent to canonical path which defaults to location.pathname from the DOM API.',
						type: 'string',
					},
					platform: {
						description: 'What platform the page viewed belongs to',
						enum: ['WALLET'],
						type: 'string',
					},
					referrer: {
						description:
							'Full URL of the previous page. Equivalent to document.referrer from the DOM API.',
						type: 'string',
					},
					search: {
						description:
							'Query string portion of the URL of the page. Equivalent to location.search from the DOM API.',
						type: 'string',
					},
					title: {
						description:
							'Title of the page. Equivalent to document.title from the DOM API.',
						type: 'string',
					},
					url: {
						description:
							'Full URL of the page. First we look for the canonical url. If the canonical url is not provided, we use location.href from the DOM API.',
						type: 'string',
					},
				},
				required: ['platform', 'device'],
				type: 'object',
			},
			traits: {
				type: 'object',
			},
		},
		title: 'Interest Viewed',
		type: 'object',
	}
	const message = {
		event: 'Interest Viewed',
		properties: props || {},
		options,
	}
	validateAgainstSchema(message, schema)

	const a = analytics()
	if (a) {
		a.track(
			'Interest Viewed',
			props || {},
			withTypewriterContext(options),
			callback
		)
	}
}
/**
 * Button which brings the user to the interest withdrawal flyover or screen is clicked. It is where the user can add withdraw funds from their interest savings wallet
 *
 * @param {InterestWithdrawalClicked} [props] - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function interestWithdrawalClicked(
	props?: InterestWithdrawalClicked,
	options?: Segment.Options,
	callback?: Segment.Callback
): void {
	const schema = {
		$schema: 'http://json-schema.org/draft-07/schema#',
		description:
			'Button which brings the user to the interest withdrawal flyover or screen is clicked. It is where the user can add withdraw funds from their interest savings wallet',
		labels: {
			flow: 'interest_v1',
			source: 'client',
		},
		properties: {
			context: {},
			properties: {
				properties: {
					currency: {
						description:
							'What currency the user is about to withdraw from their interest savings account (if known)',
						pattern: '^[A-Z]{3,5}$',
						type: 'string',
					},
					device: {
						description: 'Device type from where the event was triggered.',
						enum: ['APP-iOS', 'WEB', 'APP-Android'],
						type: 'string',
					},
					origin: {
						description:
							'What button we are referring to.  CURRENCY_PAGE : CTA or menu on the coin page next to balance. SAVINGS_PAGE: general interest savings overview page or screen ',
						enum: ['CURRENCY_PAGE', 'SAVINGS_PAGE'],
						type: 'string',
					},
					platform: {
						description: 'What platform the user is clicking from',
						enum: ['WALLET'],
						type: 'string',
					},
				},
				required: ['origin', 'platform', 'device'],
				type: 'object',
			},
			traits: {
				type: 'object',
			},
		},
		title: 'Interest Withdrawal Clicked',
		type: 'object',
	}
	const message = {
		event: 'Interest Withdrawal Clicked',
		properties: props || {},
		options,
	}
	validateAgainstSchema(message, schema)

	const a = analytics()
	if (a) {
		a.track(
			'Interest Withdrawal Clicked',
			props || {},
			withTypewriterContext(options),
			callback
		)
	}
}
/**
 * Interest withdrawal page viewed. It is where the user can withdraw funds from their interest savings wallet
 *
 * @param {InterestWithdrawalViewed} [props] - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function interestWithdrawalViewed(
	props?: InterestWithdrawalViewed,
	options?: Segment.Options,
	callback?: Segment.Callback
): void {
	const schema = {
		$schema: 'http://json-schema.org/draft-07/schema#',
		description:
			'Interest withdrawal page viewed. It is where the user can withdraw funds from their interest savings wallet',
		labels: {
			flow: 'interest_v1',
			source: 'client',
		},
		properties: {
			context: {},
			properties: {
				properties: {
					currency: {
						description:
							'What currency the user is about to withdraw from their interest savings account (if known)',
						pattern: '^[A-Z]{3,5}$',
						type: 'string',
					},
					device: {
						description: 'Device type from where the event was triggered.',
						enum: ['APP-iOS', 'WEB', 'APP-Android'],
						type: 'string',
					},
					path: {
						description:
							'Path portion of the URL of the page. Equivalent to canonical path which defaults to location.pathname from the DOM API.',
						type: 'string',
					},
					platform: {
						description: 'What platform the page viewed belongs to',
						enum: ['WALLET'],
						type: 'string',
					},
					referrer: {
						description:
							'Full URL of the previous page. Equivalent to document.referrer from the DOM API.',
						type: 'string',
					},
					search: {
						description:
							'Query string portion of the URL of the page. Equivalent to location.search from the DOM API.',
						type: 'string',
					},
					title: {
						description:
							'Title of the page. Equivalent to document.title from the DOM API.',
						type: 'string',
					},
					url: {
						description:
							'Full URL of the page. First we look for the canonical url. If the canonical url is not provided, we use location.href from the DOM API.',
						type: 'string',
					},
				},
				required: ['platform', 'device'],
				type: 'object',
			},
			traits: {
				type: 'object',
			},
		},
		title: 'Interest Withdrawal Viewed',
		type: 'object',
	}
	const message = {
		event: 'Interest Withdrawal Viewed',
		properties: props || {},
		options,
	}
	validateAgainstSchema(message, schema)

	const a = analytics()
	if (a) {
		a.track(
			'Interest Withdrawal Viewed',
			props || {},
			withTypewriterContext(options),
			callback
		)
	}
}
/**
 * Allow login without email authentication from a list of IP addresses.
 *
 * @param {IpWhitelistUpdated} props - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function ipWhitelistUpdated(
	props: IpWhitelistUpdated,
	options?: Segment.Options,
	callback?: Segment.Callback
): void {
	const schema = {
		$schema: 'http://json-schema.org/draft-07/schema#',
		description:
			'Allow login without email authentication from a list of IP addresses. ',
		labels: {
			flow: 'security_v1',
			source: 'backend',
		},
		properties: {
			context: {},
			properties: {
				properties: {
					device: {
						description: 'Device type from where the event was triggered.',
						enum: ['APP-iOS', 'WEB', 'APP-Android'],
						type: 'string',
					},
					is_empty: {
						description: 'True if list is empty',
						type: 'boolean',
					},
					platform: {
						description:
							'From what platform the user is managing Security events\n',
						enum: ['EXCHANGE', 'WALLET'],
						type: 'string',
					},
				},
				required: ['platform', 'is_empty'],
				type: 'object',
			},
			traits: {
				type: 'object',
			},
		},
		required: ['properties'],
		title: 'Ip Whitelist Updated',
		type: 'object',
	}
	const message = {
		event: 'Ip Whitelist Updated',
		properties: props || {},
		options,
	}
	validateAgainstSchema(message, schema)

	const a = analytics()
	if (a) {
		a.track(
			'Ip Whitelist Updated',
			props || {},
			withTypewriterContext(options),
			callback
		)
	}
}
/**
 * User sets their preferred language from the displayed options.
 *
 * @param {LanguageSet} props - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function languageSet(
	props: LanguageSet,
	options?: Segment.Options,
	callback?: Segment.Callback
): void {
	const schema = {
		$schema: 'http://json-schema.org/draft-07/schema#',
		description:
			'User sets their preferred language from the displayed options.',
		labels: {
			flow: ['settings_v1', 'dot_com', 'explorer'],
			source: 'backend',
		},
		properties: {
			context: {},
			properties: {
				properties: {
					device: {
						description: 'Device type from where the event was triggered.',
						enum: ['APP-iOS', 'WEB', 'APP-Android'],
						type: 'string',
					},
					language: {
						description: 'Language in Alpha-2 code (2 letters lower cases)',
						pattern: '^[a-z]{2}$',
						type: 'string',
					},
					platform: {
						description: 'From what platform the user is using the Settings',
						enum: ['BLOCKCHAIN_COM', 'EXCHANGE', 'EXPLORER', 'WALLET'],
						type: 'string',
					},
				},
				required: ['language', 'platform'],
				type: 'object',
			},
			traits: {
				type: 'object',
			},
		},
		required: ['properties'],
		title: 'Language Set',
		type: 'object',
	}
	const message = {
		event: 'Language Set',
		properties: props || {},
		options,
	}
	validateAgainstSchema(message, schema)

	const a = analytics()
	if (a) {
		a.track(
			'Language Set',
			props || {},
			withTypewriterContext(options),
			callback
		)
	}
}
/**
 * An item of the left menu is clicked
 *
 * @param {LeftMenuSelectionClicked} props - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function leftMenuSelectionClicked(
	props: LeftMenuSelectionClicked,
	options?: Segment.Options,
	callback?: Segment.Callback
): void {
	const schema = {
		$schema: 'http://json-schema.org/draft-07/schema#',
		description: 'An item of the left menu is clicked',
		labels: {
			flow: 'explorer',
			source: 'client',
		},
		properties: {
			context: {},
			properties: {
				properties: {
					device: {
						description: 'What device the event is tracked from',
						enum: ['WEB'],
						type: 'string',
					},
					item: {
						description: 'What item is clicked on the navigation header',
						enum: [
							' BITCOIN_CASH',
							' BITCOIN_CASH_TESTNET',
							' BITCOIN_TESTNET',
							' DEFI',
							' ETHEREUM',
							' NONE',
							' PRICES',
							'ACADEMY',
							'BITCOIN',
							'CHARTS',
							'DEFI',
							'DEVELOPERS',
							'EXCHANGE',
							'HOME',
							'NFT',
							'PRICES',
							'WALLET',
						],
						type: 'string',
					},
					platform: {
						description: 'What platform the event is referring to',
						enum: ['EXPLORER'],
						type: 'string',
					},
				},
				required: ['item', 'platform', 'device'],
				type: 'object',
			},
			traits: {
				type: 'object',
			},
		},
		required: ['properties'],
		title: 'Left Menu Selection Clicked',
		type: 'object',
	}
	const message = {
		event: 'Left Menu Selection Clicked',
		properties: props || {},
		options,
	}
	validateAgainstSchema(message, schema)

	const a = analytics()
	if (a) {
		a.track(
			'Left Menu Selection Clicked',
			props || {},
			withTypewriterContext(options),
			callback
		)
	}
}
/**
 * The legal entity of the user has been updated (different from an assigned legal entity, with is recorded in the "Signed Up" event)
 *
 * @param {LegalEntityUpdated} props - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function legalEntityUpdated(
	props: LegalEntityUpdated,
	options?: Segment.Options,
	callback?: Segment.Callback
): void {
	const schema = {
		$schema: 'http://json-schema.org/draft-07/schema#',
		description:
			'The legal entity of the user has been updated (different from an assigned legal entity, with is recorded in the "Signed Up" event)',
		labels: {
			flow: ['onboarding_v1', 'onboarding_e1', 'sign_up'],
			source: 'backend',
		},
		properties: {
			context: {},
			properties: {
				properties: {
					device: {
						description: 'What device the user created the account from',
						enum: [' APP-iOS', 'APP-Android', 'WEB'],
						type: 'string',
					},
					legal_entity: {
						description: 'legal entity has been updated to this label ',
						enum: ['BC_BVI_3', 'BC_LT', 'BC_LT_2', 'BC_US'],
						type: 'string',
					},
					legal_entity_before_update: {
						description: 'the users past legal entity',
						enum: [' BC_LT', ' BC_US', 'BC_BVI_3', 'BC_LT_2'],
						type: 'string',
					},
					legal_entity_reason: {
						description:
							'legal entity to a user has been updated based on this reason.',
						enum: ['ADDRESS', 'DEFAULT', 'IP', 'MANUAL'],
						type: 'string',
					},
					platform: {
						description: 'What platform the user signed up for',
						enum: ['EXCHANGE', 'WALLET'],
						type: 'string',
					},
				},
				required: [
					'device',
					'legal_entity',
					'legal_entity_before_update',
					'legal_entity_reason',
					'platform',
				],
				type: 'object',
			},
			traits: {
				type: 'object',
			},
		},
		required: ['properties'],
		title: 'Legal Entity Updated',
		type: 'object',
	}
	const message = {
		event: 'Legal Entity Updated',
		properties: props || {},
		options,
	}
	validateAgainstSchema(message, schema)

	const a = analytics()
	if (a) {
		a.track(
			'Legal Entity Updated',
			props || {},
			withTypewriterContext(options),
			callback
		)
	}
}
/**
 * The user clicks on a button to link a bank
 *
 * @param {LinkBankClicked} [props] - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function linkBankClicked(
	props?: LinkBankClicked,
	options?: Segment.Options,
	callback?: Segment.Callback
): void {
	const schema = {
		$schema: 'http://json-schema.org/draft-07/schema#',
		description: 'The user clicks on a button to link a bank',
		labels: {
			flow: ['withdraw_v1', 'settings_v1'],
			source: 'client',
		},
		properties: {
			context: {},
			properties: {
				properties: {
					device: {
						description: 'Device type from where the event was triggered.',
						enum: ['APP-iOS', 'WEB', 'APP-Android'],
						type: 'string',
					},
					origin: {
						description:
							"What button we are referring to. DEPOSIT : from depositing funds. SETTINGS : user's settings page. BUY : from the Buy flow.  WITHDRAW : from withdrawing funds.",
						enum: ['BUY', 'DEPOSIT', 'SETTINGS', 'WITHDRAW'],
						type: 'string',
					},
					platform: {
						description: 'What platform the user wants to link a bank for',
						enum: ['EXCHANGE', 'WALLET'],
						type: 'string',
					},
				},
				required: ['platform', 'device', 'origin'],
				type: 'object',
			},
			traits: {
				type: 'object',
			},
		},
		title: 'Link Bank Clicked',
		type: 'object',
	}
	const message = {
		event: 'Link Bank Clicked',
		properties: props || {},
		options,
	}
	validateAgainstSchema(message, schema)

	const a = analytics()
	if (a) {
		a.track(
			'Link Bank Clicked',
			props || {},
			withTypewriterContext(options),
			callback
		)
	}
}
/**
 * The user approves the general conditions and approvals necessary to start the link process with the bank. The user selects what bank he wants to link (e.g. REVOLUT, BARCLAYS, etc.). NOTE : Only available for OB. Not available for Web because it's inside an iframe
 *
 * @param {LinkBankConditionsApproved} props - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function linkBankConditionsApproved(
	props: LinkBankConditionsApproved,
	options?: Segment.Options,
	callback?: Segment.Callback
): void {
	const schema = {
		$schema: 'http://json-schema.org/draft-07/schema#',
		description:
			"The user approves the general conditions and approvals necessary to start the link process with the bank. The user selects what bank he wants to link (e.g. REVOLUT, BARCLAYS, etc.). NOTE : Only available for OB. Not available for Web because it's inside an iframe",
		labels: {
			flow: ['withdraw_v1', 'settings_v1'],
			source: 'client',
		},
		properties: {
			context: {},
			properties: {
				properties: {
					bank_name: {
						description:
							'Bank name, in camel case, for example "Barclays", "Revolut"',
						type: 'string',
					},
					device: {
						description: 'Device type from where the event was triggered.',
						enum: ['APP-iOS', 'WEB', 'APP-Android'],
						type: 'string',
					},
					partner: {
						description:
							'What is the bank partner. This will be used to know whether it is ACH or OB',
						enum: ['YAPILY', 'YODLEE'],
						type: 'string',
					},
					platform: {
						description: 'What platform the user wants to link a bank for',
						enum: ['EXCHANGE', 'WALLET'],
						type: 'string',
					},
					provider: {
						description: 'What provider is used to link the bank',
						enum: ['FINTECTURE', 'SAFE_CONNECT'],
						type: 'string',
					},
				},
				required: ['platform', 'partner', 'bank_name', 'provider', 'device'],
				type: 'object',
			},
			traits: {
				type: 'object',
			},
		},
		required: ['properties'],
		title: 'Link Bank Conditions Approved',
		type: 'object',
	}
	const message = {
		event: 'Link Bank Conditions Approved',
		properties: props || {},
		options,
	}
	validateAgainstSchema(message, schema)

	const a = analytics()
	if (a) {
		a.track(
			'Link Bank Conditions Approved',
			props || {},
			withTypewriterContext(options),
			callback
		)
	}
}
/**
 * The user selects what bank he wants to link (e.g. REVOLUT, BARCLAYS, etc.). NOTE : Only available for OB. Not available for Web because it's inside an iframe
 *
 * @param {LinkBankSelected} props - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function linkBankSelected(
	props: LinkBankSelected,
	options?: Segment.Options,
	callback?: Segment.Callback
): void {
	const schema = {
		$schema: 'http://json-schema.org/draft-07/schema#',
		description:
			"The user selects what bank he wants to link (e.g. REVOLUT, BARCLAYS, etc.). NOTE : Only available for OB. Not available for Web because it's inside an iframe",
		labels: {
			flow: ['withdraw_v1', 'settings_v1'],
			source: 'client',
		},
		properties: {
			context: {},
			properties: {
				properties: {
					bank_name: {
						description:
							'Bank name, in camel case, for example "Barclays", "Revolut"',
						type: 'string',
					},
					device: {
						description: 'Device type from where the event was triggered.',
						enum: ['APP-iOS', 'WEB', 'APP-Android'],
						type: 'string',
					},
					partner: {
						description:
							'What is the bank partner for the account being linked',
						enum: ['YAPILY', 'YODLEE'],
						type: 'string',
					},
					platform: {
						description: 'What platform the user wants to link a bank for',
						enum: ['EXCHANGE', 'WALLET'],
						type: 'string',
					},
				},
				required: ['partner', 'bank_name', 'device', 'platform'],
				type: 'object',
			},
			traits: {
				type: 'object',
			},
		},
		required: ['properties'],
		title: 'Link Bank Selected',
		type: 'object',
	}
	const message = {
		event: 'Link Bank Selected',
		properties: props || {},
		options,
	}
	validateAgainstSchema(message, schema)

	const a = analytics()
	if (a) {
		a.track(
			'Link Bank Selected',
			props || {},
			withTypewriterContext(options),
			callback
		)
	}
}
/**
 * The user clicks on the Add Card button to link a Card
 *
 * @param {LinkCardClicked} props - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function linkCardClicked(
	props: LinkCardClicked,
	options?: Segment.Options,
	callback?: Segment.Callback
): void {
	const schema = {
		$schema: 'http://json-schema.org/draft-07/schema#',
		description: 'The user clicks on the Add Card button to link a Card',
		labels: {
			flow: ['withdraw_v1', 'settings_v1'],
			source: 'client',
		},
		properties: {
			context: {},
			properties: {
				properties: {
					device: {
						description: 'Device type from where the event was triggered.',
						enum: ['APP-iOS', 'WEB', 'APP-Android'],
						type: 'string',
					},
					origin: {
						description:
							"What button we are referring to. SETTINGS : user's settings page. BUY : from the Buy flow.  ",
						enum: ['BUY', 'SETTINGS'],
						type: 'string',
					},
					platform: {
						description: 'What platform the user wants to link a bank for',
						enum: ['EXCHANGE', 'WALLET'],
						type: 'string',
					},
				},
				required: ['device', 'platform', 'origin'],
				type: 'object',
			},
			traits: {
				type: 'object',
			},
		},
		required: ['properties'],
		title: 'Link Card Clicked',
		type: 'object',
	}
	const message = {
		event: 'Link Card Clicked',
		properties: props || {},
		options,
	}
	validateAgainstSchema(message, schema)

	const a = analytics()
	if (a) {
		a.track(
			'Link Card Clicked',
			props || {},
			withTypewriterContext(options),
			callback
		)
	}
}
/**
 * User sets the local currency from the displayed options.
 *
 * @param {LocalCurrencySet} props - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function localCurrencySet(
	props: LocalCurrencySet,
	options?: Segment.Options,
	callback?: Segment.Callback
): void {
	const schema = {
		$schema: 'http://json-schema.org/draft-07/schema#',
		description: 'User sets the local currency from the displayed options.',
		labels: {
			flow: ['settings_v1', 'explorer'],
			source: 'backend',
		},
		properties: {
			context: {},
			properties: {
				properties: {
					currency: {
						description: 'What fiat currency',
						pattern: '^[A-Z]{3,5}$',
						type: 'string',
					},
					device: {
						description: 'Device type from where the event was triggered.',
						enum: ['APP-iOS', 'WEB', 'APP-Android'],
						type: 'string',
					},
					platform: {
						description: 'From what platform the user is using the Settings',
						enum: ['EXCHANGE', 'EXPLORER', 'WALLET'],
						type: 'string',
					},
				},
				required: ['platform', 'currency'],
				type: 'object',
			},
			traits: {
				type: 'object',
			},
		},
		required: ['properties'],
		title: 'Local Currency Set',
		type: 'object',
	}
	const message = {
		event: 'Local Currency Set',
		properties: props || {},
		options,
	}
	validateAgainstSchema(message, schema)

	const a = analytics()
	if (a) {
		a.track(
			'Local Currency Set',
			props || {},
			withTypewriterContext(options),
			callback
		)
	}
}
/**
 * Login or Sign in button which brings the user to the log in flow is clicked
 *
 * @param {LoginClicked} props - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function loginClicked(
	props: LoginClicked,
	options?: Segment.Options,
	callback?: Segment.Callback
): void {
	const schema = {
		$schema: 'http://json-schema.org/draft-07/schema#',
		description:
			'Login or Sign in button which brings the user to the log in flow is clicked',
		labels: {
			flow: ['sso_v1', 'dot_com'],
			source: 'client',
		},
		properties: {
			context: {},
			properties: {
				properties: {
					device: {
						description: 'Device from which the user is signing in ',
						enum: ['APP-Android', 'APP-iOS', 'WEB'],
						type: 'string',
					},
					exchange: {
						description: 'Parameters about the exchange account',
						properties: {
							two_fa_mode: {
								description: 'Whether the exchange account has 2FA set up',
								type: 'boolean',
							},
							user_id: {
								description: 'Exchange user credentials ID',
								type: 'string',
							},
						},
						required: [],
						type: 'object',
					},
					mergeable: {
						description: 'Indicates if possible to merge two unlinked accounts',
						type: 'boolean',
					},
					origin: {
						description:
							'What button we are referring to. \nGUEST_LIMITATION (exchange): A specific action from the guest view requires login. HOMEPAGE (dotcom) : from the Blockchain.com or Exchange.blockchain.com home page content. LAUNCH_SCREEN (mobile only) : when login from the launch screen. NAVIGATION (dotcom) : navigation bar. RECOVERY_CLOUD_BACKUP (wallet) : when failing to scan QR code cloud backup and clicking on login. ',
						enum: [
							'GUEST_LIMITATION',
							'HOMEPAGE',
							'LAUNCH_SCREEN',
							'NAVIGATION',
							'NUX_LAUNCH_PROMO_LOG_IN',
							'RECOVERY_CLOUD_BACKUP',
						],
						type: 'string',
					},
					platform: {
						description: 'Platform from which the user is signing in',
						enum: ['WALLET'],
						type: 'string',
					},
					site_redirect: {
						description:
							'Whether the user is being redirected to the exchange or wallet',
						enum: ['EXCHANGE', 'WALLET'],
						type: 'string',
					},
					upgradeable: {
						description:
							'Indicates if possible to “upgrade” to a new unified Blockchain.com Account',
						type: 'boolean',
					},
					wallet: {
						description: 'Parameters about the wallet account',
						properties: {
							auth_type: {
								description: 'The wallet 2FA type that is enforced.',
								enum: [
									'0_NONE',
									'1_YUBIKEY',
									'2_EMAIL',
									'3_YUBIKEY_MTGOX',
									'4_GOOGLE_AUTHENTICATOR',
									'5_SMS',
								],
								type: 'string',
							},
							exchange: {
								description: 'Parameters about the exchange account',
								properties: {
									two_fa_mode: {
										description: 'Whether the exchange account has 2FA set up',
										properties: {},
										required: [],
										type: 'object',
									},
									user_id: {
										description: 'Exchange user credentials ID',
										type: 'object',
									},
								},
								required: [],
								type: 'object',
							},
							guid_first_four: {
								description:
									'The first four characters of the wallet.guid field',
								pattern: '^.{4,4}$',
								type: 'string',
							},
							has_cloud_backup: {
								description: 'Whether the wallet has cloud backups',
								type: 'boolean',
							},
							is_mobile_setup: {
								description: 'Whether the wallet has a mobile client set up',
								type: 'boolean',
							},
							last_mnemonic_backup: {
								description:
									'The last time, in unix timestamp, in which a wallet has their mnemonic backup verified',
								type: 'integer',
							},
							mobile_device_type: {
								description: 'The type of device being verified',
								enum: ['APP-Android', 'APP-iOS'],
								type: 'string',
							},
							nabu: {
								description: 'Parameter about the nabu account',
								properties: {
									recovery_eligible: {
										description:
											'Whether the nabu user is eligible for recovery. Usually if account has value (> $300 or 1 payment method linked)',
										type: 'boolean',
									},
									user_id: {
										description:
											'The Nabu User ID. This is from the users table in nabu gateway',
										type: 'object',
									},
								},
								required: [],
								type: 'object',
							},
						},
						required: [],
						type: 'object',
					},
				},
				required: ['platform', 'device', 'origin'],
				type: 'object',
			},
			traits: {
				type: 'object',
			},
		},
		required: ['properties'],
		title: 'Login Clicked',
		type: 'object',
	}
	const message = {
		event: 'Login Clicked',
		properties: props || {},
		options,
	}
	validateAgainstSchema(message, schema)

	const a = analytics()
	if (a) {
		a.track(
			'Login Clicked',
			props || {},
			withTypewriterContext(options),
			callback
		)
	}
}
/**
 * User clicks on a button or link to get help when having trouble logging in. For example "Need Some Help" link
 *
 * @param {LoginHelpClicked} props - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function loginHelpClicked(
	props: LoginHelpClicked,
	options?: Segment.Options,
	callback?: Segment.Callback
): void {
	const schema = {
		$schema: 'http://json-schema.org/draft-07/schema#',
		description:
			'User clicks on a button or link to get help when having trouble logging in. For example "Need Some Help" link',
		labels: {
			flow: 'sso_v1',
			source: 'client',
		},
		properties: {
			context: {},
			properties: {
				properties: {
					device: {
						description: 'What device the user is login in from',
						enum: ['APP-Android', 'APP-iOS', 'WEB'],
						type: 'string',
					},
					exchange: {
						description: 'Parameters about the exchange account',
						properties: {
							two_fa_mode: {
								description: 'Whether the exchange account has 2FA set up',
								type: 'boolean',
							},
							user_id: {
								description: 'Exchange user credentials ID',
								type: 'string',
							},
						},
						required: [],
						type: 'object',
					},
					mergeable: {
						description: 'Indicates if possible to merge two unlinked accounts',
						type: 'boolean',
					},
					origin: {
						description:
							'what button we are referring to. IDENTIFIER : when failing to provide an identifier. PASSWORD: when failing to provide a correct password. QR_CODE : when failing to scan QR code. ',
						enum: ['IDENTIFIER', 'PASSWORD', 'QR_CODE'],
						type: 'string',
					},
					platform: {
						description: 'Platform from which the user is signing in',
						enum: ['WALLET', 'APP-Android', 'APP-iOS'],
						type: 'string',
					},
					site_redirect: {
						description:
							'Whether the user is being redirected to the exchange or wallet',
						enum: ['EXCHANGE', 'WALLET'],
						type: 'string',
					},
					upgradeable: {
						description:
							'Indicates if possible to “upgrade” to a new unified Blockchain.com Account',
						type: 'boolean',
					},
					wallet: {
						description: 'Parameters about the wallet account',
						properties: {
							auth_type: {
								description: 'The wallet 2FA type that is enforced.',
								enum: [
									'0_NONE',
									'1_YUBIKEY',
									'2_EMAIL',
									'3_YUBIKEY_MTGOX',
									'4_GOOGLE_AUTHENTICATOR',
									'5_SMS',
								],
								type: 'string',
							},
							exchange: {
								description: 'Parameters about the exchange account',
								properties: {
									two_fa_mode: {
										description: 'Whether the exchange account has 2FA set up',
										properties: {},
										required: [],
										type: 'object',
									},
									user_id: {
										description: 'Exchange user credentials ID',
										type: 'object',
									},
								},
								required: [],
								type: 'object',
							},
							guid_first_four: {
								description:
									'The first four characters of the wallet.guid field',
								pattern: '^.{4,4}$',
								type: 'string',
							},
							has_cloud_backup: {
								description: 'Whether the wallet has cloud backups',
								type: 'boolean',
							},
							is_mobile_setup: {
								description: 'Whether the wallet has a mobile client set up',
								type: 'boolean',
							},
							last_mnemonic_backup: {
								description:
									'The last time, in unix timestamp, in which a wallet has their mnemonic backup verified',
								type: 'integer',
							},
							mobile_device_type: {
								description: 'The type of device being verified',
								enum: ['APP-Android', 'APP-iOS'],
								type: 'string',
							},
							nabu: {
								description: 'Parameter about the nabu account',
								properties: {
									recovery_eligible: {
										description:
											'Whether the nabu user is eligible for recovery. Usually if account has value (> $300 or 1 payment method linked)',
										type: 'boolean',
									},
									user_id: {
										description:
											'The Nabu User ID. This is from the users table in nabu gateway',
										type: 'object',
									},
								},
								required: [],
								type: 'object',
							},
						},
						required: [],
						type: 'object',
					},
				},
				required: ['origin', 'platform', 'device'],
				type: 'object',
			},
			traits: {
				type: 'object',
			},
		},
		required: ['properties'],
		title: 'Login Help Clicked',
		type: 'object',
	}
	const message = {
		event: 'Login Help Clicked',
		properties: props || {},
		options,
	}
	validateAgainstSchema(message, schema)

	const a = analytics()
	if (a) {
		a.track(
			'Login Help Clicked',
			props || {},
			withTypewriterContext(options),
			callback
		)
	}
}
/**
 * The user entered and submitted their Email or Wallet ID to log in
 *
 * @param {LoginIdentifierEntered} props - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function loginIdentifierEntered(
	props: LoginIdentifierEntered,
	options?: Segment.Options,
	callback?: Segment.Callback
): void {
	const schema = {
		$schema: 'http://json-schema.org/draft-07/schema#',
		description:
			'The user entered and submitted their Email or Wallet ID to log in',
		labels: {
			flow: 'sso_v1',
			source: 'client',
		},
		properties: {
			context: {},
			properties: {
				properties: {
					device: {
						description: 'What device you are viewing the login screen from',
						enum: ['APP-Android', 'APP-iOS', 'WEB'],
						type: 'string',
					},
					exchange: {
						description: 'Parameters about the exchange account',
						properties: {
							two_fa_mode: {
								description: 'Whether the exchange account has 2FA set up',
								type: 'boolean',
							},
							user_id: {
								description: 'Exchange user credentials ID',
								type: 'string',
							},
						},
						required: [],
						type: 'object',
					},
					identifier_type: {
						description: 'What type of identifier is supplied',
						enum: ['EMAIL', 'WALLET_ID'],
						type: 'string',
					},
					mergeable: {
						description: 'Indicates if possible to merge two unlinked accounts',
						type: 'boolean',
					},
					platform: {
						description: 'Platform from which the user is signing in',
						enum: ['WALLET'],
						type: 'string',
					},
					site_redirect: {
						description:
							'Whether the user is being redirected to the exchange or wallet',
						enum: ['EXCHANGE', 'WALLET'],
						type: 'string',
					},
					upgradeable: {
						description:
							'Indicates if possible to “upgrade” to a new unified Blockchain.com Account',
						type: 'boolean',
					},
					wallet: {
						description: 'Parameters about the wallet account',
						properties: {
							auth_type: {
								description: 'The wallet 2FA type that is enforced.',
								enum: [
									'0_NONE',
									'1_YUBIKEY',
									'2_EMAIL',
									'3_YUBIKEY_MTGOX',
									'4_GOOGLE_AUTHENTICATOR',
									'5_SMS',
								],
								type: 'string',
							},
							exchange: {
								description: 'Parameters about the exchange account',
								properties: {
									two_fa_mode: {
										description: 'Whether the exchange account has 2FA set up',
										properties: {},
										required: [],
										type: 'object',
									},
									user_id: {
										description: 'Exchange user credentials ID',
										type: 'object',
									},
								},
								required: [],
								type: 'object',
							},
							guid_first_four: {
								description:
									'The first four characters of the wallet.guid field',
								pattern: '^.{4,4}$',
								type: 'string',
							},
							has_cloud_backup: {
								description: 'Whether the wallet has cloud backups',
								type: 'boolean',
							},
							is_mobile_setup: {
								description: 'Whether the wallet has a mobile client set up',
								type: 'boolean',
							},
							last_mnemonic_backup: {
								description:
									'The last time, in unix timestamp, in which a wallet has their mnemonic backup verified',
								type: 'integer',
							},
							mobile_device_type: {
								description: 'The type of device being verified',
								enum: ['APP-Android', 'APP-iOS'],
								type: 'string',
							},
							nabu: {
								description: 'Parameter about the nabu account',
								properties: {
									recovery_eligible: {
										description:
											'Whether the nabu user is eligible for recovery. Usually if account has value (> $300 or 1 payment method linked)',
										type: 'boolean',
									},
									user_id: {
										description:
											'The Nabu User ID. This is from the users table in nabu gateway',
										type: 'object',
									},
								},
								required: [],
								type: 'object',
							},
						},
						required: [],
						type: 'object',
					},
				},
				required: ['platform', 'device'],
				type: 'object',
			},
			traits: {
				type: 'object',
			},
		},
		required: ['properties'],
		title: 'Login Identifier Entered',
		type: 'object',
	}
	const message = {
		event: 'Login Identifier Entered',
		properties: props || {},
		options,
	}
	validateAgainstSchema(message, schema)

	const a = analytics()
	if (a) {
		a.track(
			'Login Identifier Entered',
			props || {},
			withTypewriterContext(options),
			callback
		)
	}
}
/**
 * Allowing login from IP address in user's IP whitelist.
 *
 * @param {LoginIpRestrictionUpdated} props - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function loginIpRestrictionUpdated(
	props: LoginIpRestrictionUpdated,
	options?: Segment.Options,
	callback?: Segment.Callback
): void {
	const schema = {
		$schema: 'http://json-schema.org/draft-07/schema#',
		description: "Allowing login from IP address in user's IP whitelist.",
		labels: {
			flow: 'security_v1',
			source: 'backend',
		},
		properties: {
			context: {},
			properties: {
				properties: {
					device: {
						description: 'Device type from where the event was triggered.',
						enum: ['WEB', 'APP-Android'],
						type: 'string',
					},
					is_restricted: {
						description:
							'True if only allowing login from IP addresses whitelist.',
						type: 'boolean',
					},
					platform: {
						description:
							'From what platform the user is managing Security events\n',
						enum: ['EXCHANGE', 'WALLET'],
						type: 'string',
					},
				},
				required: ['is_restricted', 'platform'],
				type: 'object',
			},
			traits: {
				type: 'object',
			},
		},
		required: ['properties'],
		title: 'Login Ip Restriction Updated',
		type: 'object',
	}
	const message = {
		event: 'Login Ip Restriction Updated',
		properties: props || {},
		options,
	}
	validateAgainstSchema(message, schema)

	const a = analytics()
	if (a) {
		a.track(
			'Login Ip Restriction Updated',
			props || {},
			withTypewriterContext(options),
			callback
		)
	}
}
/**
 * The user explicitly selects a login method, by clicking on Log In With Password, or Log In with device, etc.
 *
 * @param {LoginMethodSelected} props - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function loginMethodSelected(
	props: LoginMethodSelected,
	options?: Segment.Options,
	callback?: Segment.Callback
): void {
	const schema = {
		$schema: 'http://json-schema.org/draft-07/schema#',
		description:
			'The user explicitly selects a login method, by clicking on Log In With Password, or Log In with device, etc.',
		labels: {
			flow: 'sso_v1',
			source: 'client',
		},
		properties: {
			context: {},
			properties: {
				properties: {
					device: {
						description: 'What device you are viewing the login screen from',
						enum: ['APP-Android', 'APP-iOS', 'WEB'],
						type: 'string',
					},
					exchange: {
						description: 'Parameters about the exchange account',
						properties: {
							two_fa_mode: {
								description: 'Whether the exchange account has 2FA set up',
								type: 'boolean',
							},
							user_id: {
								description: 'Exchange user credentials ID',
								type: 'string',
							},
						},
						required: [],
						type: 'object',
					},
					login_method: {
						description:
							'How the user is trying to log in. APPLE: via Apple ID. GOOGLE : via Google Account. PASSWORD : with a password on mobile or web, PIN : with a PIN on mobile,  SECURE_CHANNEL : by sending a log in request via secure channel to another client.',
						enum: ['APPLE', 'GOOGLE', 'PASSWORD', 'PIN', 'SECURE_CHANNEL'],
						type: 'string',
					},
					mergeable: {
						description: 'Indicates if possible to merge two unlinked accounts',
						type: 'boolean',
					},
					platform: {
						description: 'Platform from which the user is signing in',
						enum: ['WALLET'],
						type: 'string',
					},
					site_redirect: {
						description:
							'Whether the user is being redirected to the exchange or wallet',
						enum: ['EXCHANGE', 'WALLET'],
						type: 'string',
					},
					upgradeable: {
						description:
							'Indicates if possible to “upgrade” to a new unified Blockchain.com Account',
						type: 'boolean',
					},
					wallet: {
						description: 'Parameters about the wallet account',
						properties: {
							auth_type: {
								description: 'The wallet 2FA type that is enforced.',
								enum: [
									'0_NONE',
									'1_YUBIKEY',
									'2_EMAIL',
									'3_YUBIKEY_MTGOX',
									'4_GOOGLE_AUTHENTICATOR',
									'5_SMS',
								],
								type: 'string',
							},
							exchange: {
								description: 'Parameters about the exchange account',
								properties: {
									two_fa_mode: {
										description: 'Whether the exchange account has 2FA set up',
										properties: {},
										required: [],
										type: 'object',
									},
									user_id: {
										description: 'Exchange user credentials ID',
										type: 'object',
									},
								},
								required: [],
								type: 'object',
							},
							guid_first_four: {
								description:
									'The first four characters of the wallet.guid field',
								pattern: '^.{4,4}$',
								type: 'string',
							},
							has_cloud_backup: {
								description: 'Whether the wallet has cloud backups',
								type: 'boolean',
							},
							is_mobile_setup: {
								description: 'Whether the wallet has a mobile client set up',
								type: 'boolean',
							},
							last_mnemonic_backup: {
								description:
									'The last time, in unix timestamp, in which a wallet has their mnemonic backup verified',
								type: 'integer',
							},
							mobile_device_type: {
								description: 'The type of device being verified',
								enum: ['APP-Android', 'APP-iOS'],
								type: 'string',
							},
							nabu: {
								description: 'Parameter about the nabu account',
								properties: {
									recovery_eligible: {
										description:
											'Whether the nabu user is eligible for recovery. Usually if account has value (> $300 or 1 payment method linked)',
										type: 'boolean',
									},
									user_id: {
										description:
											'The Nabu User ID. This is from the users table in nabu gateway',
										type: 'object',
									},
								},
								required: [],
								type: 'object',
							},
						},
						required: [],
						type: 'object',
					},
				},
				required: ['device', 'login_method', 'platform'],
				type: 'object',
			},
			traits: {
				type: 'object',
			},
		},
		required: ['properties'],
		title: 'Login Method Selected',
		type: 'object',
	}
	const message = {
		event: 'Login Method Selected',
		properties: props || {},
		options,
	}
	validateAgainstSchema(message, schema)

	const a = analytics()
	if (a) {
		a.track(
			'Login Method Selected',
			props || {},
			withTypewriterContext(options),
			callback
		)
	}
}
/**
 * The user approved the log in request (usually on mobile) sent from another client (usually from web). The request is  done via Secure Channel Opening Authentication, and approving will open the channel
 *
 * @param {LoginRequestApproved} props - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function loginRequestApproved(
	props: LoginRequestApproved,
	options?: Segment.Options,
	callback?: Segment.Callback
): void {
	const schema = {
		$schema: 'http://json-schema.org/draft-07/schema#',
		description:
			'The user approved the log in request (usually on mobile) sent from another client (usually from web). The request is  done via Secure Channel Opening Authentication, and approving will open the channel',
		labels: {
			flow: 'sso_v1',
			source: 'client',
		},
		properties: {
			context: {},
			properties: {
				properties: {
					device: {
						description: 'Device type from where the login request is approved',
						enum: ['APP-iOS', 'APP-Android'],
						type: 'string',
					},
					platform: {
						description:
							'Whether the request is being approved from the WALLET or the EXCHANGE. Only possible from the WALLET for now',
						enum: ['WALLET'],
						type: 'string',
					},
					request_browser: {
						description:
							'The browser being displayed to the user. This is the browser from where the request was sent.',
						type: 'string',
					},
					request_location_country: {
						description:
							'Parsed IP Geolocation displayed to the user. This is the ip from where the request was sent. country format TBD : ideally alpha 2 iso code',
						type: 'string',
					},
					request_platform: {
						description:
							'The channel opening requester platform (exchange/wallet)',
						enum: ['EXCHANGE', 'WALLET'],
						type: 'string',
					},
				},
				required: ['request_platform', 'device', 'platform'],
				type: 'object',
			},
			traits: {
				type: 'object',
			},
		},
		required: ['properties'],
		title: 'Login Request Approved',
		type: 'object',
	}
	const message = {
		event: 'Login Request Approved',
		properties: props || {},
		options,
	}
	validateAgainstSchema(message, schema)

	const a = analytics()
	if (a) {
		a.track(
			'Login Request Approved',
			props || {},
			withTypewriterContext(options),
			callback
		)
	}
}
/**
 * The user denied the log in request (usually on mobile) sent from another client (usually from web). The request is usually done via Secure Channel Opening Authentication, and denying will close the channel
 *
 * @param {LoginRequestDenied} props - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function loginRequestDenied(
	props: LoginRequestDenied,
	options?: Segment.Options,
	callback?: Segment.Callback
): void {
	const schema = {
		$schema: 'http://json-schema.org/draft-07/schema#',
		description:
			'The user denied the log in request (usually on mobile) sent from another client (usually from web). The request is usually done via Secure Channel Opening Authentication, and denying will close the channel',
		labels: {
			flow: 'sso_v1',
			source: 'client',
		},
		properties: {
			context: {},
			properties: {
				properties: {
					device: {
						description: 'Device type from where the login request is denied',
						enum: ['APP-iOS', 'APP-Android'],
						type: 'string',
					},
					error: {
						description: 'The error that was experienced by the user ',
						type: ['string', 'null'],
					},
					method: {
						description:
							'Whether the rejection came for a secure channel opening request OR for a log in with magic link request.',
						enum: ['MAGIC_LINK', 'SECURE_CHANNEL'],
						type: 'string',
					},
					platform: {
						description:
							'Whether the request is being denied from the WALLET or the EXCHANGE. Only possible from the WALLET for now',
						enum: ['WALLET'],
						type: 'string',
					},
					request_browser: {
						description:
							'The browser being displayed to the user. This is the browser from where the request was sent.',
						type: 'string',
					},
					request_location_country: {
						description:
							'Parsed IP Geolocation displayed to the user. This is the ip from where the request was sent. country format TBD : ideally alpha 2 iso code',
						type: 'string',
					},
					request_platform: {
						description:
							'Whether the log in request was sent to log in to the WALLET or the. EXCHANGE.',
						enum: ['EXCHANGE', 'WALLET'],
						type: 'string',
					},
				},
				required: ['request_platform', 'platform', 'device'],
				type: 'object',
			},
			traits: {
				type: 'object',
			},
		},
		required: ['properties'],
		title: 'Login Request Denied',
		type: 'object',
	}
	const message = {
		event: 'Login Request Denied',
		properties: props || {},
		options,
	}
	validateAgainstSchema(message, schema)

	const a = analytics()
	if (a) {
		a.track(
			'Login Request Denied',
			props || {},
			withTypewriterContext(options),
			callback
		)
	}
}
/**
 * The user Two Factor Authentication verification code entered by the user to confirm log in is denied
 *
 * @param {LoginTwoStepVerificationDenied} props - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function loginTwoStepVerificationDenied(
	props: LoginTwoStepVerificationDenied,
	options?: Segment.Options,
	callback?: Segment.Callback
): void {
	const schema = {
		$schema: 'http://json-schema.org/draft-07/schema#',
		description:
			'The user Two Factor Authentication verification code entered by the user to confirm log in is denied',
		labels: {
			flow: 'sso_v1',
			source: 'client',
		},
		properties: {
			context: {},
			properties: {
				properties: {
					device: {
						description: 'Device type from where the user is trying to log in',
						enum: ['APP-Android', 'APP-iOS', 'WEB'],
						type: 'string',
					},
					exchange: {
						description: 'Parameters about the exchange account',
						properties: {
							two_fa_mode: {
								description: 'Whether the exchange account has 2FA set up',
								type: 'boolean',
							},
							user_id: {
								description: 'Exchange user credentials ID',
								type: 'string',
							},
						},
						required: [],
						type: 'object',
					},
					mergeable: {
						description: 'Indicates if possible to merge two unlinked accounts',
						type: 'boolean',
					},
					platform: {
						description: 'Platform from which the user is signing in',
						enum: ['WALLET'],
						type: 'string',
					},
					site_redirect: {
						description:
							'Whether the user is being redirected to the exchange or wallet',
						enum: ['EXCHANGE', 'WALLET'],
						type: 'string',
					},
					upgradeable: {
						description:
							'Indicates if possible to “upgrade” to a new unified Blockchain.com Account',
						type: 'boolean',
					},
					wallet: {
						description: 'Parameters about the wallet account',
						properties: {
							auth_type: {
								description: 'The wallet 2FA type that is enforced.',
								enum: [
									'0_NONE',
									'1_YUBIKEY',
									'2_EMAIL',
									'3_YUBIKEY_MTGOX',
									'4_GOOGLE_AUTHENTICATOR',
									'5_SMS',
								],
								type: 'string',
							},
							exchange: {
								description: 'Parameters about the exchange account',
								properties: {
									two_fa_mode: {
										description: 'Whether the exchange account has 2FA set up',
										properties: {},
										required: [],
										type: 'object',
									},
									user_id: {
										description: 'Exchange user credentials ID',
										type: 'object',
									},
								},
								required: [],
								type: 'object',
							},
							guid_first_four: {
								description:
									'The first four characters of the wallet.guid field',
								pattern: '^.{4,4}$',
								type: 'string',
							},
							has_cloud_backup: {
								description: 'Whether the wallet has cloud backups',
								type: 'boolean',
							},
							is_mobile_setup: {
								description: 'Whether the wallet has a mobile client set up',
								type: 'boolean',
							},
							last_mnemonic_backup: {
								description:
									'The last time, in unix timestamp, in which a wallet has their mnemonic backup verified',
								type: 'integer',
							},
							mobile_device_type: {
								description: 'The type of device being verified',
								enum: ['APP-Android', 'APP-iOS'],
								type: 'string',
							},
							nabu: {
								description: 'Parameter about the nabu account',
								properties: {
									recovery_eligible: {
										description:
											'Whether the nabu user is eligible for recovery. Usually if account has value (> $300 or 1 payment method linked)',
										type: 'boolean',
									},
									user_id: {
										description:
											'The Nabu User ID. This is from the users table in nabu gateway',
										type: 'object',
									},
								},
								required: [],
								type: 'object',
							},
						},
						required: [],
						type: 'object',
					},
				},
				required: ['platform', 'device'],
				type: 'object',
			},
			traits: {
				type: 'object',
			},
		},
		required: ['properties'],
		title: 'Login Two Step Verification Denied',
		type: 'object',
	}
	const message = {
		event: 'Login Two Step Verification Denied',
		properties: props || {},
		options,
	}
	validateAgainstSchema(message, schema)

	const a = analytics()
	if (a) {
		a.track(
			'Login Two Step Verification Denied',
			props || {},
			withTypewriterContext(options),
			callback
		)
	}
}
/**
 * The user enters and submits the Two Factor Authentication verification code to confirm log in
 *
 * @param {LoginTwoStepVerificationEntered} props - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function loginTwoStepVerificationEntered(
	props: LoginTwoStepVerificationEntered,
	options?: Segment.Options,
	callback?: Segment.Callback
): void {
	const schema = {
		$schema: 'http://json-schema.org/draft-07/schema#',
		description:
			'The user enters and submits the Two Factor Authentication verification code to confirm log in',
		labels: {
			flow: 'sso_v1',
			source: 'client',
		},
		properties: {
			context: {},
			properties: {
				properties: {
					device: {
						description: 'Device type from where the user is trying to log in',
						enum: ['APP-Android', 'APP-iOS', 'WEB'],
						type: 'string',
					},
					exchange: {
						description: 'Parameters about the exchange account',
						properties: {
							two_fa_mode: {
								description: 'Whether the exchange account has 2FA set up',
								type: 'boolean',
							},
							user_id: {
								description: 'Exchange user credentials ID',
								type: 'string',
							},
						},
						required: [],
						type: 'object',
					},
					mergeable: {
						description: 'Indicates if possible to merge two unlinked accounts',
						type: 'boolean',
					},
					platform: {
						description: 'Platform from which the user is signing in',
						enum: ['WALLET'],
						type: 'string',
					},
					site_redirect: {
						description:
							'Whether the user is being redirected to the exchange or wallet',
						enum: ['EXCHANGE', 'WALLET'],
						type: 'string',
					},
					upgradeable: {
						description:
							'Indicates if possible to “upgrade” to a new unified Blockchain.com Account',
						type: 'boolean',
					},
					wallet: {
						description: 'Parameters about the wallet account',
						properties: {
							auth_type: {
								description: 'The wallet 2FA type that is enforced.',
								enum: [
									'0_NONE',
									'1_YUBIKEY',
									'2_EMAIL',
									'3_YUBIKEY_MTGOX',
									'4_GOOGLE_AUTHENTICATOR',
									'5_SMS',
								],
								type: 'string',
							},
							exchange: {
								description: 'Parameters about the exchange account',
								properties: {
									two_fa_mode: {
										description: 'Whether the exchange account has 2FA set up',
										properties: {},
										required: [],
										type: 'object',
									},
									user_id: {
										description: 'Exchange user credentials ID',
										type: 'object',
									},
								},
								required: [],
								type: 'object',
							},
							guid_first_four: {
								description:
									'The first four characters of the wallet.guid field',
								pattern: '^.{4,4}$',
								type: 'string',
							},
							has_cloud_backup: {
								description: 'Whether the wallet has cloud backups',
								type: 'boolean',
							},
							is_mobile_setup: {
								description: 'Whether the wallet has a mobile client set up',
								type: 'boolean',
							},
							last_mnemonic_backup: {
								description:
									'The last time, in unix timestamp, in which a wallet has their mnemonic backup verified',
								type: 'integer',
							},
							mobile_device_type: {
								description: 'The type of device being verified',
								enum: ['APP-Android', 'APP-iOS'],
								type: 'string',
							},
							nabu: {
								description: 'Parameter about the nabu account',
								properties: {
									recovery_eligible: {
										description:
											'Whether the nabu user is eligible for recovery. Usually if account has value (> $300 or 1 payment method linked)',
										type: 'boolean',
									},
									user_id: {
										description:
											'The Nabu User ID. This is from the users table in nabu gateway',
										type: 'object',
									},
								},
								required: [],
								type: 'object',
							},
						},
						required: [],
						type: 'object',
					},
				},
				required: ['platform', 'device'],
				type: 'object',
			},
			traits: {
				type: 'object',
			},
		},
		required: ['properties'],
		title: 'Login Two Step Verification Entered',
		type: 'object',
	}
	const message = {
		event: 'Login Two Step Verification Entered',
		properties: props || {},
		options,
	}
	validateAgainstSchema(message, schema)

	const a = analytics()
	if (a) {
		a.track(
			'Login Two Step Verification Entered',
			props || {},
			withTypewriterContext(options),
			callback
		)
	}
}
/**
 * User clicks on the Blockchain.com logo
 *
 * @param {LogoClicked} [props] - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function logoClicked(
	props?: LogoClicked,
	options?: Segment.Options,
	callback?: Segment.Callback
): void {
	const schema = {
		$schema: 'http://json-schema.org/draft-07/schema#',
		description: 'User clicks on the Blockchain.com logo',
		labels: {
			flow: ['explorer', 'dot_com'],
			source: 'client',
		},
		properties: {
			context: {},
			properties: {
				properties: {
					device: {
						description: 'Device type from where the event was triggered.',
						enum: ['APP-iOS', 'WEB', 'APP-Android'],
						type: 'string',
					},
					platform: {
						description: 'What platform the user is clicking from',
						enum: ['DOT_COM', 'EXCHANGE', 'EXPLORER', 'WALLET'],
						type: 'string',
					},
				},
				required: ['device', 'platform'],
				type: 'object',
			},
			traits: {
				type: 'object',
			},
		},
		title: 'Logo Clicked',
		type: 'object',
	}
	const message = {
		event: 'Logo Clicked',
		properties: props || {},
		options,
	}
	validateAgainstSchema(message, schema)

	const a = analytics()
	if (a) {
		a.track(
			'Logo Clicked',
			props || {},
			withTypewriterContext(options),
			callback
		)
	}
}
/**
 * Option selected from the drop down menu From the Bitcoin or the Bitcoin Cash tab.
 *
 * @param {ManageTabSelectionClicked} props - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function manageTabSelectionClicked(
	props: ManageTabSelectionClicked,
	options?: Segment.Options,
	callback?: Segment.Callback
): void {
	const schema = {
		$schema: 'http://json-schema.org/draft-07/schema#',
		description:
			'Option selected from the drop down menu From the Bitcoin or the Bitcoin Cash tab.',
		labels: {
			flow: 'settings_v1',
			source: 'client',
		},
		properties: {
			context: {},
			properties: {
				properties: {
					currency: {
						description:
							'From which currency tab was the event activated. BTC or BCH',
						enum: ['BCH', 'BTC'],
						type: 'string',
					},
					device: {
						description: 'Device type from where the event was triggered.',
						enum: ['WEB'],
						type: 'string',
					},
					platform: {
						description: 'From what platform the user is using the Settings',
						enum: ['EXCHANGE', 'WALLET'],
						type: 'string',
					},
					selection: {
						description:
							'Example: "Show xPub".  Note: "Recover Funds" option only available for Bitcoin Cash drop down menu. ',
						enum: [
							'EDIT_WALLET_NAME',
							'RECOVER_FUNDS',
							'SHOW_CHANGE_ADDRESSES',
							'SHOW_XPUB',
						],
						type: 'string',
					},
				},
				required: ['selection', 'currency', 'device', 'platform'],
				type: 'object',
			},
			traits: {
				type: 'object',
			},
		},
		required: ['properties'],
		title: 'Manage Tab Selection Clicked',
		type: 'object',
	}
	const message = {
		event: 'Manage Tab Selection Clicked',
		properties: props || {},
		options,
	}
	validateAgainstSchema(message, schema)

	const a = analytics()
	if (a) {
		a.track(
			'Manage Tab Selection Clicked',
			props || {},
			withTypewriterContext(options),
			callback
		)
	}
}
/**
 * The Verification for the tier has been sent but requires further manual checks before the user can proceed
 *
 * @param {ManualVerificationRequired} props - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function manualVerificationRequired(
	props: ManualVerificationRequired,
	options?: Segment.Options,
	callback?: Segment.Callback
): void {
	const schema = {
		$schema: 'http://json-schema.org/draft-07/schema#',
		description:
			'The Verification for the tier has been sent but requires further manual checks before the user can proceed',
		labels: {
			flow: ['onboarding_v1', 'settings_v1'],
			source: 'backend',
		},
		properties: {
			context: {},
			properties: {
				properties: {
					platform: {
						description:
							'What platform the verification was started from. (WALLET if product=SWAP and EXCHANGE if product=MERCURY in the  kyc verification table from nabu gateway)',
						enum: ['EXCHANGE', 'WALLET'],
						type: 'string',
					},
					provider: {
						description: 'BLOCKCHAIN or VERIFF',
						enum: ['BLOCKCHAIN', 'VERIFF'],
						type: 'string',
					},
					tier: {
						description:
							'What tier the user is trying to update to. 1 = Silver, 2 = Gold, 3 = SDD, 4 = SDD +, 5 = Platinium',
						type: 'integer',
					},
				},
				required: ['tier', 'platform', 'provider'],
				type: 'object',
			},
			traits: {
				type: 'object',
			},
		},
		required: ['properties'],
		title: 'Manual Verification Required',
		type: 'object',
	}
	const message = {
		event: 'Manual Verification Required',
		properties: props || {},
		options,
	}
	validateAgainstSchema(message, schema)

	const a = analytics()
	if (a) {
		a.track(
			'Manual Verification Required',
			props || {},
			withTypewriterContext(options),
			callback
		)
	}
}
/**
 * User clicks on a button to add or remove collateral. This button opens the form to start filling the margin collateral amount
 *
 * @param {MarginCollateralClicked} props - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function marginCollateralClicked(
	props: MarginCollateralClicked,
	options?: Segment.Options,
	callback?: Segment.Callback
): void {
	const schema = {
		$schema: 'http://json-schema.org/draft-07/schema#',
		description:
			'User clicks on a button to add or remove collateral. This button opens the form to start filling the margin collateral amount',
		labels: {
			flow: ['trade_e1', 'margin'],
			source: 'client',
		},
		properties: {
			context: {},
			properties: {
				properties: {
					device: {
						description: 'From what device the user is adding collateral',
						enum: ['APP-Android', 'APP-iOS', 'WEB'],
						type: 'string',
					},
					pair: {
						description: 'What is the trading pair of the position',
						pattern: '^[A-Z]{3,5}-[A-Z]{3,5}$',
						type: 'string',
					},
					platform: {
						description: 'From what platform the user is adding collateral',
						enum: ['EXCHANGE'],
						type: 'string',
					},
					position_id: {
						description:
							'Id of the margin position for which the collateral is being added/removed',
						type: 'string',
					},
				},
				required: ['pair', 'platform'],
				type: 'object',
			},
			traits: {
				type: 'object',
			},
		},
		required: ['properties'],
		title: 'Margin Collateral Clicked',
		type: 'object',
	}
	const message = {
		event: 'Margin Collateral Clicked',
		properties: props || {},
		options,
	}
	validateAgainstSchema(message, schema)

	const a = analytics()
	if (a) {
		a.track(
			'Margin Collateral Clicked',
			props || {},
			withTypewriterContext(options),
			callback
		)
	}
}
/**
 * User updated the collateral amount to of a margin position.
 *
 * @param {MarginCollateralUpdated} props - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function marginCollateralUpdated(
	props: MarginCollateralUpdated,
	options?: Segment.Options,
	callback?: Segment.Callback
): void {
	const schema = {
		$schema: 'http://json-schema.org/draft-07/schema#',
		description: 'User updated the collateral amount to of a margin position.',
		labels: {
			flow: ['trade_e1', 'margin'],
			source: 'client',
		},
		properties: {
			context: {},
			properties: {
				properties: {
					action: {
						description: 'Whether add or remove collateral',
						enum: ['ADD', 'REMOVE'],
						type: 'string',
					},
					amount: {
						description: 'The amount of collateral to be added or removed.  ',
						type: 'number',
					},
					currency: {
						description:
							'what collateral currency the user is adding or removing',
						pattern: '^[A-Z]{3,5}$',
						type: 'string',
					},
					device: {
						description: 'From what device the user is adding collateral',
						enum: ['APP-Android', 'APP-iOS', 'WEB'],
						type: 'string',
					},
					gw_order_id: {
						description:
							'Id of the gateway order created to add/remove the collateral',
						type: 'string',
					},
					pair: {
						description: 'What is the trading pair of the position',
						pattern: '^[A-Z]{3,5}-[A-Z]{3,5}$',
						type: 'string',
					},
					platform: {
						description: 'From what platform the user is adding collateral',
						enum: ['EXCHANGE'],
						type: 'string',
					},
					position_id: {
						description:
							'Id of the position for which the collateral is being added/removed',
						type: 'string',
					},
				},
				required: ['currency', 'pair', 'action', 'amount', 'platform'],
				type: 'object',
			},
			traits: {
				type: 'object',
			},
		},
		required: ['properties'],
		title: 'Margin Collateral Updated',
		type: 'object',
	}
	const message = {
		event: 'Margin Collateral Updated',
		properties: props || {},
		options,
	}
	validateAgainstSchema(message, schema)

	const a = analytics()
	if (a) {
		a.track(
			'Margin Collateral Updated',
			props || {},
			withTypewriterContext(options),
			callback
		)
	}
}
/**
 * User canceled margin order
 *
 * @param {MarginOrderCancelled} props - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function marginOrderCancelled(
	props: MarginOrderCancelled,
	options?: Segment.Options,
	callback?: Segment.Callback
): void {
	const schema = {
		$schema: 'http://json-schema.org/draft-07/schema#',
		description: 'User canceled margin order',
		labels: {
			flow: ['trade_e1', 'margin'],
			source: 'client',
		},
		properties: {
			context: {},
			properties: {
				properties: {
					amount: {
						description: 'The amount of the order.  ',
						type: 'number',
					},
					device: {
						description: 'Device type from where the event was triggered',
						enum: ['APP-Android', 'APP-iOS', 'WEB', 'WEB-Mob'],
						type: 'string',
					},
					pair: {
						description: 'What is the trading pair of the position',
						pattern: '^[A-Z]{3,5}-[A-Z]{3,5}$',
						type: 'string',
					},
					platform: {
						description: 'From what platform the event is triggered\n',
						enum: ['EXCHANGE'],
						type: 'string',
					},
					trade_type: {
						description: 'what type of trade',
						enum: ['LIMIT', 'MARKET'],
						type: 'string',
					},
				},
				required: ['pair', 'amount', 'trade_type', 'platform', 'device'],
				type: 'object',
			},
			traits: {
				type: 'object',
			},
		},
		required: ['properties'],
		title: 'Margin Order Cancelled',
		type: 'object',
	}
	const message = {
		event: 'Margin Order Cancelled',
		properties: props || {},
		options,
	}
	validateAgainstSchema(message, schema)

	const a = analytics()
	if (a) {
		a.track(
			'Margin Order Cancelled',
			props || {},
			withTypewriterContext(options),
			callback
		)
	}
}
/**
 * The user submits a margin order.
 *
 * @param {MarginOrderSubmitted} props - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function marginOrderSubmitted(
	props: MarginOrderSubmitted,
	options?: Segment.Options,
	callback?: Segment.Callback
): void {
	const schema = {
		$schema: 'http://json-schema.org/draft-07/schema#',
		description: 'The user submits a margin order.',
		labels: {
			flow: ['margin', 'trade_e1'],
			source: 'client',
		},
		properties: {
			context: {},
			properties: {
				properties: {
					device: {
						description:
							'What device the user is using. Only available for WEB for now.',
						enum: ['WEB'],
						type: 'string',
					},
					input_amount: {
						description: 'Amount of the trade in input currency',
						type: 'number',
					},
					leverage_ratio: {
						description: 'leverage ratio',
						type: 'number',
					},
					limit_price: {
						description: 'Limit price of the trade (empty for market orders)\n',
						type: 'number',
					},
					pair: {
						description: 'The trading instrument',
						pattern: '^[A-Z]{3,5}-[A-Z]{3,5}$',
						type: 'string',
					},
					platform: {
						description:
							'What platform offers leverage (EXCHANGE only for now)',
						enum: ['EXCHANGE'],
						type: 'string',
					},
					side: {
						description:
							'What side is selected when the leverage button is clicked. BUY when it says "Buy With Leverage" and SELL when it says "Sell With Leverage"',
						enum: ['BUY', 'SELL'],
						type: 'string',
					},
					trade_type: {
						description: 'what type of trade',
						enum: ['LIMIT', 'MARKET'],
						type: 'string',
					},
				},
				required: [
					'platform',
					'trade_type',
					'leverage_ratio',
					'input_amount',
					'pair',
					'device',
					'side',
				],
				type: 'object',
			},
			traits: {
				type: 'object',
			},
		},
		required: ['properties'],
		title: 'Margin Order Submitted',
		type: 'object',
	}
	const message = {
		event: 'Margin Order Submitted',
		properties: props || {},
		options,
	}
	validateAgainstSchema(message, schema)

	const a = analytics()
	if (a) {
		a.track(
			'Margin Order Submitted',
			props || {},
			withTypewriterContext(options),
			callback
		)
	}
}
/**
 * The user closes an open margin position.
 *
 * @param {MarginPositionClosed} props - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function marginPositionClosed(
	props: MarginPositionClosed,
	options?: Segment.Options,
	callback?: Segment.Callback
): void {
	const schema = {
		$schema: 'http://json-schema.org/draft-07/schema#',
		description: 'The user closes an open margin position.',
		labels: {
			flow: ['trade_e1', 'margin'],
			source: 'client',
		},
		properties: {
			context: {},
			properties: {
				properties: {
					amount: {
						description:
							'The amount of the order placed to close a margin position.',
						type: 'number',
					},
					device: {
						description: 'From what device the user is adding collateral',
						enum: ['APP-Android', 'APP-iOS', 'WEB'],
						type: 'string',
					},
					limit_price: {
						description:
							'The limit price when the position closes with a limit order.',
						type: 'number',
					},
					order_type: {
						description:
							'The type of the order placed to close a margin position.',
						enum: ['LIMIT', 'MARKET'],
						type: 'string',
					},
					platform: {
						description: 'From what platform the user is adding collateral',
						enum: ['EXCHANGE'],
						type: 'string',
					},
					position_id: {
						description:
							'Id of the margin position for which the collateral is being added/removed',
						type: 'object',
					},
				},
				required: ['amount', 'platform', 'order_type'],
				type: 'object',
			},
			traits: {
				type: 'object',
			},
		},
		required: ['properties'],
		title: 'Margin Position Closed',
		type: 'object',
	}
	const message = {
		event: 'Margin Position Closed',
		properties: props || {},
		options,
	}
	validateAgainstSchema(message, schema)

	const a = analytics()
	if (a) {
		a.track(
			'Margin Position Closed',
			props || {},
			withTypewriterContext(options),
			callback
		)
	}
}
/**
 * The user performed an action after the margin waitlist invite is shown.
 *
 * @param {MarginWaitlistActioned} props - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function marginWaitlistActioned(
	props: MarginWaitlistActioned,
	options?: Segment.Options,
	callback?: Segment.Callback
): void {
	const schema = {
		$schema: 'http://json-schema.org/draft-07/schema#',
		description:
			'The user performed an action after the margin waitlist invite is shown.',
		labels: {
			flow: 'margin',
			source: 'client',
		},
		properties: {
			context: {},
			properties: {
				properties: {
					action: {
						description:
							'What action the user performed when shown the Margin waitlist announcement. JOINED : Clicked on a button to join. DISMISSED : clicked anywhere else on the screen or clicks on the small cross to close the announcement',
						enum: ['DISMISSED', 'JOINED'],
						type: 'string',
					},
					device: {
						description: 'What device is used to action on the announcement',
						enum: ['WEB'],
						type: 'string',
					},
					platform: {
						description: 'What platform the user is on : EXCHANGE',
						enum: ['EXCHANGE'],
						type: 'string',
					},
				},
				required: ['device', 'platform', 'action'],
				type: 'object',
			},
			traits: {
				type: 'object',
			},
		},
		required: ['properties'],
		title: 'Margin Waitlist Actioned',
		type: 'object',
	}
	const message = {
		event: 'Margin Waitlist Actioned',
		properties: props || {},
		options,
	}
	validateAgainstSchema(message, schema)

	const a = analytics()
	if (a) {
		a.track(
			'Margin Waitlist Actioned',
			props || {},
			withTypewriterContext(options),
			callback
		)
	}
}
/**
 * The user is shown an announcement to join the margin waitlist
 *
 * @param {MarginWaitlistShown} props - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function marginWaitlistShown(
	props: MarginWaitlistShown,
	options?: Segment.Options,
	callback?: Segment.Callback
): void {
	const schema = {
		$schema: 'http://json-schema.org/draft-07/schema#',
		description:
			'The user is shown an announcement to join the margin waitlist',
		labels: {
			flow: 'margin',
			source: 'client',
		},
		properties: {
			context: {},
			properties: {
				properties: {
					device: {
						description: 'What device the announcement is shown on',
						enum: ['WEB'],
						type: 'string',
					},
					platform: {
						description: 'What platform the user is on : EXCHANGE',
						enum: ['EXCHANGE'],
						type: 'string',
					},
				},
				required: ['device', 'platform'],
				type: 'object',
			},
			traits: {
				type: 'object',
			},
		},
		required: ['properties'],
		title: 'Margin Waitlist Shown',
		type: 'object',
	}
	const message = {
		event: 'Margin Waitlist Shown',
		properties: props || {},
		options,
	}
	validateAgainstSchema(message, schema)

	const a = analytics()
	if (a) {
		a.track(
			'Margin Waitlist Shown',
			props || {},
			withTypewriterContext(options),
			callback
		)
	}
}
/**
 * The mobile app install screen is updated to display the instructions for another device. This is done via the toggle button
 *
 * @param {MobileAppInstallDeviceUpdated} props - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function mobileAppInstallDeviceUpdated(
	props: MobileAppInstallDeviceUpdated,
	options?: Segment.Options,
	callback?: Segment.Callback
): void {
	const schema = {
		$schema: 'http://json-schema.org/draft-07/schema#',
		description:
			'The mobile app install screen is updated to display the instructions for another device. This is done via the toggle button',
		labels: {
			flow: 'exchange2app',
			source: 'client',
		},
		properties: {
			context: {},
			properties: {
				properties: {
					device: {
						description: 'Device type from where the event was triggered.',
						enum: ['WEB'],
						type: 'string',
					},
					device_app: {
						description:
							'Whether the device was updated to view APP-Android or APP-iOS instructions',
						enum: ['APP-Android', 'APP-iOS'],
						type: 'string',
					},
					platform: {
						description: 'What platform the user is clicking from',
						enum: ['EXCHANGE'],
						type: 'string',
					},
				},
				required: ['platform', 'device', 'device_app'],
				type: 'object',
			},
			traits: {
				type: 'object',
			},
		},
		required: ['properties'],
		title: 'Mobile App Install Device Updated',
		type: 'object',
	}
	const message = {
		event: 'Mobile App Install Device Updated',
		properties: props || {},
		options,
	}
	validateAgainstSchema(message, schema)

	const a = analytics()
	if (a) {
		a.track(
			'Mobile App Install Device Updated',
			props || {},
			withTypewriterContext(options),
			callback
		)
	}
}
/**
 * The mobile app icon to install the app is clicked. This button can be found for example in the exchange header
 *
 * @param {MobileAppInstallIconClicked} props - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function mobileAppInstallIconClicked(
	props: MobileAppInstallIconClicked,
	options?: Segment.Options,
	callback?: Segment.Callback
): void {
	const schema = {
		$schema: 'http://json-schema.org/draft-07/schema#',
		description:
			'The mobile app icon to install the app is clicked. This button can be found for example in the exchange header',
		labels: {
			flow: 'exchange2app',
			source: 'client',
		},
		properties: {
			context: {},
			properties: {
				properties: {
					device: {
						description: 'Device type from where the event was triggered.',
						enum: ['WEB'],
						type: 'string',
					},
					platform: {
						description: 'What platform the user is clicking from',
						enum: ['EXCHANGE'],
						type: 'string',
					},
				},
				required: ['platform', 'device'],
				type: 'object',
			},
			traits: {
				type: 'object',
			},
		},
		required: ['properties'],
		title: 'Mobile App Install Icon Clicked',
		type: 'object',
	}
	const message = {
		event: 'Mobile App Install Icon Clicked',
		properties: props || {},
		options,
	}
	validateAgainstSchema(message, schema)

	const a = analytics()
	if (a) {
		a.track(
			'Mobile App Install Icon Clicked',
			props || {},
			withTypewriterContext(options),
			callback
		)
	}
}
/**
 * The mobile app icon to install the app is clicked. This button can be found for example in the exchange header
 *
 * @param {MobileAppInstallLinkCopied} props - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function mobileAppInstallLinkCopied(
	props: MobileAppInstallLinkCopied,
	options?: Segment.Options,
	callback?: Segment.Callback
): void {
	const schema = {
		$schema: 'http://json-schema.org/draft-07/schema#',
		description:
			'The mobile app icon to install the app is clicked. This button can be found for example in the exchange header',
		labels: {
			flow: 'exchange2app',
			source: 'client',
		},
		properties: {
			context: {},
			properties: {
				properties: {
					device: {
						description: 'Device type from where the event was triggered.',
						enum: ['WEB'],
						type: 'string',
					},
					device_app: {
						description:
							'Whether the copied app link is APP-iOS or APP-Android',
						enum: ['APP-Android', 'APP-iOS'],
						type: 'string',
					},
					platform: {
						description: 'What platform the user is clicking from',
						enum: ['EXCHANGE'],
						type: 'string',
					},
				},
				required: ['platform', 'device', 'device_app'],
				type: 'object',
			},
			traits: {
				type: 'object',
			},
		},
		required: ['properties'],
		title: 'Mobile App Install Link Copied',
		type: 'object',
	}
	const message = {
		event: 'Mobile App Install Link Copied',
		properties: props || {},
		options,
	}
	validateAgainstSchema(message, schema)

	const a = analytics()
	if (a) {
		a.track(
			'Mobile App Install Link Copied',
			props || {},
			withTypewriterContext(options),
			callback
		)
	}
}
/**
 * The Mobile Number was succesfully verified.
 *
 * @param {MobileNumberVerified} props - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function mobileNumberVerified(
	props: MobileNumberVerified,
	options?: Segment.Options,
	callback?: Segment.Callback
): void {
	const schema = {
		$schema: 'http://json-schema.org/draft-07/schema#',
		description: 'The Mobile Number was succesfully verified.',
		labels: {
			flow: ['settings_v1', 'security_v1'],
			source: 'backend',
		},
		properties: {
			context: {},
			properties: {
				properties: {
					country_code: {
						description: 'country of the mobile number, in alpha iso 2 code.',
						pattern: '^[A-Z]{2}$',
						type: 'string',
					},
					device: {
						description: 'Device type from where the event was triggered.',
						enum: ['APP-iOS', 'WEB', 'APP-Android'],
						type: 'string',
					},
					origin: {
						description:
							'From which page are they verifying the Mobile Number? Settings or Security',
						enum: ['SECURITY', 'SETTINGS'],
						type: 'string',
					},
					platform: {
						description: 'From what platform the user is using the Settings',
						enum: ['EXCHANGE', 'WALLET'],
						type: 'string',
					},
				},
				required: ['platform', 'origin', 'country_code'],
				type: 'object',
			},
			traits: {
				type: 'object',
			},
		},
		required: ['properties'],
		title: 'Mobile Number Verified',
		type: 'object',
	}
	const message = {
		event: 'Mobile Number Verified',
		properties: props || {},
		options,
	}
	validateAgainstSchema(message, schema)

	const a = analytics()
	if (a) {
		a.track(
			'Mobile Number Verified',
			props || {},
			withTypewriterContext(options),
			callback
		)
	}
}
/**
 * User changed the mobile pin code.
 *
 * @param {MobilePinCodeChanged} props - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function mobilePinCodeChanged(
	props: MobilePinCodeChanged,
	options?: Segment.Options,
	callback?: Segment.Callback
): void {
	const schema = {
		$schema: 'http://json-schema.org/draft-07/schema#',
		description: 'User changed the mobile pin code.',
		labels: {
			flow: 'security_v1',
			source: 'client',
		},
		properties: {
			context: {},
			properties: {
				properties: {
					device: {
						description: 'Device type from where the event was triggered.',
						enum: ['APP-iOS', 'WEB', 'APP-Android'],
						type: 'string',
					},
					platform: {
						description:
							'From what platform the user is managing Security events',
						enum: ['WALLET'],
						type: 'string',
					},
				},
				required: ['platform', 'device'],
				type: 'object',
			},
			traits: {
				type: 'object',
			},
		},
		required: ['properties'],
		title: 'Mobile Pin Code Changed',
		type: 'object',
	}
	const message = {
		event: 'Mobile Pin Code Changed',
		properties: props || {},
		options,
	}
	validateAgainstSchema(message, schema)

	const a = analytics()
	if (a) {
		a.track(
			'Mobile Pin Code Changed',
			props || {},
			withTypewriterContext(options),
			callback
		)
	}
}
/**
 * More NFTs button clicked
 *
 * @param {MoreNftClicked} props - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function moreNftClicked(
	props: MoreNftClicked,
	options?: Segment.Options,
	callback?: Segment.Callback
): void {
	const schema = {
		$schema: 'http://json-schema.org/draft-07/schema#',
		description: 'More NFTs button clicked',
		labels: {
			flow: 'explorer',
			source: 'client',
		},
		properties: {
			context: {},
			properties: {
				properties: {
					'': {
						description: '',
						type: 'object',
					},
					device: {
						description: 'What device the event is tracked from',
						enum: ['WEB'],
						type: 'string',
					},
					platform: {
						description: 'What platform the event is referring to',
						enum: ['EXPLORER'],
						type: 'string',
					},
				},
				required: ['platform', 'device'],
				type: 'object',
			},
			traits: {
				type: 'object',
			},
		},
		required: ['properties'],
		title: 'More NFT Clicked',
		type: 'object',
	}
	const message = {
		event: 'More NFT Clicked',
		properties: props || {},
		options,
	}
	validateAgainstSchema(message, schema)

	const a = analytics()
	if (a) {
		a.track(
			'More NFT Clicked',
			props || {},
			withTypewriterContext(options),
			callback
		)
	}
}
/**
 * button inside a NFT card which redirects the user to Opensea (CREATOR, OWNER OR COLLECTION). Opeansea LOGO redirects to opensea.  ASSET when the user clicks the nft card
 *
 * @param {NftHyperlinkClicked} props - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function nftHyperlinkClicked(
	props: NftHyperlinkClicked,
	options?: Segment.Options,
	callback?: Segment.Callback
): void {
	const schema = {
		$schema: 'http://json-schema.org/draft-07/schema#',
		description:
			'button inside a NFT card which redirects the user to Opensea (CREATOR, OWNER OR COLLECTION). Opeansea LOGO redirects to opensea.  ASSET when the user clicks the nft card',
		labels: {
			flow: 'explorer',
			source: 'client',
		},
		properties: {
			context: {},
			properties: {
				properties: {
					'': {
						description: '',
						type: 'object',
					},
					device: {
						description: 'What device the event is tracked from',
						enum: ['WEB'],
						type: 'string',
					},
					item: {
						description: 'What item is clicked on the navigation header',
						enum: ['ASSET', 'COLLECTION', 'CREATOR', 'LOGO', 'OWNER'],
						type: 'string',
					},
					platform: {
						description: 'What platform the event is referring to',
						enum: ['EXPLORER'],
						type: 'string',
					},
				},
				required: ['item', 'platform', 'device'],
				type: 'object',
			},
			traits: {
				type: 'object',
			},
		},
		required: ['properties'],
		title: 'NFT Hyperlink Clicked',
		type: 'object',
	}
	const message = {
		event: 'NFT Hyperlink Clicked',
		properties: props || {},
		options,
	}
	validateAgainstSchema(message, schema)

	const a = analytics()
	if (a) {
		a.track(
			'NFT Hyperlink Clicked',
			props || {},
			withTypewriterContext(options),
			callback
		)
	}
}
/**
 * User has opened the buy NFT order form, showing intent to purchase NFT.
 *
 * @param {NftOrderCreated} props - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function nftOrderCreated(
	props: NftOrderCreated,
	options?: Segment.Options,
	callback?: Segment.Callback
): void {
	const schema = {
		$schema: 'http://json-schema.org/draft-07/schema#',
		description:
			'User has opened the buy NFT order form, showing intent to purchase NFT.',
		labels: {
			flow: 'nft',
			source: 'client',
		},
		properties: {
			context: {},
			properties: {
				properties: {
					device: {
						description: 'What device the nft order ',
						enum: ['APP-Android', 'APP-iOS', 'WEB'],
						type: 'string',
					},
					platform: {
						description: 'what platform the nft order was from. Only in WALLET',
						enum: ['WALLET'],
						type: 'string',
					},
				},
				required: ['device', 'platform'],
				type: 'object',
			},
			traits: {
				type: 'object',
			},
		},
		required: ['properties'],
		title: 'NFT Order Created ',
		type: 'object',
	}
	const message = {
		event: 'NFT Order Created ',
		properties: props || {},
		options,
	}
	validateAgainstSchema(message, schema)

	const a = analytics()
	if (a) {
		a.track(
			'NFT Order Created ',
			props || {},
			withTypewriterContext(options),
			callback
		)
	}
}
/**
 * An NFT buy order failed, either because of a wallet error, or an opensea api failure.
 *
 * @param {NftOrderFailed} props - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function nftOrderFailed(
	props: NftOrderFailed,
	options?: Segment.Options,
	callback?: Segment.Callback
): void {
	const schema = {
		$schema: 'http://json-schema.org/draft-07/schema#',
		description:
			'An NFT buy order failed, either because of a wallet error, or an opensea api failure.',
		labels: {
			flow: 'nft',
			source: 'client',
		},
		properties: {
			context: {},
			properties: {
				properties: {
					device: {
						description: 'What device the nft order ',
						enum: ['APP-Android', 'APP-iOS', 'WEB'],
						type: 'string',
					},
					platform: {
						description: 'what platform the nft order was from. Only in WALLET',
						enum: ['WALLET'],
						type: 'string',
					},
				},
				required: ['device', 'platform'],
				type: 'object',
			},
			traits: {
				type: 'object',
			},
		},
		required: ['properties'],
		title: 'NFT Order Failed',
		type: 'object',
	}
	const message = {
		event: 'NFT Order Failed',
		properties: props || {},
		options,
	}
	validateAgainstSchema(message, schema)

	const a = analytics()
	if (a) {
		a.track(
			'NFT Order Failed',
			props || {},
			withTypewriterContext(options),
			callback
		)
	}
}
/**
 * An NFT order has been successfully sent
 *
 * @param {NftOrderSucceeded} props - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function nftOrderSucceeded(
	props: NftOrderSucceeded,
	options?: Segment.Options,
	callback?: Segment.Callback
): void {
	const schema = {
		$schema: 'http://json-schema.org/draft-07/schema#',
		description: 'An NFT order has been successfully sent',
		labels: {
			flow: 'nft',
			source: 'client',
		},
		properties: {
			context: {},
			properties: {
				properties: {
					device: {
						description: 'What device the nft order ',
						enum: ['APP-Android', 'APP-iOS', 'WEB'],
						type: 'string',
					},
					platform: {
						description: 'what platform the nft order was from. Only in WALLET',
						enum: ['WALLET'],
						type: 'string',
					},
				},
				required: ['device', 'platform'],
				type: 'object',
			},
			traits: {
				type: 'object',
			},
		},
		required: ['properties'],
		title: 'NFT Order Succeeded',
		type: 'object',
	}
	const message = {
		event: 'NFT Order Succeeded',
		properties: props || {},
		options,
	}
	validateAgainstSchema(message, schema)

	const a = analytics()
	if (a) {
		a.track(
			'NFT Order Succeeded',
			props || {},
			withTypewriterContext(options),
			callback
		)
	}
}
/**
 * An item of the navigation breadcrumbs is clicked
 *
 * @param {NavigationBreadcrumbsClicked} props - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function navigationBreadcrumbsClicked(
	props: NavigationBreadcrumbsClicked,
	options?: Segment.Options,
	callback?: Segment.Callback
): void {
	const schema = {
		$schema: 'http://json-schema.org/draft-07/schema#',
		description: 'An item of the navigation breadcrumbs is clicked',
		labels: {
			flow: 'explorer',
			source: 'client',
		},
		properties: {
			context: {},
			properties: {
				properties: {
					device: {
						description: 'What device the event is tracked from',
						enum: ['WEB'],
						type: 'string',
					},
					item: {
						description: 'What item is clicked on the navigation header',
						enum: ['BCH_EXPLORER', 'BTC_EXPLORER', 'ETH_EXPLORER'],
						type: 'string',
					},
					platform: {
						description: 'What platform the event is referring to',
						enum: ['EXPLORER'],
						type: 'string',
					},
					sub_item: {
						description:
							'What sub item in the breadcrumb is clicked on. NONE if the user clicks on the first level item',
						enum: [
							'BITCOIN',
							'BITCOIN_CASH',
							'BITCOIN_CASH_TESTNET',
							'BITCOIN_TESTNET',
							'DEFI',
							'ETHEREUM',
							'NFT',
							'NONE',
							'PRICES',
						],
						type: 'string',
					},
				},
				required: ['item', 'platform', 'device', 'sub_item'],
				type: 'object',
			},
			traits: {
				type: 'object',
			},
		},
		required: ['properties'],
		title: 'Navigation Breadcrumbs Clicked',
		type: 'object',
	}
	const message = {
		event: 'Navigation Breadcrumbs Clicked',
		properties: props || {},
		options,
	}
	validateAgainstSchema(message, schema)

	const a = analytics()
	if (a) {
		a.track(
			'Navigation Breadcrumbs Clicked',
			props || {},
			withTypewriterContext(options),
			callback
		)
	}
}
/**
 * An item of the navigation header  is clicked
 *
 * @param {NavigationOptionClicked} props - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function navigationOptionClicked(
	props: NavigationOptionClicked,
	options?: Segment.Options,
	callback?: Segment.Callback
): void {
	const schema = {
		$schema: 'http://json-schema.org/draft-07/schema#',
		description: 'An item of the navigation header  is clicked',
		labels: {
			flow: ['explorer', 'dot_com'],
			source: 'client',
		},
		properties: {
			context: {},
			properties: {
				properties: {
					device: {
						description: 'What device the event is tracked from',
						enum: ['WEB'],
						type: 'string',
					},
					item: {
						description:
							'What item is clicked on the navigation header. Explorer: NONE since it has only one level (old navigation bar). Wallet: OVERVIEW, KEYS, SECURITY. Exchange: FEATURES, FEES, MARKETS, PRIME, AFFILIATE, API',
						enum: [
							'AFFILIATE',
							'API',
							'BUY_BITCOIN',
							'EXCHANGE',
							'EXPLORER',
							'FEATURES',
							'FEES',
							'KEYS',
							'LOG_IN',
							'MARKETS',
							'OVERVIEW',
							'PRIME',
							'SECURITY',
							'SIGN_UP',
							'TRADE',
							'WALLET',
						],
						type: 'string',
					},
					platform: {
						description: 'What platform the event is referring to',
						enum: ['BLOCKCHAIN_COM', 'EXCHANGE', 'EXPLORER', 'WALLET'],
						type: 'string',
					},
					sub_item: {
						description: 'What sub item in the dropdown menu was clicked',
						enum: [
							'APIS',
							'BLOG',
							'CAREERS',
							'CHARTS',
							'COMPANY',
							'EXCHANGE',
							'EXPLORER',
							'INSTITUTIONAL',
							'LEARN',
							'OPEN_SOURCE',
							'PRESS_CENTER',
							'PRICES',
							'PRIME',
							'PRIVACY',
							'RESEARCH',
							'STATUS',
							'SUPPORT',
							'VENTURES',
							'WALLET',
						],
						type: 'string',
					},
				},
				required: ['platform', 'device'],
				type: 'object',
			},
			traits: {
				type: 'object',
			},
		},
		required: ['properties'],
		title: 'Navigation Option Clicked',
		type: 'object',
	}
	const message = {
		event: 'Navigation Option Clicked',
		properties: props || {},
		options,
	}
	validateAgainstSchema(message, schema)

	const a = analytics()
	if (a) {
		a.track(
			'Navigation Option Clicked',
			props || {},
			withTypewriterContext(options),
			callback
		)
	}
}
/**
 * Bitcoin address added to the addresses list.
 *
 * @param {NextAddressAdded} props - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function nextAddressAdded(
	props: NextAddressAdded,
	options?: Segment.Options,
	callback?: Segment.Callback
): void {
	const schema = {
		$schema: 'http://json-schema.org/draft-07/schema#',
		description: 'Bitcoin address added to the addresses list.',
		labels: {
			flow: 'settings_v1',
			source: 'backend',
		},
		properties: {
			context: {},
			properties: {
				properties: {
					currency: {
						description: '',
						pattern: '^[A-Z]{3,5}$',
						type: 'string',
					},
					device: {
						description: 'Device type from where the event was triggered.',
						enum: ['APP-iOS', 'WEB', 'APP-Android'],
						type: 'string',
					},
					platform: {
						description: 'From what platform the user is using the Settings',
						enum: ['EXCHANGE', 'WALLET'],
						type: 'string',
					},
					transaction_format: {
						description: 'Segwit format or Legacy format',
						enum: ['LEGACY', 'SEGWIT'],
						type: 'string',
					},
				},
				required: ['currency', 'platform', 'transaction_format'],
				type: 'object',
			},
			traits: {
				type: 'object',
			},
		},
		required: ['properties'],
		title: 'Next Address Added',
		type: 'object',
	}
	const message = {
		event: 'Next Address Added',
		properties: props || {},
		options,
	}
	validateAgainstSchema(message, schema)

	const a = analytics()
	if (a) {
		a.track(
			'Next Address Added',
			props || {},
			withTypewriterContext(options),
			callback
		)
	}
}
/**
 * User updates whether they prefer email, SMS or both for notifications
 *
 * @param {NotificationPreferencesUpdated} props - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function notificationPreferencesUpdated(
	props: NotificationPreferencesUpdated,
	options?: Segment.Options,
	callback?: Segment.Callback
): void {
	const schema = {
		$schema: 'http://json-schema.org/draft-07/schema#',
		description:
			'User updates whether they prefer email, SMS or both for notifications',
		labels: {
			flow: 'settings_v1',
			source: 'client',
		},
		properties: {
			context: {},
			properties: {
				properties: {
					device: {
						description: 'Device type from where the event was triggered.',
						enum: ['APP-iOS', 'WEB', 'APP-Android'],
						type: 'string',
					},
					email_enabled: {
						description:
							'Whether email notifications is enabled (Only available on WEB)',
						type: 'boolean',
					},
					platform: {
						description: 'From what platform the user is using the Settings',
						enum: ['EXCHANGE', 'WALLET'],
						type: 'string',
					},
					sms_enabled: {
						description: 'Whether sms notifications is enabled',
						type: 'boolean',
					},
				},
				required: ['platform', 'device'],
				type: 'object',
			},
			traits: {
				type: 'object',
			},
		},
		required: ['properties'],
		title: 'Notification Preferences Updated',
		type: 'object',
	}
	const message = {
		event: 'Notification Preferences Updated',
		properties: props || {},
		options,
	}
	validateAgainstSchema(message, schema)

	const a = analytics()
	if (a) {
		a.track(
			'Notification Preferences Updated',
			props || {},
			withTypewriterContext(options),
			callback
		)
	}
}
/**
 * Generic event for tracking a web page
 *
 * @param {PageViewed} props - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function pageViewed(
	props: PageViewed,
	options?: Segment.Options,
	callback?: Segment.Callback
): void {
	const schema = {
		$schema: 'http://json-schema.org/draft-07/schema#',
		description: 'Generic event for tracking a web page',
		labels: {
			flow: ['dot_com', 'explorer'],
			source: 'client',
		},
		properties: {
			context: {},
			properties: {
				properties: {
					device: {
						description: 'What device the page is viewed from',
						enum: ['WEB'],
						type: 'string',
					},
					path: {
						description:
							'Path portion of the URL of the page. Equivalent to canonical path which defaults to location.pathname from the DOM API.',
						type: 'string',
					},
					platform: {
						description: 'What platform the page viewed belongs to',
						enum: ['EXCHANGE', 'EXPLORER', 'WALLET'],
						type: 'string',
					},
					referrer: {
						description:
							'Full URL of the previous page. Equivalent to document.referrer from the DOM API.',
						type: 'string',
					},
					search: {
						description:
							'Query string portion of the URL of the page. Equivalent to location.search from the DOM API.',
						type: 'string',
					},
					search_params: {
						description: 'parameters passed in the link',
						properties: {
							from: {
								description:
									'unix timestamp used for custom date range in the prices/currency page',
								format: 'date-time',
								type: 'string',
							},
							scale: {
								description: 'linear scale (default) = 0. logarithmic= 1',
								type: 'number',
							},
							style: {
								description:
									'chart style LINE (default) or CANDELSTICK used in the prices/currency page',
								enum: ['CANDLESTICKS', 'LINE'],
								type: 'string',
							},
							timeSpan: {
								description: 'days parameter used in the prices/currency page',
								type: 'integer',
							},
							to: {
								description:
									'unix timestamp used for custom date range in the prices/currency page',
								format: 'date-time',
								type: 'string',
							},
							utm_campaign: {
								description: 'utm parameter',
								type: 'string',
							},
							view: {
								description:
									'which blockchain network is being requested in the home page',
								enum: [' BCH-TESTNET', ' BTC', ' BTC-TESTNET', ' ETH', 'BCH'],
								type: 'string',
							},
							volume: {
								description: 'show volume on used in the prices/currency page',
								type: 'boolean',
							},
						},
						required: [],
						type: 'object',
					},
					title: {
						description:
							'Title of the page. Equivalent to document.title from the DOM API.',
						type: 'string',
					},
					url: {
						description:
							'Full URL of the page. First we look for the canonical url. If the canonical url is not provided, we use location.href from the DOM API.',
						type: 'string',
					},
					url_paths: {
						description:
							'example: blockchain.com/btc/tx/hash  paths: currency:btc tx:hash',
						properties: {
							'': {
								description: '',
								type: 'object',
							},
							block: {
								description: 'block hash',
								type: 'string',
							},
							chart: {
								description:
									'which chart was selected from the charts page. example: transactions-per-second',
								type: 'string',
							},
							currency: {
								description:
									'Currency symbol for the currency being requested in the prices page by the user. For example USDT\n',
								pattern: '^[A-Z]{3,5}$',
								type: 'string',
							},
							network: {
								description:
									'which blockchain network is being requested in tx or block page',
								enum: ['BCH', 'BCH-TESTNET', 'BTC', 'BTC-TESTNET', 'ETH'],
								type: 'string',
							},
							tx: {
								description: 'tx hash',
								type: 'string',
							},
						},
						required: [],
						type: 'object',
					},
				},
				required: ['platform', 'device'],
				type: 'object',
			},
			traits: {
				type: 'object',
			},
		},
		required: ['properties'],
		title: 'Page Viewed',
		type: 'object',
	}
	const message = {
		event: 'Page Viewed',
		properties: props || {},
		options,
	}
	validateAgainstSchema(message, schema)

	const a = analytics()
	if (a) {
		a.track(
			'Page Viewed',
			props || {},
			withTypewriterContext(options),
			callback
		)
	}
}
/**
 * increases the difficulty of discovering the password using a brute-force attack but slows down loading and saving your wallet. (PBKDF2)
 *
 * @param {PasswordStretchingChanged} props - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function passwordStretchingChanged(
	props: PasswordStretchingChanged,
	options?: Segment.Options,
	callback?: Segment.Callback
): void {
	const schema = {
		$schema: 'http://json-schema.org/draft-07/schema#',
		description:
			'increases the difficulty of discovering the password using a brute-force attack but slows down loading and saving your wallet. (PBKDF2)',
		labels: {
			flow: 'security_v1',
			source: 'backend',
		},
		properties: {
			context: {},
			properties: {
				properties: {
					device: {
						description: 'Device type from where the event was triggered.',
						enum: ['APP-iOS', 'WEB', 'APP-Android'],
						type: 'string',
					},
					pbkdf2: {
						description: 'PBKDF2 must be between 1 and 20000',
						type: 'integer',
					},
					platform: {
						description:
							'From what platform the user is managing Security events\n',
						enum: ['EXCHANGE', 'WALLET'],
						type: 'string',
					},
				},
				required: ['platform', 'pbkdf2'],
				type: 'object',
			},
			traits: {
				type: 'object',
			},
		},
		required: ['properties'],
		title: 'Password Stretching Changed',
		type: 'object',
	}
	const message = {
		event: 'Password Stretching Changed',
		properties: props || {},
		options,
	}
	validateAgainstSchema(message, schema)

	const a = analytics()
	if (a) {
		a.track(
			'Password Stretching Changed',
			props || {},
			withTypewriterContext(options),
			callback
		)
	}
}
/**
 * A rule is being checked for a payment. This is from the rule_execution_report in Nabu Fraud DB
 *
 * @param {PaymentRuleExecuted} props - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function paymentRuleExecuted(
	props: PaymentRuleExecuted,
	options?: Segment.Options,
	callback?: Segment.Callback
): void {
	const schema = {
		$schema: 'http://json-schema.org/draft-07/schema#',
		description:
			'A rule is being checked for a payment. This is from the rule_execution_report in Nabu Fraud DB',
		labels: {
			source: 'backend',
		},
		properties: {
			context: {},
			properties: {
				properties: {
					decision: {
						description: 'The decision of the rule',
						enum: ['APPROVED', 'MANUAL_REVIEW', 'REJECTED'],
						type: 'string',
					},
					device: {
						description: 'Device type from where the event was triggered.',
						enum: [' APP-Android', ' WEB', 'APP-iOS'],
						type: 'string',
					},
					payment_id: {
						description:
							'id of the payment (id of the transaction from nabu payments)',
						type: 'string',
					},
					payment_type: {
						description:
							'The type of payment. (type column from the transaction table in nabu payments db)',
						enum: [
							'CHARGE',
							'DEPOSIT',
							'INTEREST_OUTGOING',
							'REFUND',
							'WITHDRAWAL',
						],
						type: 'string',
					},
					platfrom: {
						description:
							'What platform the event was started from. (WALLET if product=SIMPLEBUY and EXCHANGE if product=MERCURY',
						enum: ['EXCHANGE', 'WALLET'],
						type: 'string',
					},
					product: {
						description: 'Product for which the payment was made for',
						enum: [' EXCHANGE', ' SAVINGS', ' SIMPLEBUY', ' SWAP', 'BORROW'],
						type: 'string',
					},
					rule_type: {
						description: 'The rule',
						type: 'string',
					},
				},
				required: [
					'payment_id',
					'rule_type',
					'platfrom',
					'payment_type',
					'decision',
				],
				type: 'object',
			},
			traits: {
				type: 'object',
			},
		},
		required: ['properties'],
		title: 'Payment Rule Executed',
		type: 'object',
	}
	const message = {
		event: 'Payment Rule Executed',
		properties: props || {},
		options,
	}
	validateAgainstSchema(message, schema)

	const a = analytics()
	if (a) {
		a.track(
			'Payment Rule Executed',
			props || {},
			withTypewriterContext(options),
			callback
		)
	}
}
/**
 * A user completed a payment. (when updating final state to "COMPLETE" of transaction from nabu payments)
 *
 * @param {PaymentStateTriggered} props - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function paymentStateTriggered(
	props: PaymentStateTriggered,
	options?: Segment.Options,
	callback?: Segment.Callback
): void {
	const schema = {
		$schema: 'http://json-schema.org/draft-07/schema#',
		description:
			'A user completed a payment. (when updating final state to "COMPLETE" of transaction from nabu payments)',
		labels: {
			flow: 'simplebuy_v1',
			source: 'backend',
		},
		properties: {
			context: {},
			properties: {
				properties: {
					amount: {
						description:
							'Amount (in "currency") being deposited by the user, usually as a float. For BTC, it should be for example 1.23, meaning 1.23 BTC',
						type: 'number',
					},
					amount_usd: {
						description: 'Amount in USD deposited by the user.',
						type: 'number',
					},
					currency: {
						description: 'Currency being deposited by the user',
						pattern: '^[A-Z]{3,5}$',
						type: 'string',
					},
					device: {
						description: 'Device type from where the event was triggered.',
						enum: ['APP-iOS', 'WEB', 'APP-Android'],
						type: 'string',
					},
					failure_reason: {
						description: 'if failed, Why the payment failed',
						type: ['string', 'null'],
					},
					fee_amount: {
						description: 'Fee (in "currency") being charged for the payment.',
						type: 'number',
					},
					fee_amount_usd: {
						description: 'Fee in USD being charged for the payment',
						type: 'number',
					},
					institution_name: {
						description:
							'It is the name of the bank the user has used for the payment. Used specifically with open banking for now',
						type: 'string',
					},
					partner: {
						description: 'Payment partner. For example HWS, LHV, EVERYPAY',
						pattern: '[A-Z]+',
						type: 'string',
					},
					payment_id: {
						description:
							'id of the payment (id of the transaction from nabu payments)',
						type: 'string',
					},
					payment_type: {
						description:
							'The type of payment. (type column from the transaction table in nabu payments db)',
						enum: [
							'CHARGE',
							'DEPOSIT',
							'INTEREST_OUTGOING',
							'REFUND',
							'WITHDRAWAL',
						],
						type: 'string',
					},
					platform: {
						description:
							'What platform the event was started from. (WALLET if product=SIMPLEBUY and EXCHANGE if product=MERCURY',
						enum: ['EXCHANGE', 'WALLET'],
						type: 'string',
					},
					processing_account: {
						description: 'The processing account used for the card payment',
						type: 'string',
					},
					product: {
						description: 'Product for which the payment was made for',
						enum: ['BORROW', 'EXCHANGE', 'SAVINGS', 'SIMPLEBUY', 'SWAP'],
						type: 'string',
					},
					state: {
						description:
							'Payment status. ideal for tracking status transition timings.',
						enum: [
							'AUTHORIZED',
							'CLEARED',
							'COMPLETE',
							'COMPLETED',
							'CREATED',
							'CREDITED',
							'FAILED',
							'FRAUD_REVIEW',
							'MANUAL_EXECUTION',
							'MANUAL_REVIEW',
							'PENDING',
							'PRE_CHARGE_APPROVED',
							'PRE_CHARGE_REVIEW',
							'REFUNDED',
							'REJECTED',
							'SETTLED',
						],
						type: 'string',
					},
				},
				required: [
					'fee_amount_usd',
					'state',
					'payment_id',
					'partner',
					'amount',
					'product',
					'platform',
					'payment_type',
				],
				type: 'object',
			},
			traits: {
				type: 'object',
			},
		},
		required: ['properties'],
		title: 'Payment State Triggered',
		type: 'object',
	}
	const message = {
		event: 'Payment State Triggered',
		properties: props || {},
		options,
	}
	validateAgainstSchema(message, schema)

	const a = analytics()
	if (a) {
		a.track(
			'Payment State Triggered',
			props || {},
			withTypewriterContext(options),
			callback
		)
	}
}
/**
 * peeksheet dismissed by user x
 *
 * @param {PeeksheetDismissed} props - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function peeksheetDismissed(
	props: PeeksheetDismissed,
	options?: Segment.Options,
	callback?: Segment.Callback
): void {
	const schema = {
		$schema: 'http://json-schema.org/draft-07/schema#',
		description: 'peeksheet dismissed by user x',
		labels: {
			flow: ['onboarding_v1', 'onboarding_e1'],
			source: 'client',
		},
		properties: {
			context: {},
			properties: {
				properties: {
					current_step_completed: {
						description:
							'what is the current completed step of the user. 0 = verification pending, 1 = payment method pending or 2 = Buy never started',
						enum: ['0', '1', '2'],
						type: 'string',
					},
					device: {
						description: 'Device type from where the Peeksheet was dismissed.',
						enum: [' APP-iOS', 'APP-Android'],
						type: 'string',
					},
					platform: {
						description: 'What platform the Peeksheet was dismissed',
						enum: ['WALLET'],
						type: 'string',
					},
				},
				required: ['current_step_completed', 'device', 'platform'],
				type: 'object',
			},
			traits: {
				type: 'object',
			},
		},
		required: ['properties'],
		title: 'Peeksheet Dismissed',
		type: 'object',
	}
	const message = {
		event: 'Peeksheet Dismissed',
		properties: props || {},
		options,
	}
	validateAgainstSchema(message, schema)

	const a = analytics()
	if (a) {
		a.track(
			'Peeksheet Dismissed',
			props || {},
			withTypewriterContext(options),
			callback
		)
	}
}
/**
 * Peeksheet Process clicked from at the home dashboard. users in regions where trading is allowed will be presented with the new peek sheet. https://www.figma.com/file/IXwonpgbc67ho6uvPX7O74/NUX---New-User-Experience?node-id=572%3A36112
 *
 * @param {PeeksheetProcessClicked} props - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function peeksheetProcessClicked(
	props: PeeksheetProcessClicked,
	options?: Segment.Options,
	callback?: Segment.Callback
): void {
	const schema = {
		$schema: 'http://json-schema.org/draft-07/schema#',
		description:
			'Peeksheet Process clicked from at the home dashboard. users in regions where trading is allowed will be presented with the new peek sheet. https://www.figma.com/file/IXwonpgbc67ho6uvPX7O74/NUX---New-User-Experience?node-id=572%3A36112',
		labels: {
			flow: ['onboarding_v1', 'onboarding_e1'],
			source: 'client',
		},
		properties: {
			context: {},
			properties: {
				properties: {
					current_step_completed: {
						description:
							'what is the current completed step of the user. 0 = verification pending, 1 = payment method pending or 2 = Buy never started',
						enum: ['0', '1', '2'],
						type: 'string',
					},
					device: {
						description: 'Device type from where the Peeksheet was shown.',
						enum: [' APP-iOS', 'APP-Android'],
						type: 'string',
					},
					platform: {
						description: 'What platform the Peeksheet was displayed',
						enum: ['WALLET'],
						type: 'string',
					},
				},
				required: ['device', 'platform', 'current_step_completed'],
				type: 'object',
			},
			traits: {
				type: 'object',
			},
		},
		required: ['properties'],
		title: 'Peeksheet Process Clicked',
		type: 'object',
	}
	const message = {
		event: 'Peeksheet Process Clicked',
		properties: props || {},
		options,
	}
	validateAgainstSchema(message, schema)

	const a = analytics()
	if (a) {
		a.track(
			'Peeksheet Process Clicked',
			props || {},
			withTypewriterContext(options),
			callback
		)
	}
}
/**
 * peeksheet selection was chosen
 *
 * @param {PeeksheetSelectionClicked} props - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function peeksheetSelectionClicked(
	props: PeeksheetSelectionClicked,
	options?: Segment.Options,
	callback?: Segment.Callback
): void {
	const schema = {
		$schema: 'http://json-schema.org/draft-07/schema#',
		description: 'peeksheet selection was chosen ',
		labels: {
			flow: ['onboarding_v1', 'onboarding_e1'],
			source: 'client',
		},
		properties: {
			context: {},
			properties: {
				properties: {
					button_clicked: {
						description:
							'True if selection was clicking the main button, False if selection was made from the three items (center)',
						type: 'boolean',
					},
					current_step_completed: {
						description:
							'what is the current completed step of the user. 0 = verification pending, 1 = payment method pending or 2 = Buy never started',
						enum: ['0', '1', '2'],
						type: 'string',
					},
					device: {
						description: 'Device type from which the selection was clicked',
						enum: [' APP-iOS', 'APP-Android'],
						type: 'string',
					},
					item: {
						description: 'Peek sheet item selected',
						enum: ['BUY_CRYPTO', 'LINK_PAYMENT', 'VERIFY'],
						type: 'string',
					},
					platform: {
						description: 'What platform the Peeksheet selection was clicked',
						enum: ['WALLET'],
						type: 'string',
					},
				},
				required: [
					'device',
					'platform',
					'current_step_completed',
					'item',
					'button_clicked',
				],
				type: 'object',
			},
			traits: {
				type: 'object',
			},
		},
		required: ['properties'],
		title: 'Peeksheet Selection Clicked',
		type: 'object',
	}
	const message = {
		event: 'Peeksheet Selection Clicked',
		properties: props || {},
		options,
	}
	validateAgainstSchema(message, schema)

	const a = analytics()
	if (a) {
		a.track(
			'Peeksheet Selection Clicked',
			props || {},
			withTypewriterContext(options),
			callback
		)
	}
}
/**
 * users in regions where trading is allowed will be presented with the new peek sheet.
 *
 * @param {PeeksheetViewed} props - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function peeksheetViewed(
	props: PeeksheetViewed,
	options?: Segment.Options,
	callback?: Segment.Callback
): void {
	const schema = {
		$schema: 'http://json-schema.org/draft-07/schema#',
		description:
			'users in regions where trading is allowed will be presented with the new peek sheet.',
		labels: {
			flow: ['onboarding_v1', 'onboarding_e1'],
			source: 'client',
		},
		properties: {
			context: {},
			properties: {
				properties: {
					current_step_completed: {
						description:
							'what is the current completed step of the user. 0 = verification pending, 1 = payment method pending or 2 = Buy never started',
						enum: ['0', '1', '2'],
						type: 'string',
					},
					device: {
						description: 'Device type from where the Peeksheet was shown.',
						enum: [' APP-iOS', 'APP-Android'],
						type: 'string',
					},
					platform: {
						description: 'What platform the Peeksheet was displayed',
						enum: ['WALLET'],
						type: 'string',
					},
				},
				required: ['device', 'platform', 'current_step_completed'],
				type: 'object',
			},
			traits: {
				type: 'object',
			},
		},
		required: ['properties'],
		title: 'Peeksheet Viewed',
		type: 'object',
	}
	const message = {
		event: 'Peeksheet Viewed',
		properties: props || {},
		options,
	}
	validateAgainstSchema(message, schema)

	const a = analytics()
	if (a) {
		a.track(
			'Peeksheet Viewed',
			props || {},
			withTypewriterContext(options),
			callback
		)
	}
}
/**
 * User enters and submits his first name, last names, and date of birth
 *
 * @param {PersonalInformationEntered} props - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function personalInformationEntered(
	props: PersonalInformationEntered,
	options?: Segment.Options,
	callback?: Segment.Callback
): void {
	const schema = {
		$schema: 'http://json-schema.org/draft-07/schema#',
		description:
			'User enters and submits his first name, last names, and date of birth',
		labels: {
			flow: 'onboarding_e1',
			source: 'client',
		},
		properties: {
			context: {},
			properties: {
				properties: {
					device: {
						description: 'Device type from where the event was triggered.',
						enum: ['APP-Android', 'APP-iOS', 'WEB'],
						type: 'string',
					},
					platform: {
						description: 'What platform the user is entering PII from',
						enum: ['EXCHANGE', 'WALLET'],
						type: 'string',
					},
				},
				required: ['platform', 'device'],
				type: 'object',
			},
			traits: {
				type: 'object',
			},
		},
		required: ['properties'],
		title: 'Personal Information Entered',
		type: 'object',
	}
	const message = {
		event: 'Personal Information Entered',
		properties: props || {},
		options,
	}
	validateAgainstSchema(message, schema)

	const a = analytics()
	if (a) {
		a.track(
			'Personal Information Entered',
			props || {},
			withTypewriterContext(options),
			callback
		)
	}
}
/**
 * Button which brings the user to the Portofolio page or screen is clicked
 *
 * @param {PortfolioClicked} props - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function portfolioClicked(
	props: PortfolioClicked,
	options?: Segment.Options,
	callback?: Segment.Callback
): void {
	const schema = {
		$schema: 'http://json-schema.org/draft-07/schema#',
		description:
			'Button which brings the user to the Portofolio page or screen is clicked',
		labels: {
			flow: 'trade_e1',
			source: 'client',
		},
		properties: {
			context: {},
			properties: {
				properties: {
					device: {
						description: 'Device type from where the event was triggered.',
						enum: ['APP-iOS', 'WEB', 'APP-Android'],
						type: 'string',
					},
					origin: {
						description:
							'what button we are referring to. BALANCE : next to the balance (total account value) info on the main trading page. NAVIGATION (mobile only) : navigation bar.',
						enum: ['BALANCE', 'NAVIGATION'],
						type: 'string',
					},
					platform: {
						description: 'What platform the user is clicking from',
						enum: ['EXCHANGE'],
						type: 'string',
					},
				},
				required: ['origin', 'platform', 'device'],
				type: 'object',
			},
			traits: {
				type: 'object',
			},
		},
		required: ['properties'],
		title: 'Portfolio Clicked',
		type: 'object',
	}
	const message = {
		event: 'Portfolio Clicked',
		properties: props || {},
		options,
	}
	validateAgainstSchema(message, schema)

	const a = analytics()
	if (a) {
		a.track(
			'Portfolio Clicked',
			props || {},
			withTypewriterContext(options),
			callback
		)
	}
}
/**
 * Portfolio screen or page in the exchange is viewed
 *
 * @param {PortfolioViewed} props - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function portfolioViewed(
	props: PortfolioViewed,
	options?: Segment.Options,
	callback?: Segment.Callback
): void {
	const schema = {
		$schema: 'http://json-schema.org/draft-07/schema#',
		description: 'Portfolio screen or page in the exchange is viewed',
		labels: {
			flow: 'trade_e1',
			source: 'client',
		},
		properties: {
			context: {},
			properties: {
				properties: {
					device: {
						description: 'Device type from where the event was triggered.',
						enum: ['APP-Android', 'APP-iOS', 'WEB'],
						type: 'string',
					},
					path: {
						description:
							'Path portion of the URL of the page. Equivalent to canonical path which defaults to location.pathname from the DOM API.',
						type: 'string',
					},
					platform: {
						description: 'What platform the page viewed belongs to',
						enum: ['EXCHANGE'],
						type: 'string',
					},
					referrer: {
						description:
							'Full URL of the previous page. Equivalent to document.referrer from the DOM API.',
						type: 'string',
					},
					search: {
						description:
							'Query string portion of the URL of the page. Equivalent to location.search from the DOM API.',
						type: 'string',
					},
					title: {
						description:
							'Title of the page. Equivalent to document.title from the DOM API.',
						type: 'string',
					},
					url: {
						description:
							'Full URL of the page. First we look for the canonical url. If the canonical url is not provided, we use location.href from the DOM API.',
						type: 'string',
					},
				},
				required: ['device', 'platform'],
				type: 'object',
			},
			traits: {
				type: 'object',
			},
		},
		required: ['properties'],
		title: 'Portfolio Viewed',
		type: 'object',
	}
	const message = {
		event: 'Portfolio Viewed',
		properties: props || {},
		options,
	}
	validateAgainstSchema(message, schema)

	const a = analytics()
	if (a) {
		a.track(
			'Portfolio Viewed',
			props || {},
			withTypewriterContext(options),
			callback
		)
	}
}
/**
 * The user clicks on the Show button which shows the QR Code and the written Private Key of the current cryptocurrency tab.   Note from frontend: The Event is triggered once even if user toggles it on and off.
 *
 * @param {PrivateKeysShown} props - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function privateKeysShown(
	props: PrivateKeysShown,
	options?: Segment.Options,
	callback?: Segment.Callback
): void {
	const schema = {
		$schema: 'http://json-schema.org/draft-07/schema#',
		description:
			'The user clicks on the Show button which shows the QR Code and the written Private Key of the current cryptocurrency tab.   Note from frontend: The Event is triggered once even if user toggles it on and off.',
		labels: {
			flow: 'settings_v1',
			source: 'client',
		},
		properties: {
			context: {},
			properties: {
				properties: {
					currency: {
						description:
							'current cryptocurrency information being showed by the user. (Ethereum or Stellar for now) Example: ETH for Ethereum.',
						pattern: '^[A-Z]{3,5}$',
						type: 'string',
					},
					device: {
						description: 'Device type from where the event was triggered.',
						enum: ['WEB'],
						type: 'string',
					},
					platform: {
						description: 'From what platform the user is using the Settings',
						enum: ['EXCHANGE', 'WALLET'],
						type: 'string',
					},
				},
				required: ['platform', 'device'],
				type: 'object',
			},
			traits: {
				type: 'object',
			},
		},
		required: ['properties'],
		title: 'Private Keys Shown',
		type: 'object',
	}
	const message = {
		event: 'Private Keys Shown',
		properties: props || {},
		options,
	}
	validateAgainstSchema(message, schema)

	const a = analytics()
	if (a) {
		a.track(
			'Private Keys Shown',
			props || {},
			withTypewriterContext(options),
			callback
		)
	}
}
/**
 * Push notification from a provider bounces. https://segment.com/docs/connections/spec/mobile/#push-notification-bounced
 *
 * @param {PushNotificationBounced} props - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function pushNotificationBounced(
	props: PushNotificationBounced,
	options?: Segment.Options,
	callback?: Segment.Callback
): void {
	const schema = {
		$schema: 'http://json-schema.org/draft-07/schema#',
		description:
			'Push notification from a provider bounces. https://segment.com/docs/connections/spec/mobile/#push-notification-bounced',
		labels: {
			flow: 'push',
			source: 'client',
		},
		properties: {
			context: {},
			properties: {
				properties: {
					campaign: {
						description: '',
						properties: {
							content: {
								description: 'Push notification content.',
								type: 'string',
							},
							medium: {
								description:
									'Identifies what type of link was used (Push Notification).',
								type: 'string',
							},
							name: {
								description: 'The name of the attributed campaign.',
								type: 'string',
							},
							source: {
								description: 'Designates the push provider. ',
								type: 'string',
							},
						},
						required: [],
						type: 'object',
					},
					device: {
						description: 'Device type from where the event was triggered.',
						enum: ['APP-iOS', 'APP-Android'],
						type: 'string',
					},
					platform: {
						description: '',
						enum: ['EXCHANGE', 'WALLET'],
						type: 'string',
					},
				},
				required: ['device', 'platform'],
				type: 'object',
			},
			traits: {
				type: 'object',
			},
		},
		required: ['properties'],
		title: 'Push Notification Bounced',
		type: 'object',
	}
	const message = {
		event: 'Push Notification Bounced',
		properties: props || {},
		options,
	}
	validateAgainstSchema(message, schema)

	const a = analytics()
	if (a) {
		a.track(
			'Push Notification Bounced',
			props || {},
			withTypewriterContext(options),
			callback
		)
	}
}
/**
 * This event can be sent when a push notification is received in the app
 *
 * @param {PushNotificationReceived} props - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function pushNotificationReceived(
	props: PushNotificationReceived,
	options?: Segment.Options,
	callback?: Segment.Callback
): void {
	const schema = {
		$schema: 'http://json-schema.org/draft-07/schema#',
		description:
			'This event can be sent when a push notification is received in the app',
		labels: {
			flow: 'push',
			source: 'client',
		},
		properties: {
			context: {},
			properties: {
				properties: {
					campaign: {
						description: '',
						properties: {
							content: {
								description: 'Push notification content.',
								type: 'string',
							},
							medium: {
								description:
									'Identifies what type of link was used (Push Notification).\n',
								type: 'string',
							},
							name: {
								description: 'The name of the attributed campaign.',
								type: 'string',
							},
							source: {
								description: 'Designates the push provider.',
								type: 'string',
							},
						},
						required: [],
						type: 'object',
					},
					device: {
						description: 'Device type from where the event was triggered.',
						enum: ['APP-iOS', 'APP-Android'],
						type: 'string',
					},
					platform: {
						description: '',
						enum: ['EXCHANGE', 'WALLET'],
						type: 'string',
					},
				},
				required: ['device', 'platform'],
				type: 'object',
			},
			traits: {
				type: 'object',
			},
		},
		required: ['properties'],
		title: 'Push Notification Received',
		type: 'object',
	}
	const message = {
		event: 'Push Notification Received',
		properties: props || {},
		options,
	}
	validateAgainstSchema(message, schema)

	const a = analytics()
	if (a) {
		a.track(
			'Push Notification Received',
			props || {},
			withTypewriterContext(options),
			callback
		)
	}
}
/**
 * Push Notification Sent
 *
 * @param {PushNotificationSent} props - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function pushNotificationSent(
	props: PushNotificationSent,
	options?: Segment.Options,
	callback?: Segment.Callback
): void {
	const schema = {
		$schema: 'http://json-schema.org/draft-07/schema#',
		description: 'Push Notification Sent',
		labels: {
			flow: 'push',
			source: 'client',
		},
		properties: {
			context: {},
			properties: {
				properties: {
					device: {
						description: 'Device type from where the event was triggered.',
						enum: ['APP-iOS', 'APP-Android'],
						type: 'string',
					},
					name: {
						description: '',
						type: 'string',
					},
					platform: {
						description: '',
						enum: ['EXCHANGE', 'WALLET'],
						type: 'string',
					},
				},
				required: ['device', 'platform'],
				type: 'object',
			},
			traits: {
				type: 'object',
			},
		},
		required: ['properties'],
		title: 'Push Notification Sent',
		type: 'object',
	}
	const message = {
		event: 'Push Notification Sent',
		properties: props || {},
		options,
	}
	validateAgainstSchema(message, schema)

	const a = analytics()
	if (a) {
		a.track(
			'Push Notification Sent',
			props || {},
			withTypewriterContext(options),
			callback
		)
	}
}
/**
 * user taps on a push notification associated with the app
 *
 * @param {PushNotificationTapped} props - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function pushNotificationTapped(
	props: PushNotificationTapped,
	options?: Segment.Options,
	callback?: Segment.Callback
): void {
	const schema = {
		$schema: 'http://json-schema.org/draft-07/schema#',
		description: 'user taps on a push notification associated with the app',
		labels: {
			flow: 'push',
			source: 'client',
		},
		properties: {
			context: {},
			properties: {
				properties: {
					campaign: {
						description: '',
						properties: {
							content: {
								description: 'Push notification content.',
								type: 'string',
							},
							medium: {
								description:
									'Identifies what type of link was used (Push Notification).\n',
								type: 'string',
							},
							name: {
								description: 'The name of the attributed campaign.',
								type: 'string',
							},
							source: {
								description: 'Designates the push provider. ',
								type: 'string',
							},
						},
						required: [],
						type: 'object',
					},
					device: {
						description: 'Device type from where the event was triggered.',
						enum: ['APP-iOS', 'APP-Android'],
						type: 'string',
					},
					platform: {
						description: '',
						enum: ['EXCHANGE', 'WALLET'],
						type: 'string',
					},
				},
				required: ['device', 'platform'],
				type: 'object',
			},
			traits: {
				type: 'object',
			},
		},
		required: ['properties'],
		title: 'Push Notification Tapped',
		type: 'object',
	}
	const message = {
		event: 'Push Notification Tapped',
		properties: props || {},
		options,
	}
	validateAgainstSchema(message, schema)

	const a = analytics()
	if (a) {
		a.track(
			'Push Notification Tapped',
			props || {},
			withTypewriterContext(options),
			callback
		)
	}
}
/**
 * A Qr Code icon has been clicked on. This is typically going to trigger the camera or a menu first of things that could be scanned
 *
 * @param {QrCodeClicked} props - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function qrCodeClicked(
	props: QrCodeClicked,
	options?: Segment.Options,
	callback?: Segment.Callback
): void {
	const schema = {
		$schema: 'http://json-schema.org/draft-07/schema#',
		description:
			'A Qr Code icon has been clicked on. This is typically going to trigger the camera or a menu first of things that could be scanned',
		labels: {
			flow: 'wconnect',
			source: 'client',
		},
		properties: {
			context: {},
			properties: {
				properties: {
					device: {
						description: 'Device the user clicked the QR code from',
						enum: ['APP-iOS'],
						type: 'string',
					},
					origin: {
						description:
							'What button we are referring to. DASHBOARD : from the Home (=DASHBOARD) page',
						enum: ['DASHBOARD'],
						type: 'string',
					},
					platform: {
						description:
							'Platform the user is using wallet connect from. Currently it will be only available from the WALLET',
						enum: ['WALLET'],
						type: 'string',
					},
				},
				required: ['device', 'platform', 'origin'],
				type: 'object',
			},
			traits: {
				type: 'object',
			},
		},
		required: ['properties'],
		title: 'Qr Code Clicked',
		type: 'object',
	}
	const message = {
		event: 'Qr Code Clicked',
		properties: props || {},
		options,
	}
	validateAgainstSchema(message, schema)

	const a = analytics()
	if (a) {
		a.track(
			'Qr Code Clicked',
			props || {},
			withTypewriterContext(options),
			callback
		)
	}
}
/**
 * The user scanned a QR code using his camera from the device. It could be an external crypto address, a Dapp, or blockhain login
 *
 * @param {QrCodeScanned} props - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function qrCodeScanned(
	props: QrCodeScanned,
	options?: Segment.Options,
	callback?: Segment.Callback
): void {
	const schema = {
		$schema: 'http://json-schema.org/draft-07/schema#',
		description:
			'The user scanned a QR code using his camera from the device. It could be an external crypto address, a Dapp, or blockhain login ',
		labels: {
			flow: 'wconnect',
			source: 'client',
		},
		properties: {
			context: {},
			properties: {
				properties: {
					device: {
						description: 'Device the user user is using wallet connect from',
						enum: ['APP-iOS'],
						type: 'string',
					},
					platform: {
						description:
							'Platform the user is using wallet connect from. Currently it will be only available from the WALLET',
						enum: ['WALLET'],
						type: 'string',
					},
					qr_type: {
						description:
							'What type of QR code is scanned, if it is valid. INVALID : the qr_code scanned is not valid. CRYPTO_ADDRESS : address of a crypto currency to send funds to (CryptoTarget in iOS). DAPP : to connect to a dapp with Wallet Connect. DEEPLINK: when scanning a deeplink. LOG_IN : when opening a secure channel to log in via sso',
						enum: ['CRYPTO_ADDRESS', 'DAPP', 'DEEPLINK', 'INVALID', 'LOG_IN'],
						type: 'string',
					},
				},
				required: ['device', 'platform'],
				type: 'object',
			},
			traits: {
				type: 'object',
			},
		},
		required: ['properties'],
		title: 'Qr Code Scanned',
		type: 'object',
	}
	const message = {
		event: 'Qr Code Scanned',
		properties: props || {},
		options,
	}
	validateAgainstSchema(message, schema)

	const a = analytics()
	if (a) {
		a.track(
			'Qr Code Scanned',
			props || {},
			withTypewriterContext(options),
			callback
		)
	}
}
/**
 * A user selects the currency and accounts he wants to receive.
 *
 * @param {ReceiveCurrencySelected} props - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function receiveCurrencySelected(
	props: ReceiveCurrencySelected,
	options?: Segment.Options,
	callback?: Segment.Callback
): void {
	const schema = {
		$schema: 'http://json-schema.org/draft-07/schema#',
		description:
			'A user selects the currency and accounts he wants to receive.',
		labels: {
			flow: 'receive_v1',
			source: 'client',
		},
		properties: {
			context: {},
			properties: {
				properties: {
					account_type: {
						description:
							'To what type of account the user wants to receive funds to. \nSAVINGS is the interest saving account. \nTRADING is the wallet custodial wallet. \nUSERKEY is the Non Custodial, Private Key, wallet',
						enum: ['SAVINGS', 'TRADING', 'USERKEY'],
						type: 'string',
					},
					currency: {
						description: 'The currency the user wants to receive (e.g. BTC)',
						pattern: '^[A-Z]{3,5}$',
						type: 'string',
					},
					device: {
						description: 'Device type from where the event was triggered.',
						enum: ['APP-Android', 'APP-iOS', 'WEB'],
						type: 'string',
					},
					platform: {
						description: 'What platform the user wants to receive funds to',
						enum: ['WALLET'],
						type: 'string',
					},
				},
				required: ['platform', 'device', 'account_type', 'currency'],
				type: 'object',
			},
			traits: {
				type: 'object',
			},
		},
		required: ['properties'],
		title: 'Receive Currency Selected',
		type: 'object',
	}
	const message = {
		event: 'Receive Currency Selected',
		properties: props || {},
		options,
	}
	validateAgainstSchema(message, schema)

	const a = analytics()
	if (a) {
		a.track(
			'Receive Currency Selected',
			props || {},
			withTypewriterContext(options),
			callback
		)
	}
}
/**
 * A user copies to clipboard the information to receive the currency
 *
 * @param {ReceiveDetailsCopied} props - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function receiveDetailsCopied(
	props: ReceiveDetailsCopied,
	options?: Segment.Options,
	callback?: Segment.Callback
): void {
	const schema = {
		$schema: 'http://json-schema.org/draft-07/schema#',
		description:
			'A user copies to clipboard the information to receive the currency',
		labels: {
			flow: 'receive_v1',
			source: 'client',
		},
		properties: {
			context: {},
			properties: {
				properties: {
					account_type: {
						description:
							'To what type of account the user wants to receive funds to. \nSAVINGS is the interest saving account. \nTRADING is the wallet custodial wallet. \nUSERKEY is the Non Custodial, Private Key, wallet',
						enum: ['SAVINGS', 'TRADING', 'USERKEY'],
						type: 'string',
					},
					currency: {
						description: 'The currency the user wants to receive (e.g. BTC)',
						pattern: '^[A-Z]{3,5}$',
						type: 'string',
					},
					device: {
						description: 'Device type from where the event was triggered.',
						enum: ['APP-Android', 'APP-iOS', 'WEB'],
						type: 'string',
					},
					platform: {
						description: 'What platform the user wants to receive funds to',
						enum: ['WALLET'],
						type: 'string',
					},
				},
				required: ['currency', 'platform', 'device', 'account_type'],
				type: 'object',
			},
			traits: {
				type: 'object',
			},
		},
		required: ['properties'],
		title: 'Receive Details Copied',
		type: 'object',
	}
	const message = {
		event: 'Receive Details Copied',
		properties: props || {},
		options,
	}
	validateAgainstSchema(message, schema)

	const a = analytics()
	if (a) {
		a.track(
			'Receive Details Copied',
			props || {},
			withTypewriterContext(options),
			callback
		)
	}
}
/**
 * The user confirms the Recovery Phrase words to verify that the user saved the words offline.
 *
 * @param {RecoveryPhraseBackedUp} props - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function recoveryPhraseBackedUp(
	props: RecoveryPhraseBackedUp,
	options?: Segment.Options,
	callback?: Segment.Callback
): void {
	const schema = {
		$schema: 'http://json-schema.org/draft-07/schema#',
		description:
			'The user confirms the Recovery Phrase words to verify that the user saved the words offline.',
		labels: {
			flow: 'security_v1',
			source: 'backend',
		},
		properties: {
			context: {},
			properties: {
				properties: {
					device: {
						description: 'Device type from where the event was triggered.',
						enum: ['APP-iOS', 'WEB', 'APP-Android'],
						type: 'string',
					},
					platform: {
						description:
							'From what platform the user is managing Security events',
						enum: ['WALLET'],
						type: 'string',
					},
				},
				required: ['platform'],
				type: 'object',
			},
			traits: {
				type: 'object',
			},
		},
		required: ['properties'],
		title: 'Recovery Phrase Backed Up',
		type: 'object',
	}
	const message = {
		event: 'Recovery Phrase Backed Up',
		properties: props || {},
		options,
	}
	validateAgainstSchema(message, schema)

	const a = analytics()
	if (a) {
		a.track(
			'Recovery Phrase Backed Up',
			props || {},
			withTypewriterContext(options),
			callback
		)
	}
}
/**
 * The user has entered and submitted the recovery phrase to recover his account
 *
 * @param {RecoveryPhraseEntered} props - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function recoveryPhraseEntered(
	props: RecoveryPhraseEntered,
	options?: Segment.Options,
	callback?: Segment.Callback
): void {
	const schema = {
		$schema: 'http://json-schema.org/draft-07/schema#',
		description:
			'The user has entered and submitted the recovery phrase to recover his account',
		labels: {
			flow: 'recovery_v1',
			source: 'client',
		},
		properties: {
			context: {},
			properties: {
				properties: {
					device: {
						description: 'Device type from where the event was triggered.',
						enum: ['APP-iOS', 'WEB', 'APP-Android'],
						type: 'string',
					},
					exchange: {
						description: 'Parameters about the exchange account',
						properties: {
							two_fa_mode: {
								description: 'Whether the exchange account has 2FA set up',
								type: 'boolean',
							},
							user_id: {
								description: 'Exchange user credentials ID',
								type: 'string',
							},
						},
						required: [],
						type: 'object',
					},
					mergeable: {
						description: 'Indicates if possible to merge two unlinked accounts',
						type: 'boolean',
					},
					platform: {
						description:
							'What platform the user is is recovering the account from',
						enum: ['WALLET', 'EXCHANGE'],
						type: 'string',
					},
					site_redirect: {
						description:
							'Whether the user is being redirected to the exchange or wallet',
						enum: ['EXCHANGE', 'WALLET'],
						type: 'string',
					},
					upgradeable: {
						description:
							'Indicates if possible to upgrade to a new unified Blockchain.com Account',
						type: 'boolean',
					},
					wallet: {
						description: 'Parameters about the wallet account',
						properties: {
							auth_type: {
								description: 'The wallet 2FA type that is enforced.',
								enum: [
									'0_NONE',
									'1_YUBIKEY',
									'2_EMAIL',
									'3_YUBIKEY_MTGOX',
									'4_GOOGLE_AUTHENTICATOR',
									'5_SMS',
								],
								type: 'string',
							},
							exchange: {
								description: 'Parameters about the exchange account',
								properties: {
									two_fa_mode: {
										description: 'Whether the exchange account has 2FA set up',
										properties: {},
										required: [],
										type: 'object',
									},
									user_id: {
										description: 'Exchange user credentials ID',
										type: 'object',
									},
								},
								required: [],
								type: 'object',
							},
							guid_first_four: {
								description:
									'The first four characters of the wallet.guid field',
								pattern: '^.{4,4}$',
								type: 'string',
							},
							has_cloud_backup: {
								description: 'Whether the wallet has cloud backups',
								type: 'boolean',
							},
							is_mobile_setup: {
								description: 'Whether the wallet has a mobile client set up',
								type: 'boolean',
							},
							last_mnemonic_backup: {
								description:
									'The last time, in unix timestamp, in which a wallet has their mnemonic backup verified',
								type: 'integer',
							},
							mobile_device_type: {
								description: 'The type of device being verified',
								enum: ['APP-Android', 'APP-iOS'],
								type: 'string',
							},
							nabu: {
								description: 'Parameter about the nabu account',
								properties: {
									recovery_eligible: {
										description:
											'Whether the nabu user is eligible for recovery. Usually if account has value (> $300 or 1 payment method linked)',
										type: 'boolean',
									},
									user_id: {
										description:
											'The Nabu User ID. This is from the users table in nabu gateway',
										type: 'object',
									},
								},
								required: [],
								type: 'object',
							},
						},
						required: [],
						type: 'object',
					},
				},
				required: ['device', 'site_redirect', 'platform'],
				type: 'object',
			},
			traits: {
				type: 'object',
			},
		},
		required: ['properties'],
		title: 'Recovery Phrase Entered',
		type: 'object',
	}
	const message = {
		event: 'Recovery Phrase Entered',
		properties: props || {},
		options,
	}
	validateAgainstSchema(message, schema)

	const a = analytics()
	if (a) {
		a.track(
			'Recovery Phrase Entered',
			props || {},
			withTypewriterContext(options),
			callback
		)
	}
}
/**
 * The user request the Secret Recovery Phrase which shows the 12 words needed to recover the wallet in case of password loss.
 *
 * @param {RecoveryPhraseShown} props - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function recoveryPhraseShown(
	props: RecoveryPhraseShown,
	options?: Segment.Options,
	callback?: Segment.Callback
): void {
	const schema = {
		$schema: 'http://json-schema.org/draft-07/schema#',
		description:
			'The user request the Secret Recovery Phrase which shows the 12 words needed to recover the wallet in case of password loss.',
		labels: {
			flow: 'security_v1',
			source: 'client',
		},
		properties: {
			context: {},
			properties: {
				properties: {
					device: {
						description: 'Device type from where the event was triggered.',
						enum: ['APP-Android', 'APP-iOS', 'WEB'],
						type: 'string',
					},
					platform: {
						description:
							'From what platform the user is managing Security events',
						enum: ['WALLET'],
						type: 'string',
					},
				},
				required: ['platform', 'device'],
				type: 'object',
			},
			traits: {
				type: 'object',
			},
		},
		required: ['properties'],
		title: 'Recovery Phrase Shown',
		type: 'object',
	}
	const message = {
		event: 'Recovery Phrase Shown',
		properties: props || {},
		options,
	}
	validateAgainstSchema(message, schema)

	const a = analytics()
	if (a) {
		a.track(
			'Recovery Phrase Shown',
			props || {},
			withTypewriterContext(options),
			callback
		)
	}
}
/**
 * The user sets up a recurring buy order. This is when the backend creates a new recurring buy with initial state ACTIVE, or if a former recurring buy is activated again.
 *
 * @param {RecurringBuyActivated} props - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function recurringBuyActivated(
	props: RecurringBuyActivated,
	options?: Segment.Options,
	callback?: Segment.Callback
): void {
	const schema = {
		$schema: 'http://json-schema.org/draft-07/schema#',
		description:
			'The user sets up a recurring buy order. This is when the backend creates a new recurring buy with initial state ACTIVE, or if a former recurring buy is activated again.',
		labels: {
			flow: 'buy_rec',
			source: 'backend',
		},
		properties: {
			context: {},
			properties: {
				properties: {
					frequency: {
						description:
							'What is the frequency of the recurring buy. Also called period in the backend.',
						enum: ['BI_WEEKLY', 'DAILY', 'MONTHLY', 'WEEKLY'],
						type: 'string',
					},
					input_amount: {
						description: 'The amount in input_currency being spend by the user',
						type: 'number',
					},
					input_amount_usd: {
						description: 'The amount in USD being spend by the user',
						type: 'number',
					},
					input_currency: {
						description:
							'Currency symbol for the currency being paid in exchange for some crypto. For example USD',
						pattern: '^[A-Z]{3,5}$',
						type: 'string',
					},
					output_currency: {
						description:
							'Currency symbol for the currency being received. For example BTC',
						pattern: '^[A-Z]{3,5}$',
						type: 'string',
					},
					payment_method: {
						description: 'The payment method used for the recurring buy order',
						enum: ['BANK_TRANSFER', 'FUNDS', 'PAYMENT_CARD'],
						type: 'string',
					},
					platform: {
						description:
							'What platform the user is looking at recurring buy from',
						enum: ['WALLET'],
						type: 'string',
					},
					recurring_buy_id: {
						description: 'What id the id of the recurring buy being cancelled',
						type: 'string',
					},
				},
				required: [
					'frequency',
					'input_amount',
					'input_currency',
					'payment_method',
					'input_amount_usd',
					'platform',
					'recurring_buy_id',
					'output_currency',
				],
				type: 'object',
			},
			traits: {
				type: 'object',
			},
		},
		required: ['properties'],
		title: 'Recurring Buy Activated',
		type: 'object',
	}
	const message = {
		event: 'Recurring Buy Activated',
		properties: props || {},
		options,
	}
	validateAgainstSchema(message, schema)

	const a = analytics()
	if (a) {
		a.track(
			'Recurring Buy Activated',
			props || {},
			withTypewriterContext(options),
			callback
		)
	}
}
/**
 * The recurring buy order was cancelled either by the user or automatically, for example due to many failed attempts. This is when the backend sets to state INACTIVE the recurring buy.
 *
 * @param {RecurringBuyCancelled} props - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function recurringBuyCancelled(
	props: RecurringBuyCancelled,
	options?: Segment.Options,
	callback?: Segment.Callback
): void {
	const schema = {
		$schema: 'http://json-schema.org/draft-07/schema#',
		description:
			'The recurring buy order was cancelled either by the user or automatically, for example due to many failed attempts. This is when the backend sets to state INACTIVE the recurring buy.',
		labels: {
			flow: 'buy_rec',
			source: 'backend',
		},
		properties: {
			context: {},
			properties: {
				properties: {
					cancelled_by_user: {
						description:
							'Whether the order is cancelled by the user or by our backend (for example after many failed reattempts)',
						type: 'boolean',
					},
					frequency: {
						description:
							'What is the frequency of the recurring buy. Also called period in the backend.',
						enum: ['BI_WEEKLY', 'DAILY', 'MONTHLY', 'WEEKLY', null],
						type: ['string', 'null'],
					},
					input_amount: {
						description: 'The amount in input_currency being spend by the user',
						type: 'number',
					},
					input_amount_usd: {
						description: 'The amount in USD being spend by the user',
						type: 'number',
					},
					input_currency: {
						description:
							'Currency symbol for the currency being paid in exchange for some crypto. For example USD',
						pattern: '^[A-Z]{3,5}$',
						type: 'string',
					},
					output_currency: {
						description:
							'Currency symbol for the currency being received. For example BTC',
						pattern: '^[A-Z]{3,5}$',
						type: 'string',
					},
					payment_method: {
						description: 'The payment method used for the recurring buy order',
						enum: ['BANK_TRANSFER', 'FUNDS', 'PAYMENT_CARD'],
						type: 'string',
					},
					platform: {
						description:
							'What platform the user is looking at recurring buy from',
						enum: ['WALLET'],
						type: 'string',
					},
					recurring_buy_id: {
						description: 'What id the id of the recurring buy being cancelled',
						type: 'string',
					},
				},
				required: [
					'platform',
					'recurring_buy_id',
					'frequency',
					'output_currency',
					'input_amount',
					'input_currency',
					'payment_method',
					'input_amount_usd',
					'cancelled_by_user',
				],
				type: 'object',
			},
			traits: {
				type: 'object',
			},
		},
		required: ['properties'],
		title: 'Recurring Buy Cancelled',
		type: 'object',
	}
	const message = {
		event: 'Recurring Buy Cancelled',
		properties: props || {},
		options,
	}
	validateAgainstSchema(message, schema)

	const a = analytics()
	if (a) {
		a.track(
			'Recurring Buy Cancelled',
			props || {},
			withTypewriterContext(options),
			callback
		)
	}
}
/**
 * The user clicks on a widget to start the Recurring Buy flow
 *
 * @param {RecurringBuyClicked} props - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function recurringBuyClicked(
	props: RecurringBuyClicked,
	options?: Segment.Options,
	callback?: Segment.Callback
): void {
	const schema = {
		$schema: 'http://json-schema.org/draft-07/schema#',
		description: 'The user clicks on a widget to start the Recurring Buy flow',
		labels: {
			flow: 'buy_rec',
			source: 'client',
		},
		properties: {
			context: {},
			properties: {
				properties: {
					device: {
						description: 'Device type from where the event was triggered.\n',
						enum: ['APP-iOS', 'WEB', 'APP-Android'],
						type: 'string',
					},
					origin: {
						description:
							'What button we are referring to. BUY_CONFIRMATION : at the end of the buy flow (Create Recurring Buy at the suggestion screen).',
						enum: ['BUY_CONFIRMATION'],
						type: 'string',
					},
					platform: {
						description:
							'What platform the user is looking at recurring buy from',
						enum: ['WALLET'],
						type: 'string',
					},
				},
				required: ['platform', 'device', 'origin'],
				type: 'object',
			},
			traits: {
				type: 'object',
			},
		},
		required: ['properties'],
		title: 'Recurring Buy Clicked',
		type: 'object',
	}
	const message = {
		event: 'Recurring Buy Clicked',
		properties: props || {},
		options,
	}
	validateAgainstSchema(message, schema)

	const a = analytics()
	if (a) {
		a.track(
			'Recurring Buy Clicked',
			props || {},
			withTypewriterContext(options),
			callback
		)
	}
}
/**
 * The user clicks on a recurring buy to see the details of what is currently set up
 *
 * @param {RecurringBuyDetailsClicked} props - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function recurringBuyDetailsClicked(
	props: RecurringBuyDetailsClicked,
	options?: Segment.Options,
	callback?: Segment.Callback
): void {
	const schema = {
		$schema: 'http://json-schema.org/draft-07/schema#',
		description:
			'The user clicks on a recurring buy to see the details of what is currently set up',
		labels: {
			flow: 'buy_rec',
			source: 'client',
		},
		properties: {
			context: {},
			properties: {
				properties: {
					currency: {
						description:
							'Currency of the crypto being bought (output currency) for the recurring order',
						pattern: '^[A-Z]{3,5}$',
						type: 'string',
					},
					device: {
						description: 'Device type from where the event was triggered.\n',
						enum: ['APP-iOS', 'WEB', 'APP-Android'],
						type: 'string',
					},
					origin: {
						description:
							'What button we are referring to : CURRENCY_PAGE : Currency page (Coin View) of the coin being bought. TRANSACTION_LIST : From the historical transaction list, also called Activity in mobile',
						enum: ['CURRENCY_PAGE', 'TRANSACTION_LIST'],
						type: 'string',
					},
					platform: {
						description:
							'What platform the user is looking at recurring buy from',
						enum: ['WALLET'],
						type: 'string',
					},
				},
				required: ['origin', 'currency', 'device', 'platform'],
				type: 'object',
			},
			traits: {
				type: 'object',
			},
		},
		required: ['properties'],
		title: 'Recurring Buy Details Clicked',
		type: 'object',
	}
	const message = {
		event: 'Recurring Buy Details Clicked',
		properties: props || {},
		options,
	}
	validateAgainstSchema(message, schema)

	const a = analytics()
	if (a) {
		a.track(
			'Recurring Buy Details Clicked',
			props || {},
			withTypewriterContext(options),
			callback
		)
	}
}
/**
 * The user views some further information or description about the Recurring buy feature
 *
 * @param {RecurringBuyInfoViewed} props - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function recurringBuyInfoViewed(
	props: RecurringBuyInfoViewed,
	options?: Segment.Options,
	callback?: Segment.Callback
): void {
	const schema = {
		$schema: 'http://json-schema.org/draft-07/schema#',
		description:
			'The user views some further information or description about the Recurring buy feature',
		labels: {
			flow: 'buy_rec',
			source: 'client',
		},
		properties: {
			context: {},
			properties: {
				properties: {
					device: {
						description: 'Device type from where the event was triggered.',
						enum: ['APP-iOS', 'WEB', 'APP-Android'],
						type: 'string',
					},
					page: {
						description:
							'(From 0 to 4) If applicable : what page of the info is being viewed. ',
						type: ['integer', 'null'],
					},
					platform: {
						description:
							'What platform the user is looking at recurring buy from',
						enum: ['WALLET'],
						type: 'string',
					},
					type: {
						description:
							'type of info being viewed. e.g. DCA : Dollar Cost Averaging',
						enum: ['DCA'],
						type: 'string',
					},
				},
				required: ['page', 'platform', 'device'],
				type: 'object',
			},
			traits: {
				type: 'object',
			},
		},
		required: ['properties'],
		title: 'Recurring Buy Info Viewed',
		type: 'object',
	}
	const message = {
		event: 'Recurring Buy Info Viewed',
		properties: props || {},
		options,
	}
	validateAgainstSchema(message, schema)

	const a = analytics()
	if (a) {
		a.track(
			'Recurring Buy Info Viewed',
			props || {},
			withTypewriterContext(options),
			callback
		)
	}
}
/**
 * The user wants to learn more about the recurring buy feature. This could be bring the user either to an internal screen (Recurring Buy Info Viewed) or external link.
 *
 * @param {RecurringBuyLearnMoreClicked} props - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function recurringBuyLearnMoreClicked(
	props: RecurringBuyLearnMoreClicked,
	options?: Segment.Options,
	callback?: Segment.Callback
): void {
	const schema = {
		$schema: 'http://json-schema.org/draft-07/schema#',
		description:
			'The user wants to learn more about the recurring buy feature. This could be bring the user either to an internal screen (Recurring Buy Info Viewed) or external link.',
		labels: {
			flow: 'buy_rec',
			source: 'client',
		},
		properties: {
			context: {},
			properties: {
				properties: {
					device: {
						description: 'Device type from where the event was triggered.',
						enum: ['APP-iOS', 'WEB', 'APP-Android'],
						type: 'string',
					},
					origin: {
						description:
							'What button we are referring to. CURRENCY_PAGE : Currency page (Coin View) of the coin being bought. DASHBOARD_PROMO : announcement card or promo on dashboard.  DCA_DETAILS_LINK : the external link to learn more about the DCA method ',
						enum: ['CURRENCY_PAGE', 'DASHBOARD_PROMO', 'DCA_DETAILS_LINK'],
						type: 'string',
					},
					platform: {
						description:
							'What platform the user is looking at recurring buy from',
						enum: ['WALLET'],
						type: 'string',
					},
					type: {
						description:
							'What does the user want to learn more about ? DCA : Dollar Cost Averaging',
						enum: ['DCA'],
						type: 'string',
					},
				},
				required: ['origin', 'platform', 'device'],
				type: 'object',
			},
			traits: {
				type: 'object',
			},
		},
		required: ['properties'],
		title: 'Recurring Buy Learn More Clicked',
		type: 'object',
	}
	const message = {
		event: 'Recurring Buy Learn More Clicked',
		properties: props || {},
		options,
	}
	validateAgainstSchema(message, schema)

	const a = analytics()
	if (a) {
		a.track(
			'Recurring Buy Learn More Clicked',
			props || {},
			withTypewriterContext(options),
			callback
		)
	}
}
/**
 * The user reacted negatively on a screen suggesting to set up recurring buy. This could be either closing the suggestion or clicking on the negative option (Maybe Later, Skip, Exit, etc..)
 *
 * @param {RecurringBuySuggestionSkipped} props - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function recurringBuySuggestionSkipped(
	props: RecurringBuySuggestionSkipped,
	options?: Segment.Options,
	callback?: Segment.Callback
): void {
	const schema = {
		$schema: 'http://json-schema.org/draft-07/schema#',
		description:
			'The user reacted negatively on a screen suggesting to set up recurring buy. This could be either closing the suggestion or clicking on the negative option (Maybe Later, Skip, Exit, etc..)',
		labels: {
			flow: 'buy_rec',
			source: 'client',
		},
		properties: {
			context: {},
			properties: {
				properties: {
					device: {
						description: 'Device type from where the event was triggered.',
						enum: ['APP-iOS', 'WEB', 'APP-Android'],
						type: 'string',
					},
					origin: {
						description:
							'What recurring buy suggestion we are referring to. BUY_CONFIRMATION : at the end of the buy flow ("Maybe Later" at the suggestion screen)',
						enum: ['BUY_CONFIRMATION'],
						type: 'string',
					},
					platform: {
						description:
							'What platform the user is looking at recurring buy from',
						enum: ['WALLET'],
						type: 'string',
					},
				},
				required: ['device', 'origin'],
				type: 'object',
			},
			traits: {
				type: 'object',
			},
		},
		required: ['properties'],
		title: 'Recurring Buy Suggestion Skipped',
		type: 'object',
	}
	const message = {
		event: 'Recurring Buy Suggestion Skipped',
		properties: props || {},
		options,
	}
	validateAgainstSchema(message, schema)

	const a = analytics()
	if (a) {
		a.track(
			'Recurring Buy Suggestion Skipped',
			props || {},
			withTypewriterContext(options),
			callback
		)
	}
}
/**
 * The user was shown a warning about recurring buy unavailable
 *
 * @param {RecurringBuyUnavailableShown} props - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function recurringBuyUnavailableShown(
	props: RecurringBuyUnavailableShown,
	options?: Segment.Options,
	callback?: Segment.Callback
): void {
	const schema = {
		$schema: 'http://json-schema.org/draft-07/schema#',
		description: 'The user was shown a warning about recurring buy unavailable',
		labels: {
			flow: 'buy_rec',
			source: 'client',
		},
		properties: {
			context: {},
			properties: {
				properties: {
					device: {
						description: 'Device type from where the event was triggered.',
						enum: ['APP-iOS', 'WEB', 'APP-Android'],
						type: 'string',
					},
					platform: {
						description: 'What platform the user wants to buy from',
						enum: ['EXCHANGE', 'WALLET'],
						type: 'string',
					},
					reason: {
						description:
							'Reason for not being able to set up recurring buy. PAYMENT_METHOD_UNAVAILABLE : the current selected payment method is not available. (e.g. if cards payments cannot be used for that client for some reason) SELECT_PAYMENT : the user needs to select the payment method before selecting the frequency of the buy order, mainly shown for first time buyer. ',
						enum: ['PAYMENT_METHOD_UNAVAILABLE', 'SELECT_PAYMENT'],
						type: 'string',
					},
				},
				required: ['reason', 'platform', 'device'],
				type: 'object',
			},
			traits: {
				type: 'object',
			},
		},
		required: ['properties'],
		title: 'Recurring Buy Unavailable Shown',
		type: 'object',
	}
	const message = {
		event: 'Recurring Buy Unavailable Shown',
		properties: props || {},
		options,
	}
	validateAgainstSchema(message, schema)

	const a = analytics()
	if (a) {
		a.track(
			'Recurring Buy Unavailable Shown',
			props || {},
			withTypewriterContext(options),
			callback
		)
	}
}
/**
 * Recurring Buy Flow page or screen is viewed. This is triggered whenever the user opens the recurring buy flow from another part of the wallet
 *
 * @param {RecurringBuyViewed} props - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function recurringBuyViewed(
	props: RecurringBuyViewed,
	options?: Segment.Options,
	callback?: Segment.Callback
): void {
	const schema = {
		$schema: 'http://json-schema.org/draft-07/schema#',
		description:
			'Recurring Buy Flow page or screen is viewed. This is triggered whenever the user opens the recurring buy flow from another part of the wallet',
		labels: {
			flow: 'buy_rec',
			source: 'client',
		},
		properties: {
			context: {},
			properties: {
				properties: {
					device: {
						description: 'Device type from where the event was triggered.\n',
						enum: ['WEB', 'APP-Android'],
						type: 'string',
					},
					path: {
						description:
							'Path portion of the URL of the page. Equivalent to canonical path which defaults to location.pathname from the DOM API.',
						type: 'string',
					},
					platform: {
						description: 'What platform the page viewed belongs to',
						enum: ['WALLET'],
						type: 'string',
					},
					referrer: {
						description:
							'Full URL of the previous page. Equivalent to document.referrer from the DOM API.',
						type: 'string',
					},
					search: {
						description:
							'Query string portion of the URL of the page. Equivalent to location.search from the DOM API.',
						type: 'string',
					},
					title: {
						description:
							'Title of the page. Equivalent to document.title from the DOM API.',
						type: 'string',
					},
					url: {
						description:
							'Full URL of the page. First we look for the canonical url. If the canonical url is not provided, we use location.href from the DOM API.',
						type: 'string',
					},
				},
				required: ['platform', 'device'],
				type: 'object',
			},
			traits: {
				type: 'object',
			},
		},
		required: ['properties'],
		title: 'Recurring Buy Viewed',
		type: 'object',
	}
	const message = {
		event: 'Recurring Buy Viewed',
		properties: props || {},
		options,
	}
	validateAgainstSchema(message, schema)

	const a = analytics()
	if (a) {
		a.track(
			'Recurring Buy Viewed',
			props || {},
			withTypewriterContext(options),
			callback
		)
	}
}
/**
 * The browser will be remembered for a short period of time, allowing user to login again without having to re-authenticate. If Disabled, authentication is needed for every login.
 *
 * @param {RememberTwoStepVerificationUpdated} props - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function rememberTwoStepVerificationUpdated(
	props: RememberTwoStepVerificationUpdated,
	options?: Segment.Options,
	callback?: Segment.Callback
): void {
	const schema = {
		$schema: 'http://json-schema.org/draft-07/schema#',
		description:
			'The browser will be remembered for a short period of time, allowing user to login again without having to re-authenticate. If Disabled, authentication is needed for every login. ',
		labels: {
			flow: 'security_v1',
			source: 'backend',
		},
		properties: {
			context: {},
			properties: {
				properties: {
					device: {
						description: 'Device type from where the event was triggered.',
						enum: ['APP-iOS', 'WEB', 'APP-Android'],
						type: 'string',
					},
					is_enabled: {
						description:
							'If Enabled, browser will be remembered, allowing user to login again without having to re-authenticate. If Disabled, authentication is needed for every login. ',
						type: 'boolean',
					},
					platform: {
						description:
							'From what platform the user is managing Security events\n',
						enum: ['EXCHANGE', 'WALLET'],
						type: 'string',
					},
				},
				required: ['is_enabled', 'platform'],
				type: 'object',
			},
			traits: {
				type: 'object',
			},
		},
		required: ['properties'],
		title: 'Remember Two Step Verification Updated',
		type: 'object',
	}
	const message = {
		event: 'Remember Two Step Verification Updated',
		properties: props || {},
		options,
	}
	validateAgainstSchema(message, schema)

	const a = analytics()
	if (a) {
		a.track(
			'Remember Two Step Verification Updated',
			props || {},
			withTypewriterContext(options),
			callback
		)
	}
}
/**
 * The user clicks on the Add Card button to link a Card
 *
 * @param {RemoveLinkedCardClicked} props - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function removeLinkedCardClicked(
	props: RemoveLinkedCardClicked,
	options?: Segment.Options,
	callback?: Segment.Callback
): void {
	const schema = {
		$schema: 'http://json-schema.org/draft-07/schema#',
		description: 'The user clicks on the Add Card button to link a Card',
		labels: {
			flow: ['withdraw_v1', 'settings_v1'],
			source: 'client',
		},
		properties: {
			context: {},
			properties: {
				properties: {
					device: {
						description: 'Device type from where the event was triggered.',
						enum: ['APP-iOS', 'WEB', 'APP-Android'],
						type: 'string',
					},
					origin: {
						description:
							"What button we are referring to. SETTINGS : user's settings page. BUY : from the Buy flow.  ",
						enum: ['BUY', 'SETTINGS'],
						type: 'string',
					},
					platform: {
						description: 'What platform the user wants to link a bank for',
						enum: ['EXCHANGE', 'WALLET'],
						type: 'string',
					},
				},
				required: ['platform', 'origin', 'device'],
				type: 'object',
			},
			traits: {
				type: 'object',
			},
		},
		required: ['properties'],
		title: 'Remove Linked Card Clicked',
		type: 'object',
	}
	const message = {
		event: 'Remove Linked Card Clicked',
		properties: props || {},
		options,
	}
	validateAgainstSchema(message, schema)

	const a = analytics()
	if (a) {
		a.track(
			'Remove Linked Card Clicked',
			props || {},
			withTypewriterContext(options),
			callback
		)
	}
}
/**
 * When clicking on a button to discard reset flow, such as "Go Back" on a reset final warning or at the first confirmation
 *
 * @param {ResetAccountCancelled} props - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function resetAccountCancelled(
	props: ResetAccountCancelled,
	options?: Segment.Options,
	callback?: Segment.Callback
): void {
	const schema = {
		$schema: 'http://json-schema.org/draft-07/schema#',
		description:
			'When clicking on a button to discard reset flow, such as "Go Back" on a reset final warning or at the first confirmation',
		labels: {
			flow: 'recovery_v1',
			source: 'client',
		},
		properties: {
			context: {},
			properties: {
				properties: {
					device: {
						description: 'Device type from where the event was triggered.',
						enum: ['APP-iOS', 'WEB', 'APP-Android'],
						type: 'string',
					},
					exchange: {
						description: 'Parameters about the exchange account',
						properties: {
							two_fa_mode: {
								description: 'Whether the exchange account has 2FA set up',
								type: 'boolean',
							},
							user_id: {
								description: 'Exchange user credentials ID',
								type: 'string',
							},
						},
						required: [],
						type: 'object',
					},
					mergeable: {
						description: 'Indicates if possible to merge two unlinked accounts',
						type: 'boolean',
					},
					origin: {
						description:
							'What button we are referring to. RESET_CONFIRMATION : when confirming reset in reset flow. RESET_FINAL_WARNING : when confirming reset wish after the final warning ',
						enum: ['RESET_CONFIRMATION', 'RESET_FINAL_WARNING'],
						type: 'string',
					},
					platform: {
						description:
							'What platform the user is is recovering the account from',
						enum: ['WALLET', 'EXCHANGE'],
						type: 'string',
					},
					site_redirect: {
						description:
							'Whether the user is being redirected to the exchange or wallet',
						enum: ['EXCHANGE', 'WALLET'],
						type: 'string',
					},
					upgradeable: {
						description:
							'Indicates if possible to upgrade to a new unified Blockchain.com Account',
						type: 'boolean',
					},
					wallet: {
						description: 'Parameters about the wallet account',
						properties: {
							auth_type: {
								description: 'The wallet 2FA type that is enforced.',
								enum: [
									'0_NONE',
									'1_YUBIKEY',
									'2_EMAIL',
									'3_YUBIKEY_MTGOX',
									'4_GOOGLE_AUTHENTICATOR',
									'5_SMS',
								],
								type: 'string',
							},
							exchange: {
								description: 'Parameters about the exchange account',
								properties: {
									two_fa_mode: {
										description: 'Whether the exchange account has 2FA set up',
										properties: {},
										required: [],
										type: 'object',
									},
									user_id: {
										description: 'Exchange user credentials ID',
										type: 'object',
									},
								},
								required: [],
								type: 'object',
							},
							guid_first_four: {
								description:
									'The first four characters of the wallet.guid field',
								pattern: '^.{4,4}$',
								type: 'string',
							},
							has_cloud_backup: {
								description: 'Whether the wallet has cloud backups',
								type: 'boolean',
							},
							is_mobile_setup: {
								description: 'Whether the wallet has a mobile client set up',
								type: 'boolean',
							},
							last_mnemonic_backup: {
								description:
									'The last time, in unix timestamp, in which a wallet has their mnemonic backup verified',
								type: 'integer',
							},
							mobile_device_type: {
								description: 'The type of device being verified',
								enum: ['APP-Android', 'APP-iOS'],
								type: 'string',
							},
							nabu: {
								description: 'Parameter about the nabu account',
								properties: {
									recovery_eligible: {
										description:
											'Whether the nabu user is eligible for recovery. Usually if account has value (> $300 or 1 payment method linked)',
										type: 'boolean',
									},
									user_id: {
										description:
											'The Nabu User ID. This is from the users table in nabu gateway',
										type: 'object',
									},
								},
								required: [],
								type: 'object',
							},
						},
						required: [],
						type: 'object',
					},
				},
				required: ['origin', 'device', 'site_redirect', 'platform'],
				type: 'object',
			},
			traits: {
				type: 'object',
			},
		},
		required: ['properties'],
		title: 'Reset Account Cancelled',
		type: 'object',
	}
	const message = {
		event: 'Reset Account Cancelled',
		properties: props || {},
		options,
	}
	validateAgainstSchema(message, schema)

	const a = analytics()
	if (a) {
		a.track(
			'Reset Account Cancelled',
			props || {},
			withTypewriterContext(options),
			callback
		)
	}
}
/**
 * When clicking on a button to go to the reset account flow, such as "Reset your account"
 *
 * @param {ResetAccountClicked} props - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function resetAccountClicked(
	props: ResetAccountClicked,
	options?: Segment.Options,
	callback?: Segment.Callback
): void {
	const schema = {
		$schema: 'http://json-schema.org/draft-07/schema#',
		description:
			'When clicking on a button to go to the reset account flow, such as "Reset your account"',
		labels: {
			flow: 'recovery_v1',
			source: 'client',
		},
		properties: {
			context: {},
			properties: {
				properties: {
					device: {
						description: 'Device type from where the event was triggered.',
						enum: ['APP-iOS', 'WEB', 'APP-Android'],
						type: 'string',
					},
					exchange: {
						description: 'Parameters about the exchange account',
						properties: {
							two_fa_mode: {
								description: 'Whether the exchange account has 2FA set up',
								type: 'boolean',
							},
							user_id: {
								description: 'Exchange user credentials ID',
								type: 'string',
							},
						},
						required: [],
						type: 'object',
					},
					mergeable: {
						description: 'Indicates if possible to merge two unlinked accounts',
						type: 'boolean',
					},
					origin: {
						description:
							'What button we are referring to. RECOVERY_OPTIONS : when failing to choose between recovery options. RECOVERY_PHRASE : when failing to enter recovery phrase. RESET_CONFIRMATION : when confirming reset in reset flow. RESET_FINAL_WARNING : when confirming reset wish after the final warning ',
						enum: [
							'RECOVERY_OPTIONS',
							'RECOVERY_PHRASE',
							'RESET_CONFIRMATION',
							'RESET_FINAL_WARNING',
						],
						type: 'string',
					},
					platform: {
						description:
							'What platform the user is is recovering the account from',
						enum: ['WALLET', 'EXCHANGE'],
						type: 'string',
					},
					site_redirect: {
						description:
							'Whether the user is being redirected to the exchange or wallet',
						enum: ['EXCHANGE', 'WALLET'],
						type: 'string',
					},
					upgradeable: {
						description:
							'Indicates if possible to upgrade to a new unified Blockchain.com Account',
						type: 'boolean',
					},
					wallet: {
						description: 'Parameters about the wallet account',
						properties: {
							auth_type: {
								description: 'The wallet 2FA type that is enforced.',
								enum: [
									'0_NONE',
									'1_YUBIKEY',
									'2_EMAIL',
									'3_YUBIKEY_MTGOX',
									'4_GOOGLE_AUTHENTICATOR',
									'5_SMS',
								],
								type: 'string',
							},
							exchange: {
								description: 'Parameters about the exchange account',
								properties: {
									two_fa_mode: {
										description: 'Whether the exchange account has 2FA set up',
										properties: {},
										required: [],
										type: 'object',
									},
									user_id: {
										description: 'Exchange user credentials ID',
										type: 'object',
									},
								},
								required: [],
								type: 'object',
							},
							guid_first_four: {
								description:
									'The first four characters of the wallet.guid field',
								pattern: '^.{4,4}$',
								type: 'string',
							},
							has_cloud_backup: {
								description: 'Whether the wallet has cloud backups',
								type: 'boolean',
							},
							is_mobile_setup: {
								description: 'Whether the wallet has a mobile client set up',
								type: 'boolean',
							},
							last_mnemonic_backup: {
								description:
									'The last time, in unix timestamp, in which a wallet has their mnemonic backup verified',
								type: 'integer',
							},
							mobile_device_type: {
								description: 'The type of device being verified',
								enum: ['APP-Android', 'APP-iOS'],
								type: 'string',
							},
							nabu: {
								description: 'Parameter about the nabu account',
								properties: {
									recovery_eligible: {
										description:
											'Whether the nabu user is eligible for recovery. Usually if account has value (> $300 or 1 payment method linked)',
										type: 'boolean',
									},
									user_id: {
										description:
											'The Nabu User ID. This is from the users table in nabu gateway',
										type: 'object',
									},
								},
								required: [],
								type: 'object',
							},
						},
						required: [],
						type: 'object',
					},
				},
				required: ['origin', 'device', 'site_redirect', 'platform'],
				type: 'object',
			},
			traits: {
				type: 'object',
			},
		},
		required: ['properties'],
		title: 'Reset Account Clicked',
		type: 'object',
	}
	const message = {
		event: 'Reset Account Clicked',
		properties: props || {},
		options,
	}
	validateAgainstSchema(message, schema)

	const a = analytics()
	if (a) {
		a.track(
			'Reset Account Clicked',
			props || {},
			withTypewriterContext(options),
			callback
		)
	}
}
/**
 * Generic event when a user completes a revenue generating event
 *
 * @param {RevenueGenerated} props - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function revenueGenerated(
	props: RevenueGenerated,
	options?: Segment.Options,
	callback?: Segment.Callback
): void {
	const schema = {
		$schema: 'http://json-schema.org/draft-07/schema#',
		description:
			'Generic event when a user completes a revenue generating event',
		properties: {
			context: {},
			properties: {
				properties: {
					product_id: {
						description:
							"What product the user is buying, it's usually the trading pair of the order (e.g. BTC-EUR)",
						type: 'string',
					},
					profit: {
						description:
							'The approximated profit in usd that we make from the order. Usually a fixed approximate margin for Buy, Sell & Swap product, and the fee for trades',
						type: 'number',
					},
					revenue: {
						description:
							'The revenue amount in usd. This is the volume of crypto of fiat traded or bought from a buy, swap, sell or trade order',
						type: 'number',
					},
					revenue_type: {
						description: 'What type of revenue this is',
						enum: ['BUY', 'SELL', 'SWAP', 'TRADE'],
						type: 'string',
					},
				},
				required: ['revenue', 'revenue_type', 'product_id', 'profit'],
				type: 'object',
			},
			traits: {
				type: 'object',
			},
		},
		required: ['properties'],
		title: 'Revenue Generated',
		type: 'object',
	}
	const message = {
		event: 'Revenue Generated',
		properties: props || {},
		options,
	}
	validateAgainstSchema(message, schema)

	const a = analytics()
	if (a) {
		a.track(
			'Revenue Generated',
			props || {},
			withTypewriterContext(options),
			callback
		)
	}
}
/**
 * A user opens the search bar to search for a coin.
 *
 * @param {SearchCoinOpened} props - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function searchCoinOpened(
	props: SearchCoinOpened,
	options?: Segment.Options,
	callback?: Segment.Callback
): void {
	const schema = {
		$schema: 'http://json-schema.org/draft-07/schema#',
		description: 'A user opens the search bar to search for a coin.',
		labels: {
			flow: ['trade_e1', 'explorer'],
			source: 'client',
		},
		properties: {
			context: {},
			properties: {
				properties: {
					device: {
						description: 'Device type from where the event was triggered.',
						enum: ['APP-iOS', 'WEB', 'APP-Android'],
						type: 'string',
					},
					platform: {
						description: 'What platform the search is initiated from. ',
						enum: ['EXCHANGE', 'EXPLORER'],
						type: 'string',
					},
					search_type: {
						description:
							'What elements the user is looking for. TRADING_PAIR : trading pairs containing the coin. CRYPTO_PRICES : from the explorer price page',
						enum: ['CRYPTO_PRICES', 'TRADING_PAIR'],
						type: 'string',
					},
				},
				required: ['platform', 'device', 'search_type'],
				type: 'object',
			},
			traits: {
				type: 'object',
			},
		},
		required: ['properties'],
		title: 'Search Coin Opened',
		type: 'object',
	}
	const message = {
		event: 'Search Coin Opened',
		properties: props || {},
		options,
	}
	validateAgainstSchema(message, schema)

	const a = analytics()
	if (a) {
		a.track(
			'Search Coin Opened',
			props || {},
			withTypewriterContext(options),
			callback
		)
	}
}
/**
 * The user clicks the security section in the header (top right)

 *
 * @param {SecurityTabClicked} props - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function securityTabClicked(
	props: SecurityTabClicked,
	options?: Segment.Options,
	callback?: Segment.Callback
): void {
	const schema = {
		$schema: 'http://json-schema.org/draft-07/schema#',
		description:
			'The user clicks the security section in the header (top right)\n',
		labels: {
			flow: 'security_v1',
			source: 'client',
		},
		properties: {
			context: {},
			properties: {
				properties: {
					device: {
						description: 'Device type from where the event was triggered.',
						enum: ['WEB'],
						type: 'string',
					},
					platform: {
						description:
							'From what platform the user clicking the Security options',
						enum: ['EXCHANGE', 'WALLET'],
						type: 'string',
					},
				},
				required: ['platform', 'device'],
				type: 'object',
			},
			traits: {
				type: 'object',
			},
		},
		required: ['properties'],
		title: 'Security Tab Clicked',
		type: 'object',
	}
	const message = {
		event: 'Security Tab Clicked',
		properties: props || {},
		options,
	}
	validateAgainstSchema(message, schema)

	const a = analytics()
	if (a) {
		a.track(
			'Security Tab Clicked',
			props || {},
			withTypewriterContext(options),
			callback
		)
	}
}
/**
 * The user enters and submits the amount for a sell transaction
 *
 * @param {SellAmountEntered} props - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function sellAmountEntered(
	props: SellAmountEntered,
	options?: Segment.Options,
	callback?: Segment.Callback
): void {
	const schema = {
		$schema: 'http://json-schema.org/draft-07/schema#',
		description:
			'The user enters and submits the amount for a sell transaction',
		labels: {
			flow: 'sell_v1',
			source: 'client',
		},
		properties: {
			context: {},
			properties: {
				properties: {
					device: {
						description: 'Device type from where the event was triggered.',
						enum: ['APP-iOS', 'WEB', 'APP-Android'],
						type: 'string',
					},
					from_account_type: {
						description:
							'What type of account the user wants to sell funds from.',
						enum: ['SAVINGS', 'TRADING', 'USERKEY'],
						type: 'string',
					},
					input_amount: {
						description:
							'The expected amount for the input currency, usually as a float. For BTC, it should be for example 1.23, meaning 1.23 BTC',
						type: 'number',
					},
					input_currency: {
						description:
							'Currency symbol for the crypto currency being sent by the user in exchange for some fiat. For example BTC',
						pattern: '^[A-Z]{3,5}$',
						type: 'string',
					},
					output_currency: {
						description:
							'Currency symbol for the currency being received by the user. For example USD',
						pattern: '^[A-Z]{3,5}$',
						type: 'string',
					},
					platform: {
						description: 'What platform the user is to selling from',
						enum: ['EXCHANGE', 'WALLET'],
						type: 'string',
					},
				},
				required: [
					'output_currency',
					'input_currency',
					'input_amount',
					'platform',
					'from_account_type',
					'device',
				],
				type: 'object',
			},
			traits: {
				type: 'object',
			},
		},
		required: ['properties'],
		title: 'Sell Amount Entered',
		type: 'object',
	}
	const message = {
		event: 'Sell Amount Entered',
		properties: props || {},
		options,
	}
	validateAgainstSchema(message, schema)

	const a = analytics()
	if (a) {
		a.track(
			'Sell Amount Entered',
			props || {},
			withTypewriterContext(options),
			callback
		)
	}
}
/**
 * The user clicks on the widget or button which sets the max amount allowed or possible to sell from the account
 *
 * @param {SellAmountMaxClicked} props - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function sellAmountMaxClicked(
	props: SellAmountMaxClicked,
	options?: Segment.Options,
	callback?: Segment.Callback
): void {
	const schema = {
		$schema: 'http://json-schema.org/draft-07/schema#',
		description:
			'The user clicks on the widget or button which sets the max amount allowed or possible to sell from the account',
		labels: {
			flow: 'sell_v1',
			source: 'client',
		},
		properties: {
			context: {},
			properties: {
				properties: {
					device: {
						description: 'Device type from where the event was triggered.',
						enum: ['APP-iOS', 'WEB', 'APP-Android'],
						type: 'string',
					},
					from_account_type: {
						description:
							'What type of account the user wants to sell funds from.',
						enum: ['SAVINGS', 'TRADING', 'USERKEY'],
						type: 'string',
					},
					input_currency: {
						description:
							'Currency symbol for the crypto currency being sent by the user in exchange for some fiat. For example BTC',
						pattern: '^[A-Z]{3,5}$',
						type: 'string',
					},
					output_currency: {
						description:
							'Currency symbol for the currency being received by the user. For example USD',
						pattern: '^[A-Z]{3,5}$',
						type: 'string',
					},
					platform: {
						description: 'What platform the user is to selling from',
						enum: ['EXCHANGE', 'WALLET'],
						type: 'string',
					},
				},
				required: [
					'output_currency',
					'input_currency',
					'platform',
					'from_account_type',
					'device',
				],
				type: 'object',
			},
			traits: {
				type: 'object',
			},
		},
		required: ['properties'],
		title: 'Sell Amount Max Clicked',
		type: 'object',
	}
	const message = {
		event: 'Sell Amount Max Clicked',
		properties: props || {},
		options,
	}
	validateAgainstSchema(message, schema)

	const a = analytics()
	if (a) {
		a.track(
			'Sell Amount Max Clicked',
			props || {},
			withTypewriterContext(options),
			callback
		)
	}
}
/**
 * The user clicks on the widget or button which sets the min amount allowed or possible to sell from the account
 *
 * @param {SellAmountMinClicked} props - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function sellAmountMinClicked(
	props: SellAmountMinClicked,
	options?: Segment.Options,
	callback?: Segment.Callback
): void {
	const schema = {
		$schema: 'http://json-schema.org/draft-07/schema#',
		description:
			'The user clicks on the widget or button which sets the min amount allowed or possible to sell from the account',
		labels: {
			flow: 'sell_v1',
			source: 'client',
		},
		properties: {
			context: {},
			properties: {
				properties: {
					device: {
						description: 'Device type from where the event was triggered.',
						enum: ['APP-iOS', 'WEB', 'APP-Android'],
						type: 'string',
					},
					from_account_type: {
						description:
							'What type of account the user wants to sell funds from.',
						enum: ['SAVINGS', 'TRADING', 'USERKEY'],
						type: 'string',
					},
					input_currency: {
						description:
							'Currency symbol for the crypto currency being sent by the user in exchange for some fiat. For example BTC',
						pattern: '^[A-Z]{3,5}$',
						type: 'string',
					},
					output_currency: {
						description:
							'Currency symbol for the currency being received by the user. For example USD',
						pattern: '^[A-Z]{3,5}$',
						type: 'string',
					},
					platform: {
						description: 'What platform the user is to selling from',
						enum: ['EXCHANGE', 'WALLET'],
						type: 'string',
					},
				},
				required: [
					'output_currency',
					'input_currency',
					'platform',
					'from_account_type',
					'device',
				],
				type: 'object',
			},
			traits: {
				type: 'object',
			},
		},
		required: ['properties'],
		title: 'Sell Amount Min Clicked',
		type: 'object',
	}
	const message = {
		event: 'Sell Amount Min Clicked',
		properties: props || {},
		options,
	}
	validateAgainstSchema(message, schema)

	const a = analytics()
	if (a) {
		a.track(
			'Sell Amount Min Clicked',
			props || {},
			withTypewriterContext(options),
			callback
		)
	}
}
/**
 * Sell order submitted by the user was cancelled (when updating to final state CANCELED either the simple or custodial transaction from nabu gateway )
 *
 * @param {SellCancelled} props - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function sellCancelled(
	props: SellCancelled,
	options?: Segment.Options,
	callback?: Segment.Callback
): void {
	const schema = {
		$schema: 'http://json-schema.org/draft-07/schema#',
		description:
			'Sell order submitted by the user was cancelled (when updating to final state CANCELED either the simple or custodial transaction from nabu gateway )',
		labels: {
			flow: 'sell_v1',
			source: 'backend',
		},
		properties: {
			context: {},
			properties: {
				properties: {
					device: {
						description: 'Device the sell order was made from',
						enum: ['APP-Android', 'APP-iOS', 'WEB'],
						type: 'string',
					},
					from_account_type: {
						description:
							'What type of account the user wants to sell funds from. For simple_transactions with paymentType "Funds", it is TRADING. For custodial transactions, it is TRADING for INTERNAL type, or USERKEY for FROM_USERKEY type. \nSAVINGS : interest saving account. ',
						enum: ['SAVINGS', 'TRADING', 'USERKEY'],
						type: 'string',
					},
					input_amount: {
						description:
							'The expected amount for the input currency, usually as a float. For BTC, it should be for example 1.23, meaning 1.23 BTC. Exact amount is only in Buy Completed',
						type: 'number',
					},
					input_amount_usd: {
						description:
							'The amount of crypto sold by the user in USD, usually as a float. it should be for example 10.23, meaning $10.23 worth of crypto was sold',
						type: 'number',
					},
					input_currency: {
						description:
							'Currency symbol for the crypto currency being sent by the user in exchange for some fiat. For example BTC\n',
						pattern: '^[A-Z]{3,5}$',
						type: 'string',
					},
					output_amount: {
						description:
							'The expected amount for the output currency, usually as a float. For USD, it should be for example 1.23, meaning 1.23 USD. Exact amount is only in Sell Completed',
						type: 'number',
					},
					output_currency: {
						description:
							'Currency symbol for the currency being received by the user. For example USD\n',
						pattern: '^[A-Z]{3,5}$',
						type: 'string',
					},
					paltform: {
						description:
							'What platform the event was started from. (WALLET if product=SIMPLEBUY and EXCHANGE if product=MERCURY',
						enum: ['EXCHANGE', 'WALLET'],
						type: 'string',
					},
					payment_id: {
						description:
							'id of the payment (id of the transaction from nabu payments)',
						type: 'string',
					},
					product: {
						description:
							"The Product for which the sell order is (the product columns of the simple_transactions table, or SIMPLEBUY for custodial transactions since they aren't used in the Exchange Simple Trade product)",
						enum: ['MERCURY', 'SIMPLEBUY'],
						type: 'string',
					},
					transaction_id: {
						description:
							'The id of the transaction for the sell order (the id of either the  simple_transactions or the custodial_transactions table in nabu gateway)',
						type: 'string',
					},
				},
				required: [
					'input_currency',
					'from_account_type',
					'product',
					'output_currency',
					'paltform',
				],
				type: 'object',
			},
			traits: {
				type: 'object',
			},
		},
		required: ['properties'],
		title: 'Sell Cancelled',
		type: 'object',
	}
	const message = {
		event: 'Sell Cancelled',
		properties: props || {},
		options,
	}
	validateAgainstSchema(message, schema)

	const a = analytics()
	if (a) {
		a.track(
			'Sell Cancelled',
			props || {},
			withTypewriterContext(options),
			callback
		)
	}
}
/**
 * Sell order is completed (when updating to final state FINISHED either the simple or custodial transaction from nabu gateway )
 *
 * @param {SellCompleted} props - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function sellCompleted(
	props: SellCompleted,
	options?: Segment.Options,
	callback?: Segment.Callback
): void {
	const schema = {
		$schema: 'http://json-schema.org/draft-07/schema#',
		description:
			'Sell order is completed (when updating to final state FINISHED either the simple or custodial transaction from nabu gateway )',
		labels: {
			flow: 'sell_v1',
			source: 'backend',
		},
		properties: {
			context: {},
			properties: {
				properties: {
					device: {
						description: 'Device the sell order was made from',
						enum: ['APP-Android', 'APP-iOS', 'WEB'],
						type: 'string',
					},
					from_account_type: {
						description:
							'What type of account the user wants to sell funds from. For simple_transactions with paymentType "Funds", it is TRADING. For custodial transactions, it is TRADING for INTERNAL type, or USERKEY for FROM_USERKEY type. \nSAVINGS : interest saving account. ',
						enum: ['SAVINGS', 'TRADING', 'USERKEY'],
						type: 'string',
					},
					input_amount: {
						description:
							'The expected amount for the input currency, usually as a float. For BTC, it should be for example 1.23, meaning 1.23 BTC. Exact amount is only in Buy Completed',
						type: 'number',
					},
					input_amount_usd: {
						description:
							'The amount of crypto sold by the user in USD, usually as a float. it should be for example 10.23, meaning $10.23 worth of crypto was sold',
						type: 'number',
					},
					input_currency: {
						description:
							'Currency symbol for the crypto currency being sent by the user in exchange for some fiat. For example BTC\n',
						pattern: '^[A-Z]{3,5}$',
						type: 'string',
					},
					output_amount: {
						description:
							'The expected amount for the output currency, usually as a float. For USD, it should be for example 1.23, meaning 1.23 USD. Exact amount is only in Sell Completed',
						type: 'number',
					},
					output_currency: {
						description:
							'Currency symbol for the currency being received by the user. For example USD\n',
						pattern: '^[A-Z]{3,5}$',
						type: 'string',
					},
					platform: {
						description:
							'What platform the event was started from. (WALLET if product=SIMPLEBUY and EXCHANGE if product=MERCURY\n',
						enum: ['EXCHANGE', 'WALLET'],
						type: 'string',
					},
					product: {
						description:
							"The Product for which the sell order is (the product columns of the simple_transactions table, or SIMPLEBUY for custodial transactions since they aren't used in the Exchange Simple Trade product)",
						enum: ['MERCURY', 'SIMPLEBUY'],
						type: 'string',
					},
					spread_percentage: {
						description: 'Spread percentage applied to the exchange rate',
						type: 'number',
					},
					transaction_id: {
						description:
							'The id of the transaction for the sell order (the id of either the  simple_transactions or the custodial_transactions table in nabu gateway)',
						type: 'string',
					},
				},
				required: [
					'input_currency',
					'platform',
					'from_account_type',
					'product',
					'input_amount_usd',
					'spread_percentage',
					'output_currency',
				],
				type: 'object',
			},
			traits: {
				type: 'object',
			},
		},
		required: ['properties'],
		title: 'Sell Completed',
		type: 'object',
	}
	const message = {
		event: 'Sell Completed',
		properties: props || {},
		options,
	}
	validateAgainstSchema(message, schema)

	const a = analytics()
	if (a) {
		a.track(
			'Sell Completed',
			props || {},
			withTypewriterContext(options),
			callback
		)
	}
}
/**
 * User submits a sell order (when creating a simple transactions with state CREATED, or custodial transactions from crypto to fiat with state CREATED)
 *
 * @param {SellCreated} props - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function sellCreated(
	props: SellCreated,
	options?: Segment.Options,
	callback?: Segment.Callback
): void {
	const schema = {
		$schema: 'http://json-schema.org/draft-07/schema#',
		description:
			'User submits a sell order (when creating a simple transactions with state CREATED, or custodial transactions from crypto to fiat with state CREATED)',
		labels: {
			flow: 'sell_v1',
			source: 'backend',
		},
		properties: {
			context: {},
			properties: {
				properties: {
					device: {
						description: 'Device the sell order was made from',
						enum: ['APP-Android', 'APP-iOS', 'WEB'],
						type: 'string',
					},
					from_account_type: {
						description:
							'What type of account the user wants to sell funds from. For simple_transactions with paymentType "Funds", it is TRADING. For custodial transactions, it is TRADING for INTERNAL type, or USERKEY for FROM_USERKEY type. \nSAVINGS : interest saving account. ',
						enum: ['SAVINGS', 'TRADING', 'USERKEY'],
						type: 'string',
					},
					input_amount: {
						description:
							'The expected amount for the input currency, usually as a float. For BTC, it should be for example 1.23, meaning 1.23 BTC. Exact amount is only in Buy Completed',
						type: 'number',
					},
					input_amount_usd: {
						description:
							'The amount of crypto sold by the user in USD, usually as a float. it should be for example 10.23, meaning $10.23 worth of crypto was sold',
						type: 'number',
					},
					input_currency: {
						description:
							'Currency symbol for the crypto currency being sent by the user in exchange for some fiat. For example BTC\n',
						pattern: '^[A-Z]{3,5}$',
						type: 'string',
					},
					output_amount: {
						description:
							'The expected amount for the output currency, usually as a float. For USD, it should be for example 1.23, meaning 1.23 USD. Exact amount is only in Sell Completed',
						type: 'number',
					},
					output_currency: {
						description:
							'Currency symbol for the currency being received by the user. For example USD\n',
						pattern: '^[A-Z]{3,5}$',
						type: 'string',
					},
					payment_id: {
						description:
							'id of the payment (id of the transaction from nabu payments)',
						type: 'string',
					},
					platform: {
						description:
							'What platform the event was started from. (WALLET if product=SIMPLEBUY and EXCHANGE if product=MERCURY\n',
						enum: ['EXCHANGE', 'WALLET'],
						type: 'string',
					},
					product: {
						description:
							"The Product for which the sell order is (the product columns of the simple_transactions table, or SIMPLEBUY for custodial transactions since they aren't used in the Exchange Simple Trade product)",
						enum: ['MERCURY', 'SIMPLEBUY'],
						type: 'string',
					},
					transaction_id: {
						description:
							'The id of the transaction for the sell order (the id of either the  simple_transactions or the custodial_transactions table in nabu gateway)',
						type: 'string',
					},
				},
				required: [
					'input_currency',
					'from_account_type',
					'platform',
					'product',
					'output_currency',
				],
				type: 'object',
			},
			traits: {
				type: 'object',
			},
		},
		required: ['properties'],
		title: 'Sell Created',
		type: 'object',
	}
	const message = {
		event: 'Sell Created',
		properties: props || {},
		options,
	}
	validateAgainstSchema(message, schema)

	const a = analytics()
	if (a) {
		a.track(
			'Sell Created',
			props || {},
			withTypewriterContext(options),
			callback
		)
	}
}
/**
 * Sell order has expired (when updating to final state EXPIRED either the simple or custodial transaction from nabu gateway )
 *
 * @param {SellExpired} props - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function sellExpired(
	props: SellExpired,
	options?: Segment.Options,
	callback?: Segment.Callback
): void {
	const schema = {
		$schema: 'http://json-schema.org/draft-07/schema#',
		description:
			'Sell order has expired (when updating to final state EXPIRED either the simple or custodial transaction from nabu gateway )',
		labels: {
			flow: 'sell_v1',
			source: 'backend',
		},
		properties: {
			context: {},
			properties: {
				properties: {
					device: {
						description: 'Device the sell order was made from',
						enum: ['APP-Android', 'APP-iOS', 'WEB'],
						type: 'string',
					},
					from_account_type: {
						description:
							'What type of account the user wants to sell funds from. For simple_transactions with paymentType "Funds", it is TRADING. For custodial transactions, it is TRADING for INTERNAL type, or USERKEY for FROM_USERKEY type. \nSAVINGS : interest saving account. ',
						enum: ['SAVINGS', 'TRADING', 'USERKEY'],
						type: 'string',
					},
					input_amount: {
						description:
							'The expected amount for the input currency, usually as a float. For BTC, it should be for example 1.23, meaning 1.23 BTC. Exact amount is only in Buy Completed',
						type: 'number',
					},
					input_amount_usd: {
						description:
							'The amount of crypto sold by the user in USD, usually as a float. it should be for example 10.23, meaning $10.23 worth of crypto was sold',
						type: 'number',
					},
					input_currency: {
						description:
							'Currency symbol for the crypto currency being sent by the user in exchange for some fiat. For example BTC\n',
						pattern: '^[A-Z]{3,5}$',
						type: 'string',
					},
					output_amount: {
						description:
							'The expected amount for the output currency, usually as a float. For USD, it should be for example 1.23, meaning 1.23 USD. Exact amount is only in Sell Completed',
						type: 'number',
					},
					output_currency: {
						description:
							'Currency symbol for the currency being received by the user. For example USD\n',
						pattern: '^[A-Z]{3,5}$',
						type: 'string',
					},
					payment_id: {
						description:
							'id of the payment (id of the transaction from nabu payments)',
						type: 'string',
					},
					platform: {
						description:
							'What platform the event was started from. (WALLET if product=SIMPLEBUY and EXCHANGE if product=MERCURY\n',
						enum: ['EXCHANGE', 'WALLET'],
						type: 'string',
					},
					product: {
						description:
							"The Product for which the sell order is (the product columns of the simple_transactions table, or SIMPLEBUY for custodial transactions since they aren't used in the Exchange Simple Trade product)",
						enum: ['MERCURY', 'SIMPLEBUY'],
						type: 'string',
					},
					transaction_id: {
						description:
							'The id of the transaction for the sell order (the id of either the  simple_transactions or the custodial_transactions table in nabu gateway)',
						type: 'string',
					},
				},
				required: [
					'input_currency',
					'from_account_type',
					'product',
					'output_currency',
					'platform',
				],
				type: 'object',
			},
			traits: {
				type: 'object',
			},
		},
		required: ['properties'],
		title: 'Sell Expired',
		type: 'object',
	}
	const message = {
		event: 'Sell Expired',
		properties: props || {},
		options,
	}
	validateAgainstSchema(message, schema)

	const a = analytics()
	if (a) {
		a.track(
			'Sell Expired',
			props || {},
			withTypewriterContext(options),
			callback
		)
	}
}
/**
 * Sell order has failed (when updating to final state FAILED either the simple or custodial transaction from nabu gateway )
 *
 * @param {SellFailed} props - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function sellFailed(
	props: SellFailed,
	options?: Segment.Options,
	callback?: Segment.Callback
): void {
	const schema = {
		$schema: 'http://json-schema.org/draft-07/schema#',
		description:
			'Sell order has failed (when updating to final state FAILED either the simple or custodial transaction from nabu gateway )',
		labels: {
			flow: 'sell_v1',
			source: 'backend',
		},
		properties: {
			context: {},
			properties: {
				properties: {
					device: {
						description: 'Device the sell order was made from',
						enum: ['APP-Android', 'APP-iOS', 'WEB'],
						type: 'string',
					},
					from_account_type: {
						description:
							'What type of account the user wants to sell funds from. For simple_transactions with paymentType "Funds", it is TRADING. For custodial transactions, it is TRADING for INTERNAL type, or USERKEY for FROM_USERKEY type. \nSAVINGS : interest saving account. ',
						enum: ['SAVINGS', 'TRADING', 'USERKEY'],
						type: 'string',
					},
					input_amount: {
						description:
							'The expected amount for the input currency, usually as a float. For BTC, it should be for example 1.23, meaning 1.23 BTC. Exact amount is only in Buy Completed',
						type: 'number',
					},
					input_amount_usd: {
						description:
							'The amount of crypto sold by the user in USD, usually as a float. it should be for example 10.23, meaning $10.23 worth of crypto was sold',
						type: 'number',
					},
					input_currency: {
						description:
							'Currency symbol for the crypto currency being sent by the user in exchange for some fiat. For example BTC\n',
						pattern: '^[A-Z]{3,5}$',
						type: 'string',
					},
					output_amount: {
						description:
							'The expected amount for the output currency, usually as a float. For USD, it should be for example 1.23, meaning 1.23 USD. Exact amount is only in Sell Completed',
						type: 'number',
					},
					output_currency: {
						description:
							'Currency symbol for the currency being received by the user. For example USD\n',
						pattern: '^[A-Z]{3,5}$',
						type: 'string',
					},
					payment_id: {
						description:
							'id of the payment (id of the transaction from nabu payments)',
						type: 'string',
					},
					platform: {
						description:
							'What platform the event was started from. (WALLET if product=SIMPLEBUY and EXCHANGE if product=MERCURY\n',
						enum: ['EXCHANGE', 'WALLET'],
						type: 'string',
					},
					product: {
						description:
							"The Product for which the sell order is (the product columns of the simple_transactions table, or SIMPLEBUY for custodial transactions since they aren't used in the Exchange Simple Trade product)",
						enum: ['MERCURY', 'SIMPLEBUY'],
						type: 'string',
					},
					transaction_id: {
						description:
							'The id of the transaction for the sell order (the id of either the  simple_transactions or the custodial_transactions table in nabu gateway)',
						type: 'string',
					},
				},
				required: [
					'input_currency',
					'from_account_type',
					'product',
					'platform',
					'output_currency',
				],
				type: 'object',
			},
			traits: {
				type: 'object',
			},
		},
		required: ['properties'],
		title: 'Sell Failed',
		type: 'object',
	}
	const message = {
		event: 'Sell Failed',
		properties: props || {},
		options,
	}
	validateAgainstSchema(message, schema)

	const a = analytics()
	if (a) {
		a.track(
			'Sell Failed',
			props || {},
			withTypewriterContext(options),
			callback
		)
	}
}
/**
 * The user selects what currency and from what account he wants to sell. Event is triggered when a specific account and currency are selected from a dropdown or list of potential accounts. If it comes from two dropdown, it should be triggered once both have been selected.
 *
 * @param {SellFromSelected} props - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function sellFromSelected(
	props: SellFromSelected,
	options?: Segment.Options,
	callback?: Segment.Callback
): void {
	const schema = {
		$schema: 'http://json-schema.org/draft-07/schema#',
		description:
			'The user selects what currency and from what account he wants to sell. Event is triggered when a specific account and currency are selected from a dropdown or list of potential accounts. If it comes from two dropdown, it should be triggered once both have been selected.',
		labels: {
			flow: 'sell_v1',
			source: 'client',
		},
		properties: {
			context: {},
			properties: {
				properties: {
					device: {
						description: 'Device type from where the event was triggered.',
						enum: ['APP-iOS', 'WEB', 'APP-Android'],
						type: 'string',
					},
					from_account_type: {
						description:
							'What type of account the user wants to sell funds from.',
						enum: ['SAVINGS', 'TRADING', 'USERKEY'],
						type: 'string',
					},
					input_currency: {
						description:
							'Currency symbol for the crypto currency being sent by the user in exchange for some fiat. For example BTC',
						pattern: '^[A-Z]{3,5}$',
						type: 'string',
					},
					platform: {
						description: 'What platform the user is to selling from',
						enum: ['EXCHANGE', 'WALLET'],
						type: 'string',
					},
				},
				required: ['from_account_type', 'device', 'input_currency', 'platform'],
				type: 'object',
			},
			traits: {
				type: 'object',
			},
		},
		required: ['properties'],
		title: 'Sell From Selected',
		type: 'object',
	}
	const message = {
		event: 'Sell From Selected',
		properties: props || {},
		options,
	}
	validateAgainstSchema(message, schema)

	const a = analytics()
	if (a) {
		a.track(
			'Sell From Selected',
			props || {},
			withTypewriterContext(options),
			callback
		)
	}
}
/**
 * Sell order submitted by the user is rejected. it is not being created at all
 *
 * @param {SellRejected} props - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function sellRejected(
	props: SellRejected,
	options?: Segment.Options,
	callback?: Segment.Callback
): void {
	const schema = {
		$schema: 'http://json-schema.org/draft-07/schema#',
		description:
			'Sell order submitted by the user is rejected. it is not being created at all',
		labels: {
			flow: 'sell_v1',
			source: 'backend',
		},
		properties: {
			context: {},
			properties: {
				properties: {
					device: {
						description: 'Device the sell order was made from',
						enum: ['APP-Android', 'APP-iOS', 'WEB'],
						type: 'string',
					},
					error_reason: {
						description:
							'Error message related to the rejection. This is more detailed than the rejection_reason ',
						type: 'string',
					},
					from_account_type: {
						description:
							'What type of account the user wants to sell funds from. For simple_transactions with paymentType "Funds", it is TRADING. For custodial transactions, it is TRADING for INTERNAL type, or USERKEY for FROM_USERKEY type. \nSAVINGS : interest saving account. ',
						enum: ['SAVINGS', 'TRADING', 'USERKEY'],
						type: 'string',
					},
					input_amount: {
						description:
							'The expected amount for the input currency, usually as a float. For BTC, it should be for example 1.23, meaning 1.23 BTC. Exact amount is only in Buy Completed',
						type: 'number',
					},
					input_amount_usd: {
						description:
							'The amount of crypto sold by the user in USD, usually as a float. it should be for example 10.23, meaning $10.23 worth of crypto was sold',
						type: 'number',
					},
					input_currency: {
						description:
							'Currency symbol for the crypto currency being sent by the user in exchange for some fiat. For example BTC\n',
						pattern: '^[A-Z]{3,5}$',
						type: 'string',
					},
					output_amount: {
						description:
							'The expected amount for the output currency, usually as a float. For USD, it should be for example 1.23, meaning 1.23 USD. Exact amount is only in Sell Completed',
						type: 'number',
					},
					output_currency: {
						description:
							'Currency symbol for the currency being received by the user. For example USD\n',
						pattern: '^[A-Z]{3,5}$',
						type: 'string',
					},
					payment_id: {
						description:
							'id of the payment (id of the transaction from nabu payments)',
						type: 'string',
					},
					platform: {
						description:
							'What platform the event was started from. (WALLET if product=SIMPLEBUY and EXCHANGE if product=MERCURY\n',
						enum: ['EXCHANGE', 'WALLET'],
						type: 'string',
					},
					product: {
						description:
							"The Product for which the sell order is (the product columns of the simple_transactions table, or SIMPLEBUY for custodial transactions since they aren't used in the Exchange Simple Trade product)",
						enum: ['MERCURY', 'SIMPLEBUY'],
						type: 'string',
					},
					rejection_reason: {
						description: 'Raison of the rejection',
						type: 'string',
					},
					transaction_id: {
						description:
							'The id of the transaction for the sell order (the id of either the  simple_transactions or the custodial_transactions table in nabu gateway)',
						type: 'string',
					},
				},
				required: [
					'product',
					'output_currency',
					'input_currency',
					'platform',
					'from_account_type',
				],
				type: 'object',
			},
			traits: {
				type: 'object',
			},
		},
		required: ['properties'],
		title: 'Sell Rejected',
		type: 'object',
	}
	const message = {
		event: 'Sell Rejected',
		properties: props || {},
		options,
	}
	validateAgainstSchema(message, schema)

	const a = analytics()
	if (a) {
		a.track(
			'Sell Rejected',
			props || {},
			withTypewriterContext(options),
			callback
		)
	}
}
/**
 * A user enters and submits the amount that he wants to send. The user will typically have to confirm the send order in the next step.
 *
 * @param {SendAmountEntered} props - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function sendAmountEntered(
	props: SendAmountEntered,
	options?: Segment.Options,
	callback?: Segment.Callback
): void {
	const schema = {
		$schema: 'http://json-schema.org/draft-07/schema#',
		description:
			'A user enters and submits the amount that he wants to send. The user will typically have to confirm the send order in the next step. ',
		labels: {
			flow: 'send_v1',
			source: 'client',
		},
		properties: {
			context: {},
			properties: {
				properties: {
					currency: {
						description: 'The currency the user wants to send (e.g. BTC)',
						pattern: '^[A-Z]{3,5}$',
						type: 'string',
					},
					device: {
						description: 'Device type from where the event was triggered.\n',
						enum: ['APP-iOS', 'WEB', 'APP-Android'],
						type: 'string',
					},
					fee_rate: {
						description:
							'What fee rate is used for sending the crypto. The user may or may not have selected it explicitly, for transfers from custodial wallets for example. BACKEND : the backend will chose what fee_rate to apply. CUSTOM : custom priority defined by the user. NORMAL : normal priority for transactions according to our fee estimation.  PRIORITY : high priority for transactions according to our fee estimation.',
						enum: ['BACKEND', 'CUSTOM', 'NORMAL', 'PRIORITY'],
						type: 'string',
					},
					from_account_type: {
						description:
							'To what type of account the user wants to send funds from. \nSAVINGS : interest saving account. \nTRADING : wallet custodial wallet. \nUSERKEY : Non Custodial, Private Key, wallet',
						enum: ['SAVINGS', 'TRADING', 'USERKEY'],
						type: 'string',
					},
					platform: {
						description: 'From what platform the user is sending crypto from',
						enum: ['WALLET'],
						type: 'string',
					},
					to_account_type: {
						description:
							'To what type of account the user wants to send funds to. EXCHANGE : Blockchain Exchange wallet \nEXTERNAL : external address outside Blockchain.com. \nSAVINGS : interest saving account. \nTRADING : wallet custodial wallet. \nUSERKEY : Non Custodial, Private Key, wallet',
						enum: ['EXCHANGE', 'EXTERNAL', 'SAVINGS', 'TRADING', 'USERKEY'],
						type: 'string',
					},
				},
				required: [
					'currency',
					'from_account_type',
					'to_account_type',
					'fee_rate',
					'device',
					'platform',
				],
				type: 'object',
			},
			traits: {
				type: 'object',
			},
		},
		required: ['properties'],
		title: 'Send Amount Entered',
		type: 'object',
	}
	const message = {
		event: 'Send Amount Entered',
		properties: props || {},
		options,
	}
	validateAgainstSchema(message, schema)

	const a = analytics()
	if (a) {
		a.track(
			'Send Amount Entered',
			props || {},
			withTypewriterContext(options),
			callback
		)
	}
}
/**
 * A user the maximum amount he can send
 *
 * @param {SendAmountMaxClicked} props - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function sendAmountMaxClicked(
	props: SendAmountMaxClicked,
	options?: Segment.Options,
	callback?: Segment.Callback
): void {
	const schema = {
		$schema: 'http://json-schema.org/draft-07/schema#',
		description: 'A user the maximum amount he can send',
		labels: {
			flow: 'send_v1',
			source: 'client',
		},
		properties: {
			context: {},
			properties: {
				properties: {
					currency: {
						description: 'The currency the user wants to send (e.g. BTC)',
						pattern: '^[A-Z]{3,5}$',
						type: 'string',
					},
					device: {
						description: 'Device type from where the event was triggered.',
						enum: ['APP-iOS', 'WEB', 'APP-Android'],
						type: 'string',
					},
					from_account_type: {
						description:
							'To what type of account the user wants to send funds from. \nSAVINGS : interest saving account. \nTRADING : wallet custodial wallet. \nUSERKEY : Non Custodial, Private Key, wallet',
						enum: ['SAVINGS', 'TRADING', 'USERKEY'],
						type: 'string',
					},
					platform: {
						description: 'From what platform the user is sending crypto from',
						enum: ['WALLET'],
						type: 'string',
					},
					to_account_type: {
						description:
							'To what type of account the user wants to send funds to. EXCHANGE : Blockchain Exchange wallet \nEXTERNAL : external address outside Blockchain.com. \nSAVINGS : interest saving account. \nTRADING : wallet custodial wallet. \nUSERKEY : Non Custodial, Private Key, wallet',
						enum: ['EXCHANGE', 'EXTERNAL', 'SAVINGS', 'TRADING', 'USERKEY'],
						type: 'string',
					},
				},
				required: [
					'device',
					'platform',
					'currency',
					'from_account_type',
					'to_account_type',
				],
				type: 'object',
			},
			traits: {
				type: 'object',
			},
		},
		required: ['properties'],
		title: 'Send Amount Max Clicked',
		type: 'object',
	}
	const message = {
		event: 'Send Amount Max Clicked',
		properties: props || {},
		options,
	}
	validateAgainstSchema(message, schema)

	const a = analytics()
	if (a) {
		a.track(
			'Send Amount Max Clicked',
			props || {},
			withTypewriterContext(options),
			callback
		)
	}
}
/**
 * A user sets the fee rate he wants to use to send the transaction
 *
 * @param {SendFeeRateSelected} props - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function sendFeeRateSelected(
	props: SendFeeRateSelected,
	options?: Segment.Options,
	callback?: Segment.Callback
): void {
	const schema = {
		$schema: 'http://json-schema.org/draft-07/schema#',
		description:
			'A user sets the fee rate he wants to use to send the transaction',
		labels: {
			flow: 'send_v1',
			source: 'client',
		},
		properties: {
			context: {},
			properties: {
				properties: {
					currency: {
						description: 'The currency the user wants to send (e.g. BTC)',
						pattern: '^[A-Z]{3,5}$',
						type: 'string',
					},
					device: {
						description: 'Device type from where the event was triggered.',
						enum: ['APP-iOS', 'WEB', 'APP-Android'],
						type: 'string',
					},
					fee_rate: {
						description: 'What fee rate the user has selected',
						enum: ['CUSTOM', 'NORMAL', 'PRIORITY'],
						type: 'string',
					},
					from_account_type: {
						description:
							'To what type of account the user wants to send funds from. \nSAVINGS : interest saving account. \nTRADING : wallet custodial wallet. \nUSERKEY : Non Custodial, Private Key, wallet',
						enum: ['SAVINGS', 'TRADING', 'USERKEY'],
						type: 'string',
					},
					platform: {
						description: 'From what platform the user is sending crypto from',
						enum: ['WALLET'],
						type: 'string',
					},
					to_account_type: {
						description:
							'To what type of account the user wants to send funds to. EXCHANGE : Blockchain Exchange wallet \nEXTERNAL : external address outside Blockchain.com. \nSAVINGS : interest saving account. \nTRADING : wallet custodial wallet. \nUSERKEY : Non Custodial, Private Key, wallet',
						enum: ['EXCHANGE', 'EXTERNAL', 'SAVINGS', 'TRADING', 'USERKEY'],
						type: 'string',
					},
				},
				required: [
					'device',
					'platform',
					'to_account_type',
					'fee_rate',
					'currency',
					'from_account_type',
				],
				type: 'object',
			},
			traits: {
				type: 'object',
			},
		},
		required: ['properties'],
		title: 'Send Fee Rate Selected',
		type: 'object',
	}
	const message = {
		event: 'Send Fee Rate Selected',
		properties: props || {},
		options,
	}
	validateAgainstSchema(message, schema)

	const a = analytics()
	if (a) {
		a.track(
			'Send Fee Rate Selected',
			props || {},
			withTypewriterContext(options),
			callback
		)
	}
}
/**
 * A user selects the currency he wants to send and from what account he wants to send funds from. If currency and account are selected separately, trigger this event when the second one is selected.
 *
 * @param {SendFromSelected} props - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function sendFromSelected(
	props: SendFromSelected,
	options?: Segment.Options,
	callback?: Segment.Callback
): void {
	const schema = {
		$schema: 'http://json-schema.org/draft-07/schema#',
		description:
			'A user selects the currency he wants to send and from what account he wants to send funds from. If currency and account are selected separately, trigger this event when the second one is selected.',
		labels: {
			flow: 'send_v1',
			source: 'client',
		},
		properties: {
			context: {},
			properties: {
				properties: {
					currency: {
						description: 'The currency the user wants to send (e.g. BTC)',
						pattern: '^[A-Z]{3,5}$',
						type: 'string',
					},
					device: {
						description: 'Device type from where the event was triggered.',
						enum: ['APP-iOS', 'WEB', 'APP-Android'],
						type: 'string',
					},
					from_account_type: {
						description:
							'To what type of account the user wants to send funds from. \nSAVINGS is the interest saving account. \nTRADING is the wallet custodial wallet. \nUSERKEY is the Non Custodial, Private Key, wallet',
						enum: ['SAVINGS', 'TRADING', 'USERKEY'],
						type: 'string',
					},
					platform: {
						description: 'From what platform the user is sending crypto from',
						enum: ['WALLET'],
						type: 'string',
					},
				},
				required: ['from_account_type', 'platform', 'currency', 'device'],
				type: 'object',
			},
			traits: {
				type: 'object',
			},
		},
		required: ['properties'],
		title: 'Send From Selected',
		type: 'object',
	}
	const message = {
		event: 'Send From Selected',
		properties: props || {},
		options,
	}
	validateAgainstSchema(message, schema)

	const a = analytics()
	if (a) {
		a.track(
			'Send From Selected',
			props || {},
			withTypewriterContext(options),
			callback
		)
	}
}
/**
 * Button to access send/receive modal/tab is clicked.
 *
 * @param {SendReceiveClicked} props - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function sendReceiveClicked(
	props: SendReceiveClicked,
	options?: Segment.Options,
	callback?: Segment.Callback
): void {
	const schema = {
		$schema: 'http://json-schema.org/draft-07/schema#',
		description: 'Button to access send/receive modal/tab is clicked.',
		labels: {
			flow: ['send_v1', 'receive_v1'],
			source: 'client',
		},
		properties: {
			context: {},
			properties: {
				properties: {
					currency: {
						description:
							'What currency is being viewed. Used only for legacy flow, as the new flow will ask for the currency at a later stage.',
						pattern: '^[A-Z]{3,5}$',
						type: 'string',
					},
					device: {
						description: 'Device type from where the event was triggered.',
						enum: ['APP-iOS', 'WEB', 'APP-Android'],
						type: 'string',
					},
					origin: {
						description:
							'What button we are referring to. DASHBOARD_PROMO : announcement card or promo on dashboard. \nNAVIGATION: Navigation Bar.\n',
						enum: [
							'CURRENCY_PAGE',
							'NAVIGATION',
							'NO_HOLDINGS',
							'TRANSACTIONS_PAGE',
						],
						type: 'string',
					},
					platform: {
						description: 'What platform the user is clicking from',
						enum: ['WALLET'],
						type: 'string',
					},
					type: {
						description:
							'Whether the user clicked on a send or receive button specifically. For Android the Send or Receive screen is the same button, so this type will be empty.',
						enum: ['RECEIVE', 'SEND'],
						type: 'string',
					},
				},
				required: ['platform', 'device', 'origin'],
				type: 'object',
			},
			traits: {
				type: 'object',
			},
		},
		required: ['properties'],
		title: 'Send Receive Clicked',
		type: 'object',
	}
	const message = {
		event: 'Send Receive Clicked',
		properties: props || {},
		options,
	}
	validateAgainstSchema(message, schema)

	const a = analytics()
	if (a) {
		a.track(
			'Send Receive Clicked',
			props || {},
			withTypewriterContext(options),
			callback
		)
	}
}
/**
 * Send or Receive modal is viewed.
 *
 * @param {SendReceiveViewed} [props] - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function sendReceiveViewed(
	props?: SendReceiveViewed,
	options?: Segment.Options,
	callback?: Segment.Callback
): void {
	const schema = {
		$schema: 'http://json-schema.org/draft-07/schema#',
		description: 'Send or Receive modal is viewed.',
		labels: {
			flow: ['send_v1', 'receive_v1'],
			source: 'client',
		},
		properties: {
			context: {},
			properties: {
				properties: {
					currency: {
						description:
							'What currency is being viewed. Used only for legacy flow, as the new flow will ask for the currency at a later stage.',
						pattern: '^[A-Z]{3,5}$',
						type: 'string',
					},
					device: {
						description: 'Device type from where the event was triggered.',
						enum: ['APP-iOS', 'WEB', 'APP-Android'],
						type: 'string',
					},
					path: {
						description:
							'Path portion of the URL of the page. Equivalent to canonical path which defaults to location.pathname from the DOM API.',
						type: 'string',
					},
					platform: {
						description: 'What platform the page viewed belongs to',
						enum: ['WALLET'],
						type: 'string',
					},
					referrer: {
						description:
							'Full URL of the previous page. Equivalent to document.referrer from the DOM API.',
						type: 'string',
					},
					search: {
						description:
							'Query string portion of the URL of the page. Equivalent to location.search from the DOM API.',
						type: 'string',
					},
					title: {
						description:
							'Title of the page. Equivalent to document.title from the DOM API.',
						type: 'string',
					},
					type: {
						description:
							'Whether the user views a send or receive screen specifically. For Android the Send or Receive screen is the same, so this type will be empty.',
						enum: ['RECEIVE', 'SEND'],
						type: 'string',
					},
					url: {
						description:
							'Full URL of the page. First we look for the canonical url. If the canonical url is not provided, we use location.href from the DOM API.',
						type: 'string',
					},
				},
				required: ['platform', 'device'],
				type: 'object',
			},
			traits: {
				type: 'object',
			},
		},
		title: 'Send Receive Viewed',
		type: 'object',
	}
	const message = {
		event: 'Send Receive Viewed',
		properties: props || {},
		options,
	}
	validateAgainstSchema(message, schema)

	const a = analytics()
	if (a) {
		a.track(
			'Send Receive Viewed',
			props || {},
			withTypewriterContext(options),
			callback
		)
	}
}
/**
 * A user selects and submits the transaction that needs to be sent. The client requests the transaction to the sent to the backend or the network directly
 *
 * @param {SendSubmitted} props - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function sendSubmitted(
	props: SendSubmitted,
	options?: Segment.Options,
	callback?: Segment.Callback
): void {
	const schema = {
		$schema: 'http://json-schema.org/draft-07/schema#',
		description:
			'A user selects and submits the transaction that needs to be sent. The client requests the transaction to the sent to the backend or the network directly',
		labels: {
			flow: 'send_v1',
			source: 'client',
		},
		properties: {
			context: {},
			properties: {
				properties: {
					currency: {
						description: 'The currency the user wants to send (e.g. BTC)',
						pattern: '^[A-Z]{3,5}$',
						type: 'string',
					},
					device: {
						description: 'Device type from where the event was triggered.',
						enum: ['APP-iOS', 'WEB', 'APP-Android'],
						type: 'string',
					},
					fee_rate: {
						description:
							'What fee rate is used for sending the crypto. The user may or may not have selected it explicitly, for transfers from custodial wallets for example. BACKEND : the backend will chose what fee_rate to apply. CUSTOM : custom priority defined by the user. NORMAL : normal priority for transactions according to our fee estimation.  PRIORITY : high priority for transactions according to our fee estimation.',
						enum: ['BACKEND', 'CUSTOM', 'NORMAL', 'PRIORITY'],
						type: 'string',
					},
					from_account_type: {
						description:
							'To what type of account the user wants to send funds from. \nSAVINGS : interest saving account. \nTRADING : wallet custodial wallet. \nUSERKEY : Non Custodial, Private Key, wallet',
						enum: ['SAVINGS', 'TRADING', 'USERKEY'],
						type: 'string',
					},
					platform: {
						description: 'From what platform the user is sending crypto from',
						enum: ['WALLET'],
						type: 'string',
					},
					to_account_type: {
						description:
							'To what type of account the user wants to send funds to. EXCHANGE : Blockchain Exchange wallet \nEXTERNAL : external address outside Blockchain.com. \nSAVINGS : interest saving account. \nTRADING : wallet custodial wallet. \nUSERKEY : Non Custodial, Private Key, wallet',
						enum: ['EXCHANGE', 'EXTERNAL', 'SAVINGS', 'TRADING', 'USERKEY'],
						type: 'string',
					},
				},
				required: [
					'from_account_type',
					'platform',
					'to_account_type',
					'fee_rate',
					'device',
					'currency',
				],
				type: 'object',
			},
			traits: {
				type: 'object',
			},
		},
		required: ['properties'],
		title: 'Send Submitted',
		type: 'object',
	}
	const message = {
		event: 'Send Submitted',
		properties: props || {},
		options,
	}
	validateAgainstSchema(message, schema)

	const a = analytics()
	if (a) {
		a.track(
			'Send Submitted',
			props || {},
			withTypewriterContext(options),
			callback
		)
	}
}
/**
 * The user clicks the {cryptocurrency} tab to manage the addresses/wallets'
 *
 * @param {SettingsCurrencyClicked} props - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function settingsCurrencyClicked(
	props: SettingsCurrencyClicked,
	options?: Segment.Options,
	callback?: Segment.Callback
): void {
	const schema = {
		$schema: 'http://json-schema.org/draft-07/schema#',
		description:
			"The user clicks the {cryptocurrency} tab to manage the addresses/wallets'",
		labels: {
			flow: 'settings_v1',
			source: 'client',
		},
		properties: {
			context: {},
			properties: {
				properties: {
					currency: {
						description: '',
						pattern: '^[A-Z]{3,5}$',
						type: 'string',
					},
					device: {
						description: 'Device type from where the event was triggered.',
						enum: ['APP-iOS', 'WEB', 'APP-Android'],
						type: 'string',
					},
					platform: {
						description: 'From what platform the user is using the Settings',
						enum: ['EXCHANGE', 'WALLET'],
						type: 'string',
					},
				},
				required: ['device', 'currency', 'platform'],
				type: 'object',
			},
			traits: {
				type: 'object',
			},
		},
		required: ['properties'],
		title: 'Settings Currency Clicked',
		type: 'object',
	}
	const message = {
		event: 'Settings Currency Clicked',
		properties: props || {},
		options,
	}
	validateAgainstSchema(message, schema)

	const a = analytics()
	if (a) {
		a.track(
			'Settings Currency Clicked',
			props || {},
			withTypewriterContext(options),
			callback
		)
	}
}
/**
 * User clicks to open site about Privacy Policy, About or Term of Service.
 *
 * @param {SettingsHyperlinkClicked} props - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function settingsHyperlinkClicked(
	props: SettingsHyperlinkClicked,
	options?: Segment.Options,
	callback?: Segment.Callback
): void {
	const schema = {
		$schema: 'http://json-schema.org/draft-07/schema#',
		description:
			'User clicks to open site about Privacy Policy, About or Term of Service.',
		labels: {
			flow: 'settings_v1',
			source: 'client',
		},
		properties: {
			context: {},
			properties: {
				properties: {
					'': {
						description: '',
						type: 'object',
					},
					destination: {
						description: 'Destination link. Example: Terms of Service',
						enum: [
							'ABOUT',
							'COOKIES_POLICY',
							'PRIVACY_POLICY',
							'RATE_US',
							'TERMS_OF_SERVICE',
						],
						type: 'string',
					},
					device: {
						description: 'Device type from where the event was triggered.',
						enum: ['APP-Android', 'APP-iOS', 'WEB'],
						type: 'string',
					},
					platform: {
						description: 'From what platform the user is using the Settings',
						enum: ['EXCHANGE', 'WALLET'],
						type: 'string',
					},
				},
				required: ['destination', 'platform', 'device'],
				type: 'object',
			},
			traits: {
				type: 'object',
			},
		},
		required: ['properties'],
		title: 'Settings Hyperlink Clicked',
		type: 'object',
	}
	const message = {
		event: 'Settings Hyperlink Clicked',
		properties: props || {},
		options,
	}
	validateAgainstSchema(message, schema)

	const a = analytics()
	if (a) {
		a.track(
			'Settings Hyperlink Clicked',
			props || {},
			withTypewriterContext(options),
			callback
		)
	}
}
/**
 * The users click to select the setting section
 *
 * @param {SettingsTabClicked} props - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function settingsTabClicked(
	props: SettingsTabClicked,
	options?: Segment.Options,
	callback?: Segment.Callback
): void {
	const schema = {
		$schema: 'http://json-schema.org/draft-07/schema#',
		description: 'The users click to select the setting section ',
		labels: {
			flow: 'settings_v1',
			source: 'client',
		},
		properties: {
			context: {},
			properties: {
				properties: {
					'': {
						description: '',
						type: 'object',
					},
					device: {
						description: 'Device type from where the event was triggered.',
						enum: ['WEB'],
						type: 'string',
					},
					platform: {
						description: 'From what platform the user is using the Settings',
						enum: ['EXCHANGE', 'WALLET'],
						type: 'string',
					},
					settings_tab: {
						description:
							'General, Trading Limits, Preferences or Wallets & Addresses',
						enum: [
							'GENERAL',
							'PREFERENCES',
							'TRADING_LIMITS',
							'WALLETS&ADDRESSES',
						],
						type: 'string',
					},
				},
				required: ['device', 'platform', 'settings_tab'],
				type: 'object',
			},
			traits: {
				type: 'object',
			},
		},
		required: ['properties'],
		title: 'Settings Tab Clicked',
		type: 'object',
	}
	const message = {
		event: 'Settings Tab Clicked',
		properties: props || {},
		options,
	}
	validateAgainstSchema(message, schema)

	const a = analytics()
	if (a) {
		a.track(
			'Settings Tab Clicked',
			props || {},
			withTypewriterContext(options),
			callback
		)
	}
}
/**
 * Button to skip log in and continue as guest
 *
 * @param {SignInSkipped} props - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function signInSkipped(
	props: SignInSkipped,
	options?: Segment.Options,
	callback?: Segment.Callback
): void {
	const schema = {
		$schema: 'http://json-schema.org/draft-07/schema#',
		description: 'Button to skip log in and continue as guest',
		labels: {
			flow: 'trade_e1',
			source: 'client',
		},
		properties: {
			context: {},
			properties: {
				properties: {
					device: {
						description: 'Device type from where the event was triggered.',
						enum: ['APP-iOS', 'WEB', 'APP-Android'],
						type: 'string',
					},
					plaform: {
						description:
							'In the Exchange, the sign in can be skipped to continue as guest',
						enum: ['EXCHANGE', 'WALLET'],
						type: 'string',
					},
				},
				required: ['plaform', 'device'],
				type: 'object',
			},
			traits: {
				type: 'object',
			},
		},
		required: ['properties'],
		title: 'Sign In Skipped',
		type: 'object',
	}
	const message = {
		event: 'Sign In Skipped',
		properties: props || {},
		options,
	}
	validateAgainstSchema(message, schema)

	const a = analytics()
	if (a) {
		a.track(
			'Sign In Skipped',
			props || {},
			withTypewriterContext(options),
			callback
		)
	}
}
/**
 * A user selects the country and state in the sign up form of a product that is not supported locally.
 *
 * @param {SignUpAddressUnsupported} props - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function signUpAddressUnsupported(
	props: SignUpAddressUnsupported,
	options?: Segment.Options,
	callback?: Segment.Callback
): void {
	const schema = {
		$schema: 'http://json-schema.org/draft-07/schema#',
		description:
			'A user selects the country and state in the sign up form of a product that is not supported locally.',
		labels: {
			flow: ['sign_up', 'onboarding_v1'],
			source: 'client',
		},
		properties: {
			context: {},
			properties: {
				properties: {
					country: {
						description:
							'Country, as iso code alpha 2, provided by the user at sign up',
						pattern: '^[A-Z]{2,2}$',
						type: 'string',
					},
					country_state: {
						description:
							'country state, as ISO 3166-2 (US-NY for example), provided by the user at sign up',
						pattern: '^[A-Z]{2,2}-[A-Z]{2,2}$',
						type: 'string',
					},
					device: {
						description: 'What device the user is signing up from',
						enum: ['APP-Android', 'APP-iOS', 'WEB'],
						type: 'string',
					},
					email: {
						description: '',
						type: 'object',
					},
					platform: {
						description: 'What platform the user is signing up to',
						enum: ['EXCHANGE', 'WALLET'],
						type: 'string',
					},
				},
				required: ['device', 'platform', 'country', 'country_state', 'email'],
				type: 'object',
			},
			traits: {
				type: 'object',
			},
		},
		required: ['properties'],
		title: 'Sign Up Address Unsupported',
		type: 'object',
	}
	const message = {
		event: 'Sign Up Address Unsupported',
		properties: props || {},
		options,
	}
	validateAgainstSchema(message, schema)

	const a = analytics()
	if (a) {
		a.track(
			'Sign Up Address Unsupported',
			props || {},
			withTypewriterContext(options),
			callback
		)
	}
}
/**
 * User clicks on a widget or button to go to the sign up screen. Not what this is different from the Wallet Signed Up and Exchange Signed Up events which is when the client submits the user creation request
 *
 * @param {SignUpClicked} props - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function signUpClicked(
	props: SignUpClicked,
	options?: Segment.Options,
	callback?: Segment.Callback
): void {
	const schema = {
		$schema: 'http://json-schema.org/draft-07/schema#',
		description:
			'User clicks on a widget or button to go to the sign up screen. Not what this is different from the Wallet Signed Up and Exchange Signed Up events which is when the client submits the user creation request',
		labels: {
			flow: ['sign_up', 'onboarding_e1', 'onboarding_v1'],
			source: 'client',
		},
		properties: {
			context: {},
			properties: {
				properties: {
					device: {
						description: 'What device the user is signing up from',
						enum: ['APP-Android', 'APP-iOS', 'WEB'],
						type: 'string',
					},
					origin: {
						description:
							'What button we are referring to. NUX_LAUNCH_PROMO_BUY_CRYPTO : (mobile) Buy Crypto button at the bottom of a card announcement  when launching the app and before login in.',
						enum: ['NUX_LAUNCH_PROMO_BUY_CRYPTO'],
						type: 'string',
					},
					platform: {
						description: 'What platform the user is signing up to',
						enum: ['EXCHANGE', 'WALLET'],
						type: 'string',
					},
				},
				required: ['device', 'origin', 'platform'],
				type: 'object',
			},
			traits: {
				type: 'object',
			},
		},
		required: ['properties'],
		title: 'Sign Up Clicked',
		type: 'object',
	}
	const message = {
		event: 'Sign Up Clicked',
		properties: props || {},
		options,
	}
	validateAgainstSchema(message, schema)

	const a = analytics()
	if (a) {
		a.track(
			'Sign Up Clicked',
			props || {},
			withTypewriterContext(options),
			callback
		)
	}
}
/**
 * A user selects the country in the sign up form. It could be an exchange or wallet sign up. This should be triggered as soon as the user selects the country, even if the user hasn't submitted the sign up form yet.
 *
 * @param {SignUpCountrySelected} props - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function signUpCountrySelected(
	props: SignUpCountrySelected,
	options?: Segment.Options,
	callback?: Segment.Callback
): void {
	const schema = {
		$schema: 'http://json-schema.org/draft-07/schema#',
		description:
			"A user selects the country in the sign up form. It could be an exchange or wallet sign up. This should be triggered as soon as the user selects the country, even if the user hasn't submitted the sign up form yet.",
		labels: {
			flow: ['sign_up', 'onboarding_v1'],
			source: 'client',
		},
		properties: {
			context: {},
			properties: {
				properties: {
					country: {
						description:
							'Country, as iso code alpha 2, provided by the user at sign up',
						pattern: '^[A-Z]{2,2}$',
						type: 'string',
					},
					country_state: {
						description:
							'country state, as ISO 3166-2 (US-NY for example), provided by the user at sign up',
						pattern: '^[A-Z]{2,2}-[A-Z]{2,2}$',
						type: 'string',
					},
					device: {
						description: 'What device the user is signing up from',
						enum: ['APP-Android', 'APP-iOS', 'WEB'],
						type: 'string',
					},
					platform: {
						description: 'What platform the user is signing up to',
						enum: ['EXCHANGE', 'WALLET'],
						type: 'string',
					},
				},
				required: ['device', 'country', 'platform'],
				type: 'object',
			},
			traits: {
				type: 'object',
			},
		},
		required: ['properties'],
		title: 'Sign Up Country Selected',
		type: 'object',
	}
	const message = {
		event: 'Sign Up Country Selected',
		properties: props || {},
		options,
	}
	validateAgainstSchema(message, schema)

	const a = analytics()
	if (a) {
		a.track(
			'Sign Up Country Selected',
			props || {},
			withTypewriterContext(options),
			callback
		)
	}
}
/**
 * The user succesfully logs in. On mobile, it is triggered every time the user unlocks the app from the pin code.
 *
 * @param {SignedIn} props - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function signedIn(
	props: SignedIn,
	options?: Segment.Options,
	callback?: Segment.Callback
): void {
	const schema = {
		$schema: 'http://json-schema.org/draft-07/schema#',
		description:
			'The user succesfully logs in. On mobile, it is triggered every time the user unlocks the app from the pin code.',
		labels: {
			flow: ['navigation_v1', 'trade_e1'],
			source: 'client',
		},
		properties: {
			context: {},
			properties: {
				properties: {
					authentification_type: {
						description:
							'How the user is trying to log in. PASSWORD : with a password on mobile or web, PIN : with a PIN on mobile,  SECURE_CHANNEL : by sending a log in request via secure channel to another client',
						enum: ['PASSWORD', 'PIN', 'SECURE_CHANNEL'],
						type: 'string',
					},
					device: {
						description: 'Device type from where the event was triggered.',
						enum: ['APP-iOS', 'WEB', 'APP-Android'],
						type: 'string',
					},
					platform: {
						description: 'What platform the user logs in to.',
						enum: ['EXCHANGE', 'WALLET'],
						type: 'string',
					},
					site_redirect: {
						description:
							'Whether the user is being redirected to the WALLET or the EXCHANGE',
						enum: ['EXCHANGE', 'WALLET'],
						type: 'string',
					},
				},
				required: ['platform', 'device'],
				type: 'object',
			},
			traits: {
				type: 'object',
			},
		},
		required: ['properties'],
		title: 'Signed In',
		type: 'object',
	}
	const message = {
		event: 'Signed In',
		properties: props || {},
		options,
	}
	validateAgainstSchema(message, schema)

	const a = analytics()
	if (a) {
		a.track('Signed In', props || {}, withTypewriterContext(options), callback)
	}
}
/**
 * The user logs out, by explicitly clicking on a Log Out or Sign Out button
 *
 * @param {SignedOut} props - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function signedOut(
	props: SignedOut,
	options?: Segment.Options,
	callback?: Segment.Callback
): void {
	const schema = {
		$schema: 'http://json-schema.org/draft-07/schema#',
		description:
			'The user logs out, by explicitly clicking on a Log Out or Sign Out button',
		labels: {
			flow: ['navigation_v1', 'trade_e1', 'settings_v1'],
			source: 'client',
		},
		properties: {
			context: {},
			properties: {
				properties: {
					device: {
						description: 'Device type from where the event was triggered.',
						enum: ['APP-iOS', 'WEB', 'APP-Android'],
						type: 'string',
					},
					platform: {
						description: 'What platform the user logs out from.',
						enum: ['EXCHANGE', 'WALLET'],
						type: 'string',
					},
				},
				required: ['platform', 'device'],
				type: 'object',
			},
			traits: {
				type: 'object',
			},
		},
		required: ['properties'],
		title: 'Signed Out',
		type: 'object',
	}
	const message = {
		event: 'Signed Out',
		properties: props || {},
		options,
	}
	validateAgainstSchema(message, schema)

	const a = analytics()
	if (a) {
		a.track('Signed Out', props || {}, withTypewriterContext(options), callback)
	}
}
/**
 * A user signs up for a user profile (custodial) with us. For the wallet, this is when a nabu user is created. For the exchange, this is when exchange user credentials are created, slightly before the nabu profile. Note that this is different from Wallet Signed Up or Exchange Signed Up. The user is signed up automatically in the wallet or exchange when we need to record information about the user.
 *
 * @param {SignedUp} props - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function signedUp(
	props: SignedUp,
	options?: Segment.Options,
	callback?: Segment.Callback
): void {
	const schema = {
		$schema: 'http://json-schema.org/draft-07/schema#',
		description:
			'A user signs up for a user profile (custodial) with us. For the wallet, this is when a nabu user is created. For the exchange, this is when exchange user credentials are created, slightly before the nabu profile. Note that this is different from Wallet Signed Up or Exchange Signed Up. The user is signed up automatically in the wallet or exchange when we need to record information about the user.',
		labels: {
			flow: ['onboarding_v1', 'onboarding_e1', 'sign_up'],
			source: 'backend',
		},
		properties: {
			context: {},
			properties: {
				properties: {
					device: {
						description: 'What device the user created the account from',
						enum: [' APP-iOS', 'APP-Android', 'WEB'],
						type: 'string',
					},
					is_from_linking: {
						description:
							'Whether the profile is created from linking the account from another product. For now, we record it specifically when an exchange account is created by linking a wallet account.',
						type: 'boolean',
					},
					legal_entity: {
						description:
							'every user need to be assigned to a legal entity based on a certain reason.',
						enum: ['BC_BVI_3', 'BC_LT', 'BC_LT_2', 'BC_US'],
						type: 'string',
					},
					legal_entity_reason: {
						description:
							'legal entity to a user assigned based on this reason.',
						enum: ['ADDRESS', 'DEFAULT', 'IP', 'MANUAL'],
						type: 'string',
					},
					platform: {
						description: 'What platform the user signed up for',
						enum: ['EXCHANGE', 'WALLET'],
						type: 'string',
					},
				},
				required: ['platform', 'legal_entity_reason', 'device', 'legal_entity'],
				type: 'object',
			},
			traits: {
				type: 'object',
			},
		},
		required: ['properties'],
		title: 'Signed Up',
		type: 'object',
	}
	const message = {
		event: 'Signed Up',
		properties: props || {},
		options,
	}
	validateAgainstSchema(message, schema)

	const a = analytics()
	if (a) {
		a.track('Signed Up', props || {}, withTypewriterContext(options), callback)
	}
}
/**
 * Button which brings the user to the Simple Trade general page or. screen, with all the available assets, is clicked. Next step of Simple Trade will be a Buy Sell flow. Note : SimpleTrade  uses the brokerage product under the hood
 *
 * @param {SimpleTradeClicked} props - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function simpleTradeClicked(
	props: SimpleTradeClicked,
	options?: Segment.Options,
	callback?: Segment.Callback
): void {
	const schema = {
		$schema: 'http://json-schema.org/draft-07/schema#',
		description:
			'Button which brings the user to the Simple Trade general page or. screen, with all the available assets, is clicked. Next step of Simple Trade will be a Buy Sell flow. Note : SimpleTrade  uses the brokerage product under the hood',
		labels: {
			flow: 'simple_trade_e1',
			source: 'client',
		},
		properties: {
			context: {},
			properties: {
				properties: {
					device: {
						description: 'Device type from where the event was triggered.',
						enum: ['APP-iOS', 'WEB', 'APP-Android'],
						type: 'string',
					},
					origin: {
						description:
							'what button we are referring to. NAVIGATION : navigation bar. \n',
						enum: ['NAVIGATION'],
						type: 'string',
					},
					platform: {
						description: 'What platform the user is clicking from',
						enum: ['EXCHANGE'],
						type: 'string',
					},
				},
				required: ['origin', 'platform', 'device'],
				type: 'object',
			},
			traits: {
				type: 'object',
			},
		},
		required: ['properties'],
		title: 'Simple Trade Clicked',
		type: 'object',
	}
	const message = {
		event: 'Simple Trade Clicked',
		properties: props || {},
		options,
	}
	validateAgainstSchema(message, schema)

	const a = analytics()
	if (a) {
		a.track(
			'Simple Trade Clicked',
			props || {},
			withTypewriterContext(options),
			callback
		)
	}
}
/**
 * Simple Trade general page, with ll the available assets is viewed. Next step of Simple Trade will be a Buy Sell flow. Note : Simple Trade uses the brokerage product under the hood
 *
 * @param {SimpleTradeViewed} [props] - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function simpleTradeViewed(
	props?: SimpleTradeViewed,
	options?: Segment.Options,
	callback?: Segment.Callback
): void {
	const schema = {
		$schema: 'http://json-schema.org/draft-07/schema#',
		description:
			'Simple Trade general page, with ll the available assets is viewed. Next step of Simple Trade will be a Buy Sell flow. Note : Simple Trade uses the brokerage product under the hood',
		labels: {
			flow: 'simple_trade_e1',
			source: 'client',
		},
		properties: {
			context: {},
			properties: {
				properties: {
					device: {
						description: 'Device type from where the event was triggered.',
						enum: ['APP-iOS', 'WEB', 'APP-Android'],
						type: 'string',
					},
					path: {
						description:
							'Path portion of the URL of the page. Equivalent to canonical path which defaults to location.pathname from the DOM API.',
						type: 'string',
					},
					platform: {
						description: 'What platform the page viewed belongs to',
						enum: ['EXCHANGE'],
						type: 'string',
					},
					referrer: {
						description:
							'Full URL of the previous page. Equivalent to document.referrer from the DOM API.',
						type: 'string',
					},
					search: {
						description:
							'Query string portion of the URL of the page. Equivalent to location.search from the DOM API.',
						type: 'string',
					},
					title: {
						description:
							'Title of the page. Equivalent to document.title from the DOM API.',
						type: 'string',
					},
					url: {
						description:
							'Full URL of the page. First we look for the canonical url. If the canonical url is not provided, we use location.href from the DOM API.',
						type: 'string',
					},
				},
				required: ['device', 'platform'],
				type: 'object',
			},
			traits: {
				type: 'object',
			},
		},
		title: 'Simple Trade Viewed',
		type: 'object',
	}
	const message = {
		event: 'Simple Trade Viewed',
		properties: props || {},
		options,
	}
	validateAgainstSchema(message, schema)

	const a = analytics()
	if (a) {
		a.track(
			'Simple Trade Viewed',
			props || {},
			withTypewriterContext(options),
			callback
		)
	}
}
/**
 * The system sends an SMS message with the code after the user inputs a valid mobile number.
 *
 * @param {SmsMessageSent} props - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function smsMessageSent(
	props: SmsMessageSent,
	options?: Segment.Options,
	callback?: Segment.Callback
): void {
	const schema = {
		$schema: 'http://json-schema.org/draft-07/schema#',
		description:
			'The system sends an SMS message with the code after the user inputs a valid mobile number.',
		labels: {
			flow: ['settings_v1', 'security_v1'],
			source: 'backend',
		},
		properties: {
			context: {},
			properties: {
				properties: {
					country_code: {
						description: 'country of the mobile number, in alpha iso 2 code.',
						pattern: '^[A-Z]{2}$',
						type: 'string',
					},
					device: {
						description: 'Device type from where the event was triggered.',
						enum: ['APP-iOS', 'WEB', 'APP-Android'],
						type: 'string',
					},
					origin: {
						description:
							'From which page are they verifying the Mobile Number? Settings or Security',
						enum: ['SECURITY', 'SETTINGS'],
						type: 'string',
					},
					platform: {
						description: 'From what platform the user is using the Settings',
						enum: ['EXCHANGE', 'WALLET'],
						type: 'string',
					},
				},
				required: ['platform', 'origin', 'country_code'],
				type: 'object',
			},
			traits: {
				type: 'object',
			},
		},
		required: ['properties'],
		title: 'Sms Message Sent',
		type: 'object',
	}
	const message = {
		event: 'Sms Message Sent',
		properties: props || {},
		options,
	}
	validateAgainstSchema(message, schema)

	const a = analytics()
	if (a) {
		a.track(
			'Sms Message Sent',
			props || {},
			withTypewriterContext(options),
			callback
		)
	}
}
/**
 * The user selects and submits from what account and currency the swap funds should come from and be received to. Event is triggered when both accounts and currencies are confirmed (click on Next or a Suggested Pair is clicked or when receive info is selected and it confirms both directly like in iOS)
 *
 * @param {SwapAccountsSelected} props - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function swapAccountsSelected(
	props: SwapAccountsSelected,
	options?: Segment.Options,
	callback?: Segment.Callback
): void {
	const schema = {
		$schema: 'http://json-schema.org/draft-07/schema#',
		description:
			'The user selects and submits from what account and currency the swap funds should come from and be received to. Event is triggered when both accounts and currencies are confirmed (click on Next or a Suggested Pair is clicked or when receive info is selected and it confirms both directly like in iOS) ',
		labels: {
			flow: 'swap_v1',
			source: 'client',
		},
		properties: {
			context: {},
			properties: {
				properties: {
					device: {
						description: 'Device type from where the event was triggered.',
						enum: ['APP-iOS', 'WEB', 'APP-Android'],
						type: 'string',
					},
					input_currency: {
						description:
							'Currency symbol for the currency being swap from in exchange for some other currency. For example BTC in a BTC-ETH swap',
						pattern: '^[A-Z]{3,5}$',
						type: 'string',
					},
					input_type: {
						description: 'The type of account the swap funds are coming from',
						enum: ['TRADING', 'USERKEY'],
						type: 'string',
					},
					output_currency: {
						description:
							'Currency symbol for the currency being swap to. For example ETH in a BTC-ETH swap',
						pattern: '^[A-Z]{3,5}$',
						type: 'string',
					},
					output_type: {
						description: 'The type of account the swap funds are going to',
						enum: ['TRADING', 'USERKEY'],
						type: 'string',
					},
					platform: {
						description: 'From what platform the user wants to Swap from',
						enum: ['WALLET'],
						type: 'string',
					},
					was_suggested: {
						description:
							'Whether the swap accounts and currency were suggested by the UX and the user clicked on it. Empty if this information is unknown.',
						type: 'boolean',
					},
				},
				required: [
					'platform',
					'output_currency',
					'output_type',
					'input_currency',
					'input_type',
					'device',
				],
				type: 'object',
			},
			traits: {
				type: 'object',
			},
		},
		required: ['properties'],
		title: 'Swap Accounts Selected',
		type: 'object',
	}
	const message = {
		event: 'Swap Accounts Selected',
		properties: props || {},
		options,
	}
	validateAgainstSchema(message, schema)

	const a = analytics()
	if (a) {
		a.track(
			'Swap Accounts Selected',
			props || {},
			withTypewriterContext(options),
			callback
		)
	}
}
/**
 * The user enters and submits the amount for a swap transaction. (Preview swap click on Web)
 *
 * @param {SwapAmountEntered} props - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function swapAmountEntered(
	props: SwapAmountEntered,
	options?: Segment.Options,
	callback?: Segment.Callback
): void {
	const schema = {
		$schema: 'http://json-schema.org/draft-07/schema#',
		description:
			'The user enters and submits the amount for a swap transaction. (Preview swap click on Web)',
		labels: {
			flow: 'swap_v1',
			source: 'client',
		},
		properties: {
			context: {},
			properties: {
				properties: {
					amount: {
						description:
							'The amount in the native fiat currency that the user selects the amount',
						type: 'number',
					},
					amount_currency: {
						description: 'The native fiat currency ',
						pattern: '^[A-Z]{3,5}$',
						type: 'string',
					},
					device: {
						description: 'Device type from where the event was triggered.',
						enum: ['APP-iOS', 'WEB', 'APP-Android'],
						type: 'string',
					},
					input_amount: {
						description: 'The amount for the input currency',
						type: 'number',
					},
					input_currency: {
						description:
							'Currency symbol for the currency being swap from in exchange for some other currency. For example BTC in a BTC-ETH swap',
						pattern: '^[A-Z]{3,5}$',
						type: 'string',
					},
					input_type: {
						description: 'The type of account the swap funds are coming from',
						enum: ['TRADING', 'USERKEY'],
						type: 'string',
					},
					output_amount: {
						description: 'The amount for the output currency',
						type: 'number',
					},
					output_currency: {
						description:
							'Currency symbol for the currency being swap to. For example ETH in a BTC-ETH swap',
						pattern: '^[A-Z]{3,5}$',
						type: 'string',
					},
					output_type: {
						description: 'The type of account the swap funds are going to',
						enum: ['TRADING', 'USERKEY'],
						type: 'string',
					},
					platform: {
						description: 'From what platform the user wants to Swap from',
						enum: ['WALLET'],
						type: 'string',
					},
				},
				required: [
					'input_currency',
					'platform',
					'input_amount',
					'input_type',
					'device',
					'output_type',
					'output_currency',
				],
				type: 'object',
			},
			traits: {
				type: 'object',
			},
		},
		required: ['properties'],
		title: 'Swap Amount Entered',
		type: 'object',
	}
	const message = {
		event: 'Swap Amount Entered',
		properties: props || {},
		options,
	}
	validateAgainstSchema(message, schema)

	const a = analytics()
	if (a) {
		a.track(
			'Swap Amount Entered',
			props || {},
			withTypewriterContext(options),
			callback
		)
	}
}
/**
 * The user clicks on the widget or button which sets the max amount allowed.
 *
 * @param {SwapAmountMaxClicked} props - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function swapAmountMaxClicked(
	props: SwapAmountMaxClicked,
	options?: Segment.Options,
	callback?: Segment.Callback
): void {
	const schema = {
		$schema: 'http://json-schema.org/draft-07/schema#',
		description:
			'The user clicks on the widget or button which sets the max amount allowed.',
		labels: {
			flow: 'swap_v1',
			source: 'client',
		},
		properties: {
			context: {},
			properties: {
				properties: {
					amount_currency: {
						description:
							'If the button explicitly displays the amount in a specific currency. what is the currency being clicked on for the max amount ?',
						pattern: '^[A-Z]{3,5}$',
						type: 'string',
					},
					device: {
						description: 'Device type from where the event was triggered.',
						enum: ['APP-iOS', 'WEB', 'APP-Android'],
						type: 'string',
					},
					input_currency: {
						description:
							'Currency symbol for the currency being swap from in exchange for some other currency. For example BTC in a BTC-ETH swap',
						pattern: '^[A-Z]{3,5}$',
						type: 'string',
					},
					input_type: {
						description: 'The type of account the swap funds are coming from',
						enum: ['TRADING', 'USERKEY'],
						type: 'string',
					},
					output_currency: {
						description:
							'Currency symbol for the currency being swap to. For example ETH in a BTC-ETH swap',
						pattern: '^[A-Z]{3,5}$',
						type: 'string',
					},
					output_type: {
						description: 'The type of account the swap funds are going to',
						enum: ['TRADING', 'USERKEY'],
						type: 'string',
					},
					platform: {
						description: 'From what platform the user wants to Swap from',
						enum: ['WALLET'],
						type: 'string',
					},
				},
				required: [
					'input_type',
					'platform',
					'output_currency',
					'device',
					'output_type',
					'input_currency',
				],
				type: 'object',
			},
			traits: {
				type: 'object',
			},
		},
		required: ['properties'],
		title: 'Swap Amount Max Clicked',
		type: 'object',
	}
	const message = {
		event: 'Swap Amount Max Clicked',
		properties: props || {},
		options,
	}
	validateAgainstSchema(message, schema)

	const a = analytics()
	if (a) {
		a.track(
			'Swap Amount Max Clicked',
			props || {},
			withTypewriterContext(options),
			callback
		)
	}
}
/**
 * The user clicks on the widget or button which sets the min amount allowed.
 *
 * @param {SwapAmountMinClicked} props - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function swapAmountMinClicked(
	props: SwapAmountMinClicked,
	options?: Segment.Options,
	callback?: Segment.Callback
): void {
	const schema = {
		$schema: 'http://json-schema.org/draft-07/schema#',
		description:
			'The user clicks on the widget or button which sets the min amount allowed.',
		labels: {
			flow: 'swap_v1',
			source: 'client',
		},
		properties: {
			context: {},
			properties: {
				properties: {
					amount_currency: {
						description:
							'If the button explicitly displays the amount in a specific currency. what is the currency being clicked on for the min amount ?',
						pattern: '^[A-Z]{3,5}$',
						type: 'string',
					},
					device: {
						description: 'Device type from where the event was triggered.',
						enum: ['APP-iOS', 'WEB', 'APP-Android'],
						type: 'string',
					},
					input_currency: {
						description:
							'Currency symbol for the currency being swap from in exchange for some other currency. For example BTC in a BTC-ETH swap',
						pattern: '^[A-Z]{3,5}$',
						type: 'string',
					},
					input_type: {
						description: 'The type of account the swap funds are coming from',
						enum: ['TRADING', 'USERKEY'],
						type: 'string',
					},
					output_currency: {
						description:
							'Currency symbol for the currency being swap to. For example ETH in a BTC-ETH swap',
						pattern: '^[A-Z]{3,5}$',
						type: 'string',
					},
					output_type: {
						description: 'The type of account the swap funds are going to',
						enum: ['TRADING', 'USERKEY'],
						type: 'string',
					},
					platform: {
						description: 'From what platform the user wants to Swap from',
						enum: ['WALLET'],
						type: 'string',
					},
				},
				required: [
					'input_currency',
					'input_type',
					'output_currency',
					'device',
					'output_type',
					'platform',
				],
				type: 'object',
			},
			traits: {
				type: 'object',
			},
		},
		required: ['properties'],
		title: 'Swap Amount Min Clicked',
		type: 'object',
	}
	const message = {
		event: 'Swap Amount Min Clicked',
		properties: props || {},
		options,
	}
	validateAgainstSchema(message, schema)

	const a = analytics()
	if (a) {
		a.track(
			'Swap Amount Min Clicked',
			props || {},
			withTypewriterContext(options),
			callback
		)
	}
}
/**
 * Swap Crypto to Crypto (ONLY!) order is cancelled (when updating a custodial transaction with final state CANCELED from custodial_transactions from nabu gateway, with input and output currencies between crypto
 *
 * @param {SwapCancelled} props - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function swapCancelled(
	props: SwapCancelled,
	options?: Segment.Options,
	callback?: Segment.Callback
): void {
	const schema = {
		$schema: 'http://json-schema.org/draft-07/schema#',
		description:
			'Swap Crypto to Crypto (ONLY!) order is cancelled (when updating a custodial transaction with final state CANCELED from custodial_transactions from nabu gateway, with input and output currencies between crypto',
		labels: {
			flow: 'swap_v1',
			source: 'backend',
		},
		properties: {
			context: {},
			properties: {
				properties: {
					device: {
						description: 'Device type from where the event was triggered.',
						enum: ['APP-iOS', 'WEB', 'APP-Android'],
						type: 'string',
					},
					direction: {
						description:
							'What type of swap transactions it is, as a direction from/to Custodial or Non Custodial Wallet. INTERNAL is from TRADING to TRADING wallets. ON_CHAIN is from USERKEY to USERKEY. FROM_USERKEY is from USERKEY to TRADING wallets. TO_USERKEY is from TRADING to USERKEY wallets',
						enum: ['FROM_USERKEY', 'INTERNAL', 'ON_CHAIN', 'TO_USERKEY'],
						type: 'string',
					},
					from_account_type: {
						description:
							'The type of account the swap funds are coming from. (USERKEY for ON_CHAIN and FROM_USERKEY directions, TRADING for INTERNAL and TO_USERKEY)',
						enum: ['TRADING', 'USERKEY'],
						type: 'string',
					},
					input_amount: {
						description: 'The amount for the input currency',
						type: 'number',
					},
					input_amount_usd: {
						description: 'Approximate amount in USD sent by the user.',
						type: 'number',
					},
					input_currency: {
						description:
							'Symbol for the crypto currency being swap from in exchange for some other crypto currency. For example BTC in a BTC-ETH swap',
						pattern: '^[A-Z]{3,5}$',
						type: 'string',
					},
					output_amount: {
						description: 'The amount for the output currency',
						type: 'number',
					},
					output_currency: {
						description:
							'Symbol for the crypto currency being swap to. For example ETH in a BTC-ETH swap',
						pattern: '^[A-Z]{3,5}$',
						type: 'string',
					},
					payment_id: {
						description:
							'id of the payment (id of the transaction from nabu payments)',
						type: 'string',
					},
					platform: {
						description: 'What platform the event was started from. (WALLET)\n',
						enum: ['EXCHANGE', 'WALLET'],
						type: 'string',
					},
					to_account_type: {
						description:
							'The type of account the swap funds are coming from. (USERKEY for ON_CHAIN and TO_USERKEY directions, TRADING for INTERNAL and FROM_USERKEY directions)',
						enum: ['TRADING', 'USERKEY'],
						type: 'string',
					},
					transaction_id: {
						description:
							'id of the transaction from nabu gateway custodial_transaction table',
						type: 'string',
					},
				},
				required: [
					'platform',
					'device',
					'transaction_id',
					'from_account_type',
					'output_amount',
					'input_currency',
					'input_amount',
					'direction',
					'output_currency',
					'to_account_type',
				],
				type: 'object',
			},
			traits: {
				type: 'object',
			},
		},
		required: ['properties'],
		title: 'Swap Cancelled',
		type: 'object',
	}
	const message = {
		event: 'Swap Cancelled',
		properties: props || {},
		options,
	}
	validateAgainstSchema(message, schema)

	const a = analytics()
	if (a) {
		a.track(
			'Swap Cancelled',
			props || {},
			withTypewriterContext(options),
			callback
		)
	}
}
/**
 * Button which brings the user to the Swap product clicked
 *
 * @param {SwapClicked} props - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function swapClicked(
	props: SwapClicked,
	options?: Segment.Options,
	callback?: Segment.Callback
): void {
	const schema = {
		$schema: 'http://json-schema.org/draft-07/schema#',
		description: 'Button which brings the user to the Swap product clicked',
		labels: {
			flow: 'swap_v1',
			source: 'client',
		},
		properties: {
			context: {},
			properties: {
				properties: {
					device: {
						description: 'Device type from where the event was triggered.',
						enum: ['APP-iOS', 'WEB', 'APP-Android'],
						type: 'string',
					},
					origin: {
						description:
							'What button we are referring to. \nCURRENCY_PAGE : CTA or menu on the coin page next to balance. \nDASHBOARD_PROMO : announcement card or promo on dashboard. \nDEEP_LINK : any deep linking\nNAVIGATION : navigation bar. \nPRICES_PAGE : prices page in wallet. \nSEND: comes from Send product. \nSETTINGS : Settings page\n',
						enum: [
							'CURRENCY_PAGE',
							'DASHBOARD_PROMO',
							'DEEP_LINK',
							'NAVIGATION',
							'PRICES_PAGE',
							'SEND',
							'SETTINGS',
						],
						type: 'string',
					},
					platform: {
						description: 'What platform the user is clicking from',
						enum: ['WALLET'],
						type: 'string',
					},
				},
				required: ['origin', 'platform', 'device'],
				type: 'object',
			},
			traits: {
				type: 'object',
			},
		},
		required: ['properties'],
		title: 'Swap Clicked',
		type: 'object',
	}
	const message = {
		event: 'Swap Clicked',
		properties: props || {},
		options,
	}
	validateAgainstSchema(message, schema)

	const a = analytics()
	if (a) {
		a.track(
			'Swap Clicked',
			props || {},
			withTypewriterContext(options),
			callback
		)
	}
}
/**
 * Swap Crypto to Crypto (ONLY!) order is completed (when updating a custodial transaction with final state FINISHED from custodial_transactions from nabu gateway, with input and output currencies between crypto
 *
 * @param {SwapCompleted} props - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function swapCompleted(
	props: SwapCompleted,
	options?: Segment.Options,
	callback?: Segment.Callback
): void {
	const schema = {
		$schema: 'http://json-schema.org/draft-07/schema#',
		description:
			'Swap Crypto to Crypto (ONLY!) order is completed (when updating a custodial transaction with final state FINISHED from custodial_transactions from nabu gateway, with input and output currencies between crypto',
		labels: {
			flow: 'swap_v1',
			source: 'backend',
		},
		properties: {
			context: {},
			properties: {
				properties: {
					device: {
						description: 'Device type from where the event was triggered.',
						enum: ['APP-iOS', 'WEB', 'APP-Android'],
						type: 'string',
					},
					direction: {
						description:
							'What type of swap transactions it is, as a direction from/to Custodial or Non Custodial Wallet. INTERNAL is from TRADING to TRADING wallets. ON_CHAIN is from USERKEY to USERKEY. FROM_USERKEY is from USERKEY to TRADING wallets. TO_USERKEY is from TRADING to USERKEY wallets',
						enum: ['FROM_USERKEY', 'INTERNAL', 'ON_CHAIN', 'TO_USERKEY'],
						type: 'string',
					},
					from_account_type: {
						description:
							'The type of account the swap funds are coming from. (USERKEY for ON_CHAIN and FROM_USERKEY directions, TRADING for INTERNAL and TO_USERKEY)',
						enum: ['TRADING', 'USERKEY'],
						type: 'string',
					},
					input_amount: {
						description: 'The amount for the input currency',
						type: 'number',
					},
					input_amount_usd: {
						description: 'Approximate amount in USD sent by the user.',
						type: 'number',
					},
					input_currency: {
						description:
							'Symbol for the crypto currency being swap from in exchange for some other crypto currency. For example BTC in a BTC-ETH swap',
						pattern: '^[A-Z]{3,5}$',
						type: 'string',
					},
					output_amount: {
						description: 'The amount for the output currency',
						type: 'number',
					},
					output_currency: {
						description:
							'Symbol for the crypto currency being swap to. For example ETH in a BTC-ETH swap',
						pattern: '^[A-Z]{3,5}$',
						type: 'string',
					},
					payment_id: {
						description:
							'id of the payment (id of the transaction from nabu payments)',
						type: 'string',
					},
					platform: {
						description: 'What platform the event was started from. (WALLET)\n',
						enum: ['EXCHANGE', 'WALLET'],
						type: 'string',
					},
					spread_percentage: {
						description: 'Spread percentage applied to the exchange rate',
						type: 'number',
					},
					to_account_type: {
						description:
							'The type of account the swap funds are coming from. (USERKEY for ON_CHAIN and TO_USERKEY directions, TRADING for INTERNAL and FROM_USERKEY directions)',
						enum: ['TRADING', 'USERKEY'],
						type: 'string',
					},
					transaction_id: {
						description:
							'id of the transaction from nabu gateway custodial_transaction table',
						type: 'string',
					},
				},
				required: [
					'from_account_type',
					'output_currency',
					'input_amount',
					'input_currency',
					'direction',
					'to_account_type',
					'spread_percentage',
					'output_amount',
					'platform',
					'input_amount_usd',
					'device',
					'transaction_id',
				],
				type: 'object',
			},
			traits: {
				type: 'object',
			},
		},
		required: ['properties'],
		title: 'Swap Completed',
		type: 'object',
	}
	const message = {
		event: 'Swap Completed',
		properties: props || {},
		options,
	}
	validateAgainstSchema(message, schema)

	const a = analytics()
	if (a) {
		a.track(
			'Swap Completed',
			props || {},
			withTypewriterContext(options),
			callback
		)
	}
}
/**
 * User submits a Crypto to Crypto (ONLY!) swap order (when creating a custodial transaction with state CREATED from custodial_transactions from nabu gateway, with input and output currencies between crypto
 *
 * @param {SwapCreated} props - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function swapCreated(
	props: SwapCreated,
	options?: Segment.Options,
	callback?: Segment.Callback
): void {
	const schema = {
		$schema: 'http://json-schema.org/draft-07/schema#',
		description:
			'User submits a Crypto to Crypto (ONLY!) swap order (when creating a custodial transaction with state CREATED from custodial_transactions from nabu gateway, with input and output currencies between crypto',
		labels: {
			flow: 'swap_v1',
			source: 'backend',
		},
		properties: {
			context: {},
			properties: {
				properties: {
					device: {
						description: 'Device type from where the event was triggered.',
						enum: ['APP-iOS', 'WEB', 'APP-Android'],
						type: 'string',
					},
					direction: {
						description:
							'What type of swap transactions it is, as a direction from/to Custodial or Non Custodial Wallet. INTERNAL is from TRADING to TRADING wallets. ON_CHAIN is from USERKEY to USERKEY. FROM_USERKEY is from USERKEY to TRADING wallets. TO_USERKEY is from TRADING to USERKEY wallets',
						enum: ['FROM_USERKEY', 'INTERNAL', 'ON_CHAIN', 'TO_USERKEY'],
						type: 'string',
					},
					from_account_type: {
						description:
							'The type of account the swap funds are coming from. (USERKEY for ON_CHAIN and FROM_USERKEY directions, TRADING for INTERNAL and TO_USERKEY)',
						enum: ['TRADING', 'USERKEY'],
						type: 'string',
					},
					input_amount: {
						description: 'The amount for the input currency',
						type: 'number',
					},
					input_amount_usd: {
						description: 'Approximate amount in USD sent by the user.',
						type: 'number',
					},
					input_currency: {
						description:
							'Symbol for the crypto currency being swap from in exchange for some other crypto currency. For example BTC in a BTC-ETH swap',
						pattern: '^[A-Z]{3,5}$',
						type: 'string',
					},
					output_amount: {
						description: 'The amount for the output currency',
						type: 'number',
					},
					output_currency: {
						description:
							'Symbol for the crypto currency being swap to. For example ETH in a BTC-ETH swap',
						pattern: '^[A-Z]{3,5}$',
						type: 'string',
					},
					payment_id: {
						description:
							'id of the payment (id of the transaction from nabu payments)',
						type: 'string',
					},
					platform: {
						description: 'What platform the event was started from. (WALLET)\n',
						enum: ['EXCHANGE', 'WALLET'],
						type: 'string',
					},
					to_account_type: {
						description:
							'The type of account the swap funds are coming from. (USERKEY for ON_CHAIN and TO_USERKEY directions, TRADING for INTERNAL and FROM_USERKEY directions)',
						enum: ['TRADING', 'USERKEY'],
						type: 'string',
					},
					transaction_id: {
						description:
							'id of the transaction from nabu gateway custodial_transaction table',
						type: 'string',
					},
				},
				required: [
					'output_amount',
					'output_currency',
					'input_currency',
					'direction',
					'from_account_type',
					'device',
					'platform',
					'input_amount',
					'to_account_type',
					'transaction_id',
				],
				type: 'object',
			},
			traits: {
				type: 'object',
			},
		},
		required: ['properties'],
		title: 'Swap Created',
		type: 'object',
	}
	const message = {
		event: 'Swap Created',
		properties: props || {},
		options,
	}
	validateAgainstSchema(message, schema)

	const a = analytics()
	if (a) {
		a.track(
			'Swap Created',
			props || {},
			withTypewriterContext(options),
			callback
		)
	}
}
/**
 * Swap Crypto to Crypto (ONLY!) order is expired (when updating a custodial transaction with final state EXPIRED from custodial_transactions from nabu gateway, with input and output currencies between crypto
 *
 * @param {SwapExpired} props - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function swapExpired(
	props: SwapExpired,
	options?: Segment.Options,
	callback?: Segment.Callback
): void {
	const schema = {
		$schema: 'http://json-schema.org/draft-07/schema#',
		description:
			'Swap Crypto to Crypto (ONLY!) order is expired (when updating a custodial transaction with final state EXPIRED from custodial_transactions from nabu gateway, with input and output currencies between crypto',
		labels: {
			flow: 'swap_v1',
			source: 'backend',
		},
		properties: {
			context: {},
			properties: {
				properties: {
					device: {
						description: 'Device type from where the event was triggered.',
						enum: ['APP-iOS', 'WEB', 'APP-Android'],
						type: 'string',
					},
					direction: {
						description:
							'What type of swap transactions it is, as a direction from/to Custodial or Non Custodial Wallet. INTERNAL is from TRADING to TRADING wallets. ON_CHAIN is from USERKEY to USERKEY. FROM_USERKEY is from USERKEY to TRADING wallets. TO_USERKEY is from TRADING to USERKEY wallets',
						enum: ['FROM_USERKEY', 'INTERNAL', 'ON_CHAIN', 'TO_USERKEY'],
						type: 'string',
					},
					from_account_type: {
						description:
							'The type of account the swap funds are coming from. (USERKEY for ON_CHAIN and FROM_USERKEY directions, TRADING for INTERNAL and TO_USERKEY)',
						enum: ['TRADING', 'USERKEY'],
						type: 'string',
					},
					input_amount: {
						description: 'The amount for the input currency',
						type: 'number',
					},
					input_amount_usd: {
						description: 'Approximate amount in USD sent by the user.',
						type: 'number',
					},
					input_currency: {
						description:
							'Symbol for the crypto currency being swap from in exchange for some other crypto currency. For example BTC in a BTC-ETH swap',
						pattern: '^[A-Z]{3,5}$',
						type: 'string',
					},
					output_amount: {
						description: 'The amount for the output currency',
						type: 'number',
					},
					output_currency: {
						description:
							'Symbol for the crypto currency being swap to. For example ETH in a BTC-ETH swap',
						pattern: '^[A-Z]{3,5}$',
						type: 'string',
					},
					payment_id: {
						description:
							'id of the payment (id of the transaction from nabu payments)',
						type: 'string',
					},
					platform: {
						description: 'What platform the event was started from. (WALLET)',
						enum: ['EXCHANGE', 'WALLET'],
						type: 'string',
					},
					to_account_type: {
						description:
							'The type of account the swap funds are coming from. (USERKEY for ON_CHAIN and TO_USERKEY directions, TRADING for INTERNAL and FROM_USERKEY directions)',
						enum: ['TRADING', 'USERKEY'],
						type: 'string',
					},
					transaction_id: {
						description:
							'id of the transaction from nabu gateway custodial_transaction table',
						type: 'string',
					},
				},
				required: [
					'output_currency',
					'to_account_type',
					'transaction_id',
					'output_amount',
					'device',
					'from_account_type',
					'direction',
					'platform',
					'input_currency',
					'input_amount',
				],
				type: 'object',
			},
			traits: {
				type: 'object',
			},
		},
		required: ['properties'],
		title: 'Swap Expired',
		type: 'object',
	}
	const message = {
		event: 'Swap Expired',
		properties: props || {},
		options,
	}
	validateAgainstSchema(message, schema)

	const a = analytics()
	if (a) {
		a.track(
			'Swap Expired',
			props || {},
			withTypewriterContext(options),
			callback
		)
	}
}
/**
 * Swap Crypto to Crypto (ONLY!) order is failed (when updating a custodial transaction with final state FAILED from custodial_transactions from nabu gateway, with input and output currencies between crypto
 *
 * @param {SwapFailed} props - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function swapFailed(
	props: SwapFailed,
	options?: Segment.Options,
	callback?: Segment.Callback
): void {
	const schema = {
		$schema: 'http://json-schema.org/draft-07/schema#',
		description:
			'Swap Crypto to Crypto (ONLY!) order is failed (when updating a custodial transaction with final state FAILED from custodial_transactions from nabu gateway, with input and output currencies between crypto',
		labels: {
			flow: 'swap_v1',
			source: 'backend',
		},
		properties: {
			context: {},
			properties: {
				properties: {
					device: {
						description: 'Device type from where the event was triggered.',
						enum: ['APP-iOS', 'WEB', 'APP-Android'],
						type: 'string',
					},
					direction: {
						description:
							'What type of swap transactions it is, as a direction from/to Custodial or Non Custodial Wallet. INTERNAL is from TRADING to TRADING wallets. ON_CHAIN is from USERKEY to USERKEY. FROM_USERKEY is from USERKEY to TRADING wallets. TO_USERKEY is from TRADING to USERKEY wallets',
						enum: ['FROM_USERKEY', 'INTERNAL', 'ON_CHAIN', 'TO_USERKEY'],
						type: 'string',
					},
					from_account_type: {
						description:
							'The type of account the swap funds are coming from. (USERKEY for ON_CHAIN and FROM_USERKEY directions, TRADING for INTERNAL and TO_USERKEY)',
						enum: ['TRADING', 'USERKEY'],
						type: 'string',
					},
					input_amount: {
						description: 'The amount for the input currency',
						type: 'number',
					},
					input_amount_usd: {
						description: 'Approximate amount in USD sent by the user.',
						type: 'number',
					},
					input_currency: {
						description:
							'Symbol for the crypto currency being swap from in exchange for some other crypto currency. For example BTC in a BTC-ETH swap',
						pattern: '^[A-Z]{3,5}$',
						type: 'string',
					},
					output_amount: {
						description: 'The amount for the output currency',
						type: 'number',
					},
					output_currency: {
						description:
							'Symbol for the crypto currency being swap to. For example ETH in a BTC-ETH swap',
						pattern: '^[A-Z]{3,5}$',
						type: 'string',
					},
					payment_id: {
						description:
							'id of the payment (id of the transaction from nabu payments)',
						type: 'string',
					},
					platform: {
						description: 'What platform the event was started from. (WALLET)',
						enum: ['EXCHANGE', 'WALLET'],
						type: 'string',
					},
					to_account_type: {
						description:
							'The type of account the swap funds are coming from. (USERKEY for ON_CHAIN and TO_USERKEY directions, TRADING for INTERNAL and FROM_USERKEY directions)',
						enum: ['TRADING', 'USERKEY'],
						type: 'string',
					},
					transaction_id: {
						description:
							'id of the transaction from nabu gateway custodial_transaction table',
						type: 'string',
					},
				},
				required: [
					'output_currency',
					'input_currency',
					'direction',
					'input_amount',
					'output_amount',
					'device',
					'platform',
					'to_account_type',
					'from_account_type',
					'transaction_id',
				],
				type: 'object',
			},
			traits: {
				type: 'object',
			},
		},
		required: ['properties'],
		title: 'Swap Failed',
		type: 'object',
	}
	const message = {
		event: 'Swap Failed',
		properties: props || {},
		options,
	}
	validateAgainstSchema(message, schema)

	const a = analytics()
	if (a) {
		a.track(
			'Swap Failed',
			props || {},
			withTypewriterContext(options),
			callback
		)
	}
}
/**
 * The user selects and submits from what account and currency the swap funds should come from.  Event is triggered when a specific account and currency are selected from a dropdown or list of potential accounts
 *
 * @param {SwapFromSelected} props - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function swapFromSelected(
	props: SwapFromSelected,
	options?: Segment.Options,
	callback?: Segment.Callback
): void {
	const schema = {
		$schema: 'http://json-schema.org/draft-07/schema#',
		description:
			'The user selects and submits from what account and currency the swap funds should come from.  Event is triggered when a specific account and currency are selected from a dropdown or list of potential accounts',
		labels: {
			flow: 'swap_v1',
			source: 'client',
		},
		properties: {
			context: {},
			properties: {
				properties: {
					device: {
						description: 'Device type from where the event was triggered.',
						enum: ['APP-iOS', 'WEB', 'APP-Android'],
						type: 'string',
					},
					input_currency: {
						description:
							'Currency symbol for the currency being swap from in exchange for some other currency. For example BTC in a BTC-ETH swap',
						pattern: '^[A-Z]{3,5}$',
						type: 'string',
					},
					input_type: {
						description: 'The type of account the swap funds are coming from',
						enum: ['TRADING', 'USERKEY'],
						type: 'string',
					},
					platform: {
						description: 'From what platform the user wants to Swap from',
						enum: ['WALLET'],
						type: 'string',
					},
				},
				required: ['input_type', 'device', 'platform', 'input_currency'],
				type: 'object',
			},
			traits: {
				type: 'object',
			},
		},
		required: ['properties'],
		title: 'Swap From Selected',
		type: 'object',
	}
	const message = {
		event: 'Swap From Selected',
		properties: props || {},
		options,
	}
	validateAgainstSchema(message, schema)

	const a = analytics()
	if (a) {
		a.track(
			'Swap From Selected',
			props || {},
			withTypewriterContext(options),
			callback
		)
	}
}
/**
 * The user selects and submits to what account the swapped funds and currency should be received to. Event is triggered when a specific account and currency are selected from a dropdown or list of potential accounts
 *
 * @param {SwapReceiveSelected} props - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function swapReceiveSelected(
	props: SwapReceiveSelected,
	options?: Segment.Options,
	callback?: Segment.Callback
): void {
	const schema = {
		$schema: 'http://json-schema.org/draft-07/schema#',
		description:
			'The user selects and submits to what account the swapped funds and currency should be received to. Event is triggered when a specific account and currency are selected from a dropdown or list of potential accounts',
		labels: {
			flow: 'swap_v1',
			source: 'client',
		},
		properties: {
			context: {},
			properties: {
				properties: {
					device: {
						description: 'Device type from where the event was triggered.',
						enum: ['APP-iOS', 'WEB', 'APP-Android'],
						type: 'string',
					},
					output_currency: {
						description:
							'Currency symbol for the currency being swap to. For example ETH in a BTC-ETH swap',
						pattern: '^[A-Z]{3,5}$',
						type: 'string',
					},
					output_type: {
						description: 'The type of account the swap funds are going to',
						enum: ['TRADING', 'USERKEY'],
						type: 'string',
					},
					platform: {
						description: 'From what platform the user wants to Swap from',
						enum: ['WALLET'],
						type: 'string',
					},
				},
				required: ['device', 'output_currency', 'output_type', 'platform'],
				type: 'object',
			},
			traits: {
				type: 'object',
			},
		},
		required: ['properties'],
		title: 'Swap Receive Selected',
		type: 'object',
	}
	const message = {
		event: 'Swap Receive Selected',
		properties: props || {},
		options,
	}
	validateAgainstSchema(message, schema)

	const a = analytics()
	if (a) {
		a.track(
			'Swap Receive Selected',
			props || {},
			withTypewriterContext(options),
			callback
		)
	}
}
/**
 * Swap Crypto to Crypto (ONLY!) order is rejected. It is not being created at all
 *
 * @param {SwapRejected} props - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function swapRejected(
	props: SwapRejected,
	options?: Segment.Options,
	callback?: Segment.Callback
): void {
	const schema = {
		$schema: 'http://json-schema.org/draft-07/schema#',
		description:
			'Swap Crypto to Crypto (ONLY!) order is rejected. It is not being created at all',
		labels: {
			flow: 'swap_v1',
			source: 'backend',
		},
		properties: {
			context: {},
			properties: {
				properties: {
					device: {
						description: 'Device type from where the event was triggered.',
						enum: ['APP-iOS', 'WEB', 'APP-Android'],
						type: 'string',
					},
					direction: {
						description:
							'What type of swap transactions it is, as a direction from/to Custodial or Non Custodial Wallet. INTERNAL is from TRADING to TRADING wallets. ON_CHAIN is from USERKEY to USERKEY. FROM_USERKEY is from USERKEY to TRADING wallets. TO_USERKEY is from TRADING to USERKEY wallets',
						enum: ['FROM_USERKEY', 'INTERNAL', 'ON_CHAIN', 'TO_USERKEY'],
						type: 'string',
					},
					error_message: {
						description: 'error message for the rejection',
						type: 'string',
					},
					from_account_type: {
						description:
							'The type of account the swap funds are coming from. (USERKEY for ON_CHAIN and FROM_USERKEY directions, TRADING for INTERNAL and TO_USERKEY)',
						enum: ['TRADING', 'USERKEY'],
						type: 'string',
					},
					input_amount: {
						description: 'The amount for the input currency',
						type: 'number',
					},
					input_amount_usd: {
						description: 'Approximate amount in USD sent by the user.',
						type: 'number',
					},
					input_currency: {
						description:
							'Symbol for the crypto currency being swap from in exchange for some other crypto currency. For example BTC in a BTC-ETH swap',
						pattern: '^[A-Z]{3,5}$',
						type: 'string',
					},
					output_amount: {
						description: 'The amount for the output currency',
						type: 'number',
					},
					output_currency: {
						description:
							'Symbol for the crypto currency being swap to. For example ETH in a BTC-ETH swap',
						pattern: '^[A-Z]{3,5}$',
						type: 'string',
					},
					payment_id: {
						description:
							'id of the payment (id of the transaction from nabu payments)',
						type: 'string',
					},
					platform: {
						description: 'What platform the event was started from. (WALLET)',
						enum: ['EXCHANGE', 'WALLET'],
						type: 'string',
					},
					property: {
						description: 'What platform the event was started from. (WALLET)',
						enum: ['EXCHANGE', 'WALLET'],
						type: 'string',
					},
					rejection_reason: {
						description:
							'The main reason why creating the swap order was rejected.',
						type: 'string',
					},
					to_account_type: {
						description:
							'The type of account the swap funds are coming from. (USERKEY for ON_CHAIN and TO_USERKEY directions, TRADING for INTERNAL and FROM_USERKEY directions)',
						enum: ['TRADING', 'USERKEY'],
						type: 'string',
					},
				},
				required: [
					'to_account_type',
					'platform',
					'device',
					'input_currency',
					'output_currency',
					'from_account_type',
					'rejection_reason',
					'output_amount',
					'direction',
					'transaction_id',
					'input_amount',
					'property',
				],
				type: 'object',
			},
			traits: {
				type: 'object',
			},
		},
		required: ['properties'],
		title: 'Swap Rejected',
		type: 'object',
	}
	const message = {
		event: 'Swap Rejected',
		properties: props || {},
		options,
	}
	validateAgainstSchema(message, schema)

	const a = analytics()
	if (a) {
		a.track(
			'Swap Rejected',
			props || {},
			withTypewriterContext(options),
			callback
		)
	}
}
/**
 * User confirms and submits a Crypto to Crypto (ONLY!) swap order and the client requests the swap to be created to the backend. We record this in the client because the backend doesn't have the fee information.
 *
 * @param {SwapRequested} props - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function swapRequested(
	props: SwapRequested,
	options?: Segment.Options,
	callback?: Segment.Callback
): void {
	const schema = {
		$schema: 'http://json-schema.org/draft-07/schema#',
		description:
			"User confirms and submits a Crypto to Crypto (ONLY!) swap order and the client requests the swap to be created to the backend. We record this in the client because the backend doesn't have the fee information.",
		labels: {
			flow: 'swap_v1',
			source: 'client',
		},
		properties: {
			context: {},
			properties: {
				properties: {
					device: {
						description: 'Device type from where the event was triggered.',
						enum: ['APP-iOS', 'WEB', 'APP-Android'],
						type: 'string',
					},
					exchange_rate: {
						description:
							'The exchange rate of the swap, how much 1 input_currency is worth in output_currency.. For example, for a BTC-ETH swap, we would have 1 BTC = 31.48 ETH, we would store 31.48',
						type: 'number',
					},
					input_amount: {
						description: 'The amount for the input currency',
						type: 'number',
					},
					input_currency: {
						description:
							'Symbol for the crypto currency being swap from in exchange for some other crypto currency. For example BTC in a BTC-ETH swap',
						pattern: '^[A-Z]{3,5}$',
						type: 'string',
					},
					input_type: {
						description:
							'The type of account the swap funds are coming from. (USERKEY for ON_CHAIN and FROM_USERKEY directions, TRADING for INTERNAL and TO_USERKEY)',
						enum: ['TRADING', 'USERKEY'],
						type: 'string',
					},
					network_fee_input_amount: {
						description:
							'Network fee amount for the deposit (input) of the swap transaction. Amount should be for the network_fee_input_currency. Will be 0 for input_type TRADING and > 0 for USERKEY',
						type: 'number',
					},
					network_fee_input_currency: {
						description:
							'Network fee currency for the deposit (input) of the swap transaction, for the network_fee_input_amount',
						pattern: '^[A-Z]{3,5}$',
						type: 'string',
					},
					network_fee_output_amount: {
						description:
							'Network fee amount for the destination (output) of the swap transaction. Amount should be for the network_fee_output_currency. Will be 0 for output_type TRADING and > 0 for USERKEY',
						type: 'number',
					},
					network_fee_output_currency: {
						description:
							'Network fee currency for the destination (output) of the swap transaction, for the network_fee_output_amount',
						pattern: '^[A-Z]{3,5}$',
						type: 'string',
					},
					output_amount: {
						description: 'The amount for the output currency',
						type: 'number',
					},
					output_currency: {
						description:
							'Symbol for the crypto currency being swap to. For example ETH in a BTC-ETH swap',
						pattern: '^[A-Z]{3,5}$',
						type: 'string',
					},
					output_type: {
						description:
							'The type of account the swap funds are going to. (USERKEY for ON_CHAIN and TO_USERKEY directions, TRADING for INTERNAL and FROM_USERKEY directions)',
						enum: ['TRADING', 'USERKEY'],
						type: 'string',
					},
					platform: {
						description: 'From what platform the user wants to Swap from',
						enum: ['WALLET'],
						type: 'string',
					},
				},
				required: [
					'platform',
					'input_amount',
					'network_fee_input_amount',
					'network_fee_output_amount',
					'output_type',
					'device',
					'network_fee_output_currency',
					'input_type',
					'input_currency',
					'output_amount',
					'network_fee_input_currency',
					'output_currency',
				],
				type: 'object',
			},
			traits: {
				type: 'object',
			},
		},
		required: ['properties'],
		title: 'Swap Requested',
		type: 'object',
	}
	const message = {
		event: 'Swap Requested',
		properties: props || {},
		options,
	}
	validateAgainstSchema(message, schema)

	const a = analytics()
	if (a) {
		a.track(
			'Swap Requested',
			props || {},
			withTypewriterContext(options),
			callback
		)
	}
}
/**
 * Swap modal or screen viewed. (SWAP_MODAL for web, Swap tab screens for mobile)
 *
 * @param {SwapViewed} [props] - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function swapViewed(
	props?: SwapViewed,
	options?: Segment.Options,
	callback?: Segment.Callback
): void {
	const schema = {
		$schema: 'http://json-schema.org/draft-07/schema#',
		description:
			'Swap modal or screen viewed. (SWAP_MODAL for web, Swap tab screens for mobile)',
		labels: {
			flow: 'swap_v1',
			source: 'client',
		},
		properties: {
			context: {},
			properties: {
				properties: {
					device: {
						description: 'Device type from where the event was triggered.',
						enum: ['APP-iOS', 'WEB', 'APP-Android'],
						type: 'string',
					},
					path: {
						description:
							'Path portion of the URL of the page. Equivalent to canonical path which defaults to location.pathname from the DOM API.',
						type: 'string',
					},
					platform: {
						description: 'What platform the page viewed belongs to',
						enum: ['WALLET'],
						type: 'string',
					},
					referrer: {
						description:
							'Full URL of the previous page. Equivalent to document.referrer from the DOM API.',
						type: 'string',
					},
					search: {
						description:
							'Query string portion of the URL of the page. Equivalent to location.search from the DOM API.',
						type: 'string',
					},
					title: {
						description:
							'Title of the page. Equivalent to document.title from the DOM API.',
						type: 'string',
					},
					url: {
						description:
							'Full URL of the page. First we look for the canonical url. If the canonical url is not provided, we use location.href from the DOM API.',
						type: 'string',
					},
				},
				required: ['device'],
				type: 'object',
			},
			traits: {
				type: 'object',
			},
		},
		title: 'Swap Viewed',
		type: 'object',
	}
	const message = {
		event: 'Swap Viewed',
		properties: props || {},
		options,
	}
	validateAgainstSchema(message, schema)

	const a = analytics()
	if (a) {
		a.track(
			'Swap Viewed',
			props || {},
			withTypewriterContext(options),
			callback
		)
	}
}
/**
 * User swipes to turn on or turn off the receiving feature.
 *
 * @param {SwipeToReceiveOptionUpdated} props - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function swipeToReceiveOptionUpdated(
	props: SwipeToReceiveOptionUpdated,
	options?: Segment.Options,
	callback?: Segment.Callback
): void {
	const schema = {
		$schema: 'http://json-schema.org/draft-07/schema#',
		description: 'User swipes to turn on or turn off the receiving feature.',
		labels: {
			flow: 'security_v1',
			source: 'client',
		},
		properties: {
			context: {},
			properties: {
				properties: {
					device: {
						description: 'Device type from where the event was triggered.',
						enum: ['WEB'],
						type: 'string',
					},
					is_enabled: {
						description: 'Receiving feature was enabled or disabled.',
						type: 'boolean',
					},
					platform: {
						description:
							'From what platform the user is managing Security events',
						enum: ['WALLET'],
						type: 'string',
					},
				},
				required: ['is_enabled', 'device', 'platform'],
				type: 'object',
			},
			traits: {
				type: 'object',
			},
		},
		required: ['properties'],
		title: 'Swipe To Receive Option Updated',
		type: 'object',
	}
	const message = {
		event: 'Swipe To Receive Option Updated',
		properties: props || {},
		options,
	}
	validateAgainstSchema(message, schema)

	const a = analytics()
	if (a) {
		a.track(
			'Swipe To Receive Option Updated',
			props || {},
			withTypewriterContext(options),
			callback
		)
	}
}
/**
 * Portfolio Widget Sync was turned on or turned off
 *
 * @param {SyncMyWidgetPortfolioUpdated} props - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function syncMyWidgetPortfolioUpdated(
	props: SyncMyWidgetPortfolioUpdated,
	options?: Segment.Options,
	callback?: Segment.Callback
): void {
	const schema = {
		$schema: 'http://json-schema.org/draft-07/schema#',
		description: 'Portfolio Widget Sync was turned on or turned off',
		labels: {
			flow: 'security_v1',
			source: 'client',
		},
		properties: {
			context: {},
			properties: {
				properties: {
					device: {
						description: 'Device type from where the event was triggered.',
						enum: ['APP-iOS'],
						type: 'string',
					},
					is_enabled: {
						description:
							'My Widget Portafolio Sync option enabled or disabled.',
						type: 'boolean',
					},
					platform: {
						description:
							'From what platform the user is managing Security events',
						enum: ['WALLET'],
						type: 'string',
					},
				},
				required: ['platform', 'is_enabled', 'device'],
				type: 'object',
			},
			traits: {
				type: 'object',
			},
		},
		required: ['properties'],
		title: 'Sync My Widget Portfolio Updated',
		type: 'object',
	}
	const message = {
		event: 'Sync My Widget Portfolio Updated',
		properties: props || {},
		options,
	}
	validateAgainstSchema(message, schema)

	const a = analytics()
	if (a) {
		a.track(
			'Sync My Widget Portfolio Updated',
			props || {},
			withTypewriterContext(options),
			callback
		)
	}
}
/**
 * User sets their preferred theme from the displayed options.
 *
 * @param {ThemeSet} props - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function themeSet(
	props: ThemeSet,
	options?: Segment.Options,
	callback?: Segment.Callback
): void {
	const schema = {
		$schema: 'http://json-schema.org/draft-07/schema#',
		description: 'User sets their preferred theme from the displayed options.',
		labels: {
			flow: 'settings_v1',
			source: 'backend',
		},
		properties: {
			context: {},
			properties: {
				properties: {
					device: {
						description: 'Device type from where the event was triggered.',
						enum: ['APP-iOS', 'WEB', 'APP-Android'],
						type: 'string',
					},
					platform: {
						description: 'From what platform the user is using the Settings',
						enum: ['EXCHANGE', 'WALLET'],
						type: 'string',
					},
					theme: {
						description: '',
						enum: ['COMPLEMENT', 'DARAKMODE', 'DEFAULT', 'GRAYSCALE', 'INVERT'],
						type: 'string',
					},
				},
				required: ['theme', 'platform'],
				type: 'object',
			},
			traits: {
				type: 'object',
			},
		},
		required: ['properties'],
		title: 'Theme Set',
		type: 'object',
	}
	const message = {
		event: 'Theme Set',
		properties: props || {},
		options,
	}
	validateAgainstSchema(message, schema)

	const a = analytics()
	if (a) {
		a.track('Theme Set', props || {}, withTypewriterContext(options), callback)
	}
}
/**
 * The user enters and submits the amount for an exchange trade order. The user will typically confirms the trade in the next screen
 *
 * @param {TradeAmountEntered} props - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function tradeAmountEntered(
	props: TradeAmountEntered,
	options?: Segment.Options,
	callback?: Segment.Callback
): void {
	const schema = {
		$schema: 'http://json-schema.org/draft-07/schema#',
		description:
			'The user enters and submits the amount for an exchange trade order. The user will typically confirms the trade in the next screen',
		labels: {
			flow: ['trade_e1', 'margin'],
			source: 'client',
		},
		properties: {
			context: {},
			properties: {
				properties: {
					collateral_type: {
						description: 'Currency for collateral',
						pattern: '^[A-Z]{3,5}$',
						type: 'string',
					},
					device: {
						description: 'Device type from where the event was triggered.',
						enum: ['APP-iOS', 'WEB', 'APP-Android'],
						type: 'string',
					},
					input_amount: {
						description: 'Amount of the trade in input currency',
						type: 'number',
					},
					leverage_ratio: {
						description: 'Ratio of leverage. 2 for 2x, 3 for 3x, etc.',
						type: ['number', 'null'],
					},
					limit_price: {
						description: 'Limit price of the trade (empty for market orders)',
						type: 'number',
					},
					pair: {
						description: 'What is the trading pair of the trade',
						pattern: '^[A-Z]{3,5}-[A-Z]{3,5}$',
						type: 'string',
					},
					platform: {
						description: 'From what platform the event is triggered',
						enum: ['EXCHANGE'],
						type: 'string',
					},
					side: {
						description: "whether it's a buy or sell trade",
						enum: ['BUY', 'SELL'],
						type: 'string',
					},
					stop_loss: {
						description: 'Stop loss price for leverage',
						type: 'number',
					},
					stop_price: {
						description: 'Stop price of the trade (only for stop-limit orders)',
						type: 'number',
					},
					tif: {
						description:
							'Time In Force (empty for Market trades, required otherwise)',
						enum: ['FOK', 'GTC', 'GTD', 'IOC'],
						type: 'string',
					},
					trade_type: {
						description: 'What type of trade is created',
						enum: ['LIMIT', 'MARKET', 'STOP', 'STOP_LIMIT'],
						type: 'string',
					},
					with_leverage: {
						description: 'Trade with leverage',
						type: 'boolean',
					},
				},
				required: [
					'platform',
					'trade_type',
					'tif',
					'input_amount',
					'pair',
					'with_leverage',
					'side',
					'device',
				],
				type: 'object',
			},
			traits: {
				type: 'object',
			},
		},
		required: ['properties'],
		title: 'Trade Amount Entered',
		type: 'object',
	}
	const message = {
		event: 'Trade Amount Entered',
		properties: props || {},
		options,
	}
	validateAgainstSchema(message, schema)

	const a = analytics()
	if (a) {
		a.track(
			'Trade Amount Entered',
			props || {},
			withTypewriterContext(options),
			callback
		)
	}
}
/**
 * The user clicked on the widget or button which sets pre selected amounts to the order
 *
 * @param {TradeAmountHelperClicked} props - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function tradeAmountHelperClicked(
	props: TradeAmountHelperClicked,
	options?: Segment.Options,
	callback?: Segment.Callback
): void {
	const schema = {
		$schema: 'http://json-schema.org/draft-07/schema#',
		description:
			'The user clicked on the widget or button which sets pre selected amounts to the order',
		labels: {
			flow: 'trade_e1',
			source: 'client',
		},
		properties: {
			context: {},
			properties: {
				properties: {
					amount: {
						description:
							'What amount in amount_currency the user clicks on (either amount or amount_pct should be specified)',
						type: 'number',
					},
					amount_currency: {
						description:
							'What currency  for the amount selected (empty if the amount is in percentage)',
						pattern: '^[A-Z]{3,5}$',
						type: 'string',
					},
					amount_pct: {
						description:
							'What amount percentage the user clicks on (either amount or amount_pct should be specified) Enter 25 if 25% selected',
						type: 'integer',
					},
					device: {
						description: 'Device type from where the event was triggered.',
						enum: ['APP-iOS', 'WEB', 'APP-Android'],
						type: 'string',
					},
					input_amount: {
						description: 'Amount of the trade in input currency',
						type: 'number',
					},
					pair: {
						description: 'What is the trading pair of the trade',
						pattern: '^[A-Z]{3,5}-[A-Z]{3,5}$',
						type: 'string',
					},
					platform: {
						description: 'From what platform the amount is triggered',
						enum: ['EXCHANGE'],
						type: 'string',
					},
					side: {
						description: "whether it's a buy or sell trade",
						enum: ['BUY', 'SELL'],
						type: 'string',
					},
					tif: {
						description:
							'Time In Force (empty for Market trades, required otherwise)',
						enum: ['FOK', 'GTC', 'GTD', 'IOC'],
						type: 'string',
					},
					trade_type: {
						description: 'What type of trade is created',
						enum: ['LIMIT', 'MARKET', 'STOP', 'STOP_LIMIT'],
						type: 'string',
					},
				},
				required: [
					'device',
					'platform',
					'trade_type',
					'tif',
					'input_amount',
					'pair',
					'side',
				],
				type: 'object',
			},
			traits: {
				type: 'object',
			},
		},
		required: ['properties'],
		title: 'Trade Amount Helper Clicked',
		type: 'object',
	}
	const message = {
		event: 'Trade Amount Helper Clicked',
		properties: props || {},
		options,
	}
	validateAgainstSchema(message, schema)

	const a = analytics()
	if (a) {
		a.track(
			'Trade Amount Helper Clicked',
			props || {},
			withTypewriterContext(options),
			callback
		)
	}
}
/**
 * The client sends a requests to the backend to cancel a trade, for example after clicking on "cancel order" or similar buttons
 *
 * @param {TradeCancellationRequested} props - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function tradeCancellationRequested(
	props: TradeCancellationRequested,
	options?: Segment.Options,
	callback?: Segment.Callback
): void {
	const schema = {
		$schema: 'http://json-schema.org/draft-07/schema#',
		description:
			'The client sends a requests to the backend to cancel a trade, for example after clicking on "cancel order" or similar buttons',
		labels: {
			flow: 'trade_e1',
			source: 'client',
		},
		properties: {
			context: {},
			properties: {
				properties: {
					device: {
						description: 'Device type from where the event was triggered.',
						enum: ['APP-iOS', 'WEB', 'APP-Android'],
						type: 'string',
					},
					origin: {
						description:
							'What button the user clicked on to request the cancelation.  OPEN_ORDERS : From the list of open orders. TRADE_HISTORY : from the trade history page. TRADE_DETAILS : bottom of the trade details.',
						enum: ['OPEN_ORDERS', 'TRADE_DETAILS', 'TRADE_HISTORY'],
						type: 'string',
					},
				},
				required: ['origin', 'device'],
				type: 'object',
			},
			traits: {
				type: 'object',
			},
		},
		required: ['properties'],
		title: 'Trade Cancellation Requested',
		type: 'object',
	}
	const message = {
		event: 'Trade Cancellation Requested',
		properties: props || {},
		options,
	}
	validateAgainstSchema(message, schema)

	const a = analytics()
	if (a) {
		a.track(
			'Trade Cancellation Requested',
			props || {},
			withTypewriterContext(options),
			callback
		)
	}
}
/**
 * A Trade has been created. This event was not implemented due to the fact the market makers will trigger the event constantly. consider using Trade Preview Submitted as an alternative
 *
 * @param {TradeCreated} props - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function tradeCreated(
	props: TradeCreated,
	options?: Segment.Options,
	callback?: Segment.Callback
): void {
	const schema = {
		$schema: 'http://json-schema.org/draft-07/schema#',
		description:
			'A Trade has been created. This event was not implemented due to the fact the market makers will trigger the event constantly. consider using Trade Preview Submitted as an alternative',
		labels: {
			flow: ['trade_e1', 'margin'],
			source: 'backend',
		},
		properties: {
			context: {},
			properties: {
				properties: {
					device: {
						description: 'Device type from where the event was triggered.',
						enum: ['APP-iOS', 'WEB', 'APP-Android'],
						type: 'string',
					},
					exchange_rate: {
						description:
							'the exchange rate, If pair is BTC-USD, it is how much 1 BTC is worth in BTC. ',
						type: 'number',
					},
					handle_instruction: {
						description:
							'Handle instruction. M for margin order, PSF for spot orders that are created in the background to close a margin position, null for spot orders, C not used at the moment.',
						enum: [
							'CASH',
							'CLOSE_POSITION_MARGIN',
							'FORCE_CLOSE_POSITION_MARGIN',
							'MARGIN',
							'STOP_LOSS_CLOSE_POSITION_MARGIN',
							null,
						],
						type: ['string', 'null'],
					},
					input_amount: {
						description: 'Amount of the trade in input currency',
						type: 'number',
					},
					input_amount_usd: {
						description: 'Amount of the trade in USD',
						type: 'number',
					},
					pair: {
						description: 'What is the trading pair of the trade',
						pattern: '^[A-Z]{3,5}-[A-Z]{3,5}$',
						type: 'string',
					},
					side: {
						description: "whether it's a buy or sell trade",
						enum: ['BUY', 'SELL'],
						type: 'string',
					},
					tif: {
						description:
							'Time In Force (empty for Market trades, required otherwise)',
						enum: ['FOK', 'GTC', 'GTD', 'IOC'],
						type: 'string',
					},
					trade_id: {
						description: 'TBD with Niall',
						type: 'string',
					},
					trade_type: {
						description: 'What type of trade is created',
						enum: ['LIMIT', 'MARKET', 'STOP', 'STOP_LIMIT'],
						type: 'string',
					},
				},
				required: [
					'trade_type',
					'pair',
					'input_amount_usd',
					'input_amount',
					'exchange_rate',
					'side',
					'device',
				],
				type: 'object',
			},
			traits: {
				type: 'object',
			},
		},
		required: ['properties'],
		title: 'Trade Created',
		type: 'object',
	}
	const message = {
		event: 'Trade Created',
		properties: props || {},
		options,
	}
	validateAgainstSchema(message, schema)

	const a = analytics()
	if (a) {
		a.track(
			'Trade Created',
			props || {},
			withTypewriterContext(options),
			callback
		)
	}
}
/**
 * A Trade has been filled or partially filled. If a trade is fully filled in two parts, this event will be triggered twice and the sum of the input_amount should match the trade amount
 *
 * @param {TradeFilled} props - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function tradeFilled(
	props: TradeFilled,
	options?: Segment.Options,
	callback?: Segment.Callback
): void {
	const schema = {
		$schema: 'http://json-schema.org/draft-07/schema#',
		description:
			'A Trade has been filled or partially filled. If a trade is fully filled in two parts, this event will be triggered twice and the sum of the input_amount should match the trade amount',
		labels: {
			flow: ['trade_e1', 'margin'],
			source: 'backend',
		},
		properties: {
			context: {},
			properties: {
				properties: {
					device: {
						description: 'Device type from where the event was triggered.',
						enum: ['APP-iOS', 'WEB', 'APP-Android'],
						type: 'string',
					},
					exchange_rate: {
						description:
							'the exchange rate, If pair is BTC-USD, it is how much 1 BTC is worth in BTC. ',
						type: 'number',
					},
					fee_amount: {
						description:
							'Trade fee in native counter currency. (for BTC-ETH pair it would be ETH). For 0.013 ETH fee, enter 0.013.',
						type: 'number',
					},
					fee_amount_usd: {
						description:
							'IMPORTANT : Trade fee in USD. This will be used for revenue information. For 0.12 USD enter 0.12, NOT 12.',
						type: 'number',
					},
					handle_instruction: {
						description:
							'Handle instruction. M for margin order, PSF for spot orders that are created in the background to close a margin position, null for spot orders, C not used at the moment.',
						enum: [
							'CASH',
							'CLOSE_POSITION_MARGIN',
							'FORCE_CLOSE_POSITION_MARGIN',
							'MARGIN',
							'STOP_LOSS_CLOSE_POSITION_MARGIN',
						],
						type: 'string',
					},
					input_amount: {
						description:
							'The amount being filled for the trade, the input currency',
						type: 'number',
					},
					input_amount_usd: {
						description: 'The amount being filled for the trade in USD',
						type: 'number',
					},
					liquidity_indicator: {
						description:
							'Whether the trade fill Adds liquidity (A) = MAKER  or Removes liquidity = TAKER. or NEUTRAL',
						enum: ['MAKER', 'NEUTRAL', 'TAKER'],
						type: 'string',
					},
					pair: {
						description: 'What is the trading pair of the trade',
						pattern: '^[A-Z]{3,5}-[A-Z]{3,5}$',
						type: 'string',
					},
					side: {
						description: 'Whether it is a Buy or Sell trade',
						enum: ['BUY', 'SELL'],
						type: 'string',
					},
					tif: {
						description:
							'Time In Force (empty for Market trades, required otherwise)',
						enum: ['FOK', 'GTC', 'GTD', 'IOC'],
						type: 'string',
					},
					trade_id: {
						description: 'TBD with Niall',
						type: 'string',
					},
					trade_type: {
						description: 'What type of trade is created',
						enum: ['LIMIT', 'MARKET', 'STOP', 'STOP_LIMIT'],
						type: 'string',
					},
					volume_usd_last_30d: {
						description:
							'What is the trading volume of the user in the last 30d, including this input_amount_usd. This is mainly used for Tune integration to reward user based on the user tier.',
						type: 'number',
					},
				},
				required: [
					'pair',
					'exchange_rate',
					'side',
					'input_amount_usd',
					'input_amount',
					'liquidity_indicator',
					'fee_amount_usd',
					'tif',
					'handle_instruction',
					'trade_type',
					'device',
					'volume_usd_last_30d',
					'fee_amount',
				],
				type: 'object',
			},
			traits: {
				type: 'object',
			},
		},
		required: ['properties'],
		title: 'Trade Filled',
		type: 'object',
	}
	const message = {
		event: 'Trade Filled',
		properties: props || {},
		options,
	}
	validateAgainstSchema(message, schema)

	const a = analytics()
	if (a) {
		a.track(
			'Trade Filled',
			props || {},
			withTypewriterContext(options),
			callback
		)
	}
}
/**
 * The user clicks to cancel the trade being previewed. The preview is typically the final screen before the trade is actually placed, just after the amount is entered.
 *
 * @param {TradePreviewCancelled} props - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function tradePreviewCancelled(
	props: TradePreviewCancelled,
	options?: Segment.Options,
	callback?: Segment.Callback
): void {
	const schema = {
		$schema: 'http://json-schema.org/draft-07/schema#',
		description:
			'The user clicks to cancel the trade being previewed. The preview is typically the final screen before the trade is actually placed, just after the amount is entered.',
		labels: {
			flow: 'trade_e1',
			source: 'client',
		},
		properties: {
			context: {},
			properties: {
				properties: {
					device: {
						description: 'Device type from where the event was triggered.',
						enum: ['APP-iOS', 'WEB', 'APP-Android'],
						type: 'string',
					},
					input_amount: {
						description: 'Amount of the trade in input currency',
						type: 'number',
					},
					limit_price: {
						description: 'Limit price of the trade (empty for market orders)',
						type: 'number',
					},
					pair: {
						description: 'What is the trading pair of the trade',
						pattern: '^[A-Z]{3,5}-[A-Z]{3,5}$',
						type: 'string',
					},
					platform: {
						description: 'From what platform the event is triggered',
						enum: ['EXCHANGE'],
						type: 'string',
					},
					side: {
						description: "whether it's a buy or sell trade",
						enum: ['BUY', 'SELL'],
						type: 'string',
					},
					stop_price: {
						description: 'Stop price of the trade (only for stop-limit orders)',
						type: 'number',
					},
					tif: {
						description:
							'Time In Force (empty for Market trades, required otherwise)',
						enum: ['FOK', 'GTC', 'GTD', 'IOC'],
						type: 'string',
					},
					trade_type: {
						description: 'What type of trade is created',
						enum: ['LIMIT', 'MARKET', 'STOP', 'STOP_LIMIT'],
						type: 'string',
					},
				},
				required: [
					'device',
					'platform',
					'trade_type',
					'tif',
					'input_amount',
					'pair',
					'side',
				],
				type: 'object',
			},
			traits: {
				type: 'object',
			},
		},
		required: ['properties'],
		title: 'Trade Preview Cancelled',
		type: 'object',
	}
	const message = {
		event: 'Trade Preview Cancelled',
		properties: props || {},
		options,
	}
	validateAgainstSchema(message, schema)

	const a = analytics()
	if (a) {
		a.track(
			'Trade Preview Cancelled',
			props || {},
			withTypewriterContext(options),
			callback
		)
	}
}
/**
 * The user clicks to retry the trade being previewed. (mobile only) This happens for example when the previous submission failed few seconds earlier. The preview is typically the final screen before the trade is actually placed, just after the amount is entered.
 *
 * @param {TradePreviewRetried} props - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function tradePreviewRetried(
	props: TradePreviewRetried,
	options?: Segment.Options,
	callback?: Segment.Callback
): void {
	const schema = {
		$schema: 'http://json-schema.org/draft-07/schema#',
		description:
			'The user clicks to retry the trade being previewed. (mobile only) This happens for example when the previous submission failed few seconds earlier. The preview is typically the final screen before the trade is actually placed, just after the amount is entered.',
		labels: {
			flow: 'trade_e1',
			source: 'client',
		},
		properties: {
			context: {},
			properties: {
				properties: {
					device: {
						description: 'Device type from where the event was triggered.',
						enum: ['APP-iOS', 'APP-Android'],
						type: 'string',
					},
					failure_reason: {
						description: 'Why the previously submit trade previous failed',
						type: 'string',
					},
					input_amount: {
						description: 'Amount of the trade in input currency',
						type: 'number',
					},
					limit_price: {
						description: 'Limit price of the trade (empty for market orders)',
						type: 'number',
					},
					pair: {
						description: 'What is the trading pair of the trade',
						pattern: '^[A-Z]{3,5}-[A-Z]{3,5}$',
						type: 'string',
					},
					platform: {
						description: 'From what platform the event is triggered',
						enum: ['EXCHANGE'],
						type: 'string',
					},
					side: {
						description: "whether it's a buy or sell trade",
						enum: ['BUY', 'SELL'],
						type: 'string',
					},
					stop_price: {
						description: 'Stop price of the trade (only for stop-limit orders)',
						type: 'number',
					},
					tif: {
						description:
							'Time In Force (empty for Market trades, required otherwise)',
						enum: ['FOK', 'GTC', 'GTD', 'IOC'],
						type: 'string',
					},
					trade_type: {
						description: 'What type of trade is created',
						enum: ['LIMIT', 'MARKET', 'STOP', 'STOP_LIMIT'],
						type: 'string',
					},
				},
				required: [
					'device',
					'pair',
					'platform',
					'side',
					'trade_type',
					'tif',
					'input_amount',
				],
				type: 'object',
			},
			traits: {
				type: 'object',
			},
		},
		required: ['properties'],
		title: 'Trade Preview Retried',
		type: 'object',
	}
	const message = {
		event: 'Trade Preview Retried',
		properties: props || {},
		options,
	}
	validateAgainstSchema(message, schema)

	const a = analytics()
	if (a) {
		a.track(
			'Trade Preview Retried',
			props || {},
			withTypewriterContext(options),
			callback
		)
	}
}
/**
 * The user submits the trade being previewed. The preview is typically the final screen before the trade is actually placed, just after the amount is entered.
 *
 * @param {TradePreviewSubmitted} props - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function tradePreviewSubmitted(
	props: TradePreviewSubmitted,
	options?: Segment.Options,
	callback?: Segment.Callback
): void {
	const schema = {
		$schema: 'http://json-schema.org/draft-07/schema#',
		description:
			'The user submits the trade being previewed. The preview is typically the final screen before the trade is actually placed, just after the amount is entered.',
		labels: {
			flow: 'trade_e1',
			source: 'client',
		},
		properties: {
			context: {},
			properties: {
				properties: {
					device: {
						description: 'Device type from where the event was triggered.',
						enum: ['APP-iOS', 'WEB', 'APP-Android'],
						type: 'string',
					},
					input_amount: {
						description: 'Amount of the trade in input currency',
						type: 'number',
					},
					limit_price: {
						description: 'Limit price of the trade (empty for market orders)',
						type: 'number',
					},
					pair: {
						description: 'What is the trading pair of the trade',
						pattern: '^[A-Z]{3,5}-[A-Z]{3,5}$',
						type: 'string',
					},
					platform: {
						description: 'From what platform the event is triggered',
						enum: ['EXCHANGE'],
						type: 'string',
					},
					side: {
						description: "whether it's a buy or sell trade",
						enum: ['BUY', 'SELL'],
						type: 'string',
					},
					stop_price: {
						description: 'Stop price of the trade (only for stop-limit orders)',
						type: 'number',
					},
					tif: {
						description:
							'Time In Force (empty for Market trades, required otherwise)',
						enum: ['FOK', 'GTC', 'GTD', 'IOC'],
						type: 'string',
					},
					trade_type: {
						description: 'What type of trade is created',
						enum: ['LIMIT', 'MARKET', 'STOP', 'STOP_LIMIT'],
						type: 'string',
					},
				},
				required: [
					'device',
					'trade_type',
					'tif',
					'input_amount',
					'pair',
					'platform',
					'side',
				],
				type: 'object',
			},
			traits: {
				type: 'object',
			},
		},
		required: ['properties'],
		title: 'Trade Preview Submitted',
		type: 'object',
	}
	const message = {
		event: 'Trade Preview Submitted',
		properties: props || {},
		options,
	}
	validateAgainstSchema(message, schema)

	const a = analytics()
	if (a) {
		a.track(
			'Trade Preview Submitted',
			props || {},
			withTypewriterContext(options),
			callback
		)
	}
}
/**
 * Button which brings the user to the Trading page or screen is clicked
 *
 * @param {TradingClicked} props - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function tradingClicked(
	props: TradingClicked,
	options?: Segment.Options,
	callback?: Segment.Callback
): void {
	const schema = {
		$schema: 'http://json-schema.org/draft-07/schema#',
		description:
			'Button which brings the user to the Trading page or screen is clicked',
		labels: {
			flow: 'trade_e1',
			source: 'client',
		},
		properties: {
			context: {},
			properties: {
				properties: {
					device: {
						description: 'Device type from where the event was triggered.',
						enum: ['APP-iOS', 'WEB', 'APP-Android'],
						type: 'string',
					},
					origin: {
						description:
							'what button we are referring to. NAVIGATION (mobile only) : navigation bar. TOP_MARKETS (mobile only) : click on the trading pair in Top Markets page, HOMEPAGE (web only) : the View Exchange button. PAIR_MENU : the pair selection. When clicking on the tab on web, or on the select from dropdown on mobile\n',
						enum: ['HOMEPAGE', 'NAVIGATION', 'PAIR_MENU', 'TOP_MARKETS'],
						type: 'string',
					},
					platform: {
						description: 'What platform the user is clicking from',
						enum: ['EXCHANGE'],
						type: 'string',
					},
				},
				required: ['origin', 'device', 'platform'],
				type: 'object',
			},
			traits: {
				type: 'object',
			},
		},
		required: ['properties'],
		title: 'Trading Clicked',
		type: 'object',
	}
	const message = {
		event: 'Trading Clicked',
		properties: props || {},
		options,
	}
	validateAgainstSchema(message, schema)

	const a = analytics()
	if (a) {
		a.track(
			'Trading Clicked',
			props || {},
			withTypewriterContext(options),
			callback
		)
	}
}
/**
 * Main Trading screen or page in the exchange is viewed. This is the Exchange page with the orderbook, price chart and buy sell screen
 *
 * @param {TradingViewed} props - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function tradingViewed(
	props: TradingViewed,
	options?: Segment.Options,
	callback?: Segment.Callback
): void {
	const schema = {
		$schema: 'http://json-schema.org/draft-07/schema#',
		description:
			'Main Trading screen or page in the exchange is viewed. This is the Exchange page with the orderbook, price chart and buy sell screen',
		labels: {
			flow: 'trade_e1',
			source: 'client',
		},
		properties: {
			context: {},
			properties: {
				properties: {
					device: {
						description: 'Device type from where the event was triggered.',
						enum: ['APP-iOS', 'WEB', 'APP-Android'],
						type: 'string',
					},
					pair: {
						description: 'What trading pair is being viewed',
						pattern: '^[A-Z]{3,5}-[A-Z]{3,5}$',
						type: 'string',
					},
					path: {
						description:
							'Path portion of the URL of the page. Equivalent to canonical path which defaults to location.pathname from the DOM API.',
						type: 'string',
					},
					platform: {
						description: 'What platform the page viewed belongs to',
						enum: ['EXCHANGE'],
						type: 'string',
					},
					referrer: {
						description:
							'Full URL of the previous page. Equivalent to document.referrer from the DOM API.',
						type: 'string',
					},
					search: {
						description:
							'Query string portion of the URL of the page. Equivalent to location.search from the DOM API.',
						type: 'string',
					},
					title: {
						description:
							'Title of the page. Equivalent to document.title from the DOM API.',
						type: 'string',
					},
					url: {
						description:
							'Full URL of the page. First we look for the canonical url. If the canonical url is not provided, we use location.href from the DOM API.',
						type: 'string',
					},
				},
				required: ['platform', 'device', 'pair'],
				type: 'object',
			},
			traits: {
				type: 'object',
			},
		},
		required: ['properties'],
		title: 'Trading Viewed',
		type: 'object',
	}
	const message = {
		event: 'Trading Viewed',
		properties: props || {},
		options,
	}
	validateAgainstSchema(message, schema)

	const a = analytics()
	if (a) {
		a.track(
			'Trading Viewed',
			props || {},
			withTypewriterContext(options),
			callback
		)
	}
}
/**
 * Two-Step Verification turned off by user request.
 *
 * @param {TwoStepVerificationDisabled} props - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function twoStepVerificationDisabled(
	props: TwoStepVerificationDisabled,
	options?: Segment.Options,
	callback?: Segment.Callback
): void {
	const schema = {
		$schema: 'http://json-schema.org/draft-07/schema#',
		description: 'Two-Step Verification turned off by user request.',
		labels: {
			flow: 'security_v1',
			source: 'backend',
		},
		properties: {
			context: {},
			properties: {
				properties: {
					device: {
						description: 'Device type from where the event was triggered.',
						enum: ['APP-Android', 'APP-iOS', 'WEB'],
						type: 'string',
					},
					platform: {
						description:
							'From what platform the user is managing Security events',
						enum: ['EXCHANGE', 'WALLET'],
						type: 'string',
					},
					two_step_option: {
						description:
							'Which was the verification option activated before the user disabled two-step security? Authenticator App, Yubikey or Mobile Number',
						enum: ['AUTHENTICATOR_APP', 'MOBILE_NUMBER', 'YUBIKEY'],
						type: 'string',
					},
				},
				required: ['platform', 'two_step_option'],
				type: 'object',
			},
			traits: {
				type: 'object',
			},
		},
		required: ['properties'],
		title: 'Two Step Verification Disabled',
		type: 'object',
	}
	const message = {
		event: 'Two Step Verification Disabled',
		properties: props || {},
		options,
	}
	validateAgainstSchema(message, schema)

	const a = analytics()
	if (a) {
		a.track(
			'Two Step Verification Disabled',
			props || {},
			withTypewriterContext(options),
			callback
		)
	}
}
/**
 * Two-Step Verification succesfully activated.
 *
 * @param {TwoStepVerificationEnabled} props - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function twoStepVerificationEnabled(
	props: TwoStepVerificationEnabled,
	options?: Segment.Options,
	callback?: Segment.Callback
): void {
	const schema = {
		$schema: 'http://json-schema.org/draft-07/schema#',
		description: 'Two-Step Verification succesfully activated.',
		labels: {
			flow: 'security_v1',
			source: 'backend',
		},
		properties: {
			context: {},
			properties: {
				properties: {
					device: {
						description: 'Device type from where the event was triggered.',
						enum: ['APP-iOS', 'WEB', 'APP-Android'],
						type: 'string',
					},
					platform: {
						description:
							'From what platform the user is managing Security events',
						enum: ['EXCHANGE', 'WALLET'],
						type: 'string',
					},
					two_step_option: {
						description:
							'Which verification option was activated? Authenticator App, Yubikey or Mobile Number',
						enum: ['AUTHENTICATOR_APP', 'MOBILE_NUMBER', 'YUBIKEY'],
						type: 'string',
					},
				},
				required: ['platform', 'two_step_option'],
				type: 'object',
			},
			traits: {
				type: 'object',
			},
		},
		required: ['properties'],
		title: 'Two Step Verification Enabled',
		type: 'object',
	}
	const message = {
		event: 'Two Step Verification Enabled',
		properties: props || {},
		options,
	}
	validateAgainstSchema(message, schema)

	const a = analytics()
	if (a) {
		a.track(
			'Two Step Verification Enabled',
			props || {},
			withTypewriterContext(options),
			callback
		)
	}
}
/**
 * The user clicks the preferred Two-Step security option
 *
 * @param {TwoStepVerificationOptionClicked} props - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function twoStepVerificationOptionClicked(
	props: TwoStepVerificationOptionClicked,
	options?: Segment.Options,
	callback?: Segment.Callback
): void {
	const schema = {
		$schema: 'http://json-schema.org/draft-07/schema#',
		description: 'The user clicks the preferred Two-Step security option',
		labels: {
			flow: 'security_v1',
			source: 'client',
		},
		properties: {
			context: {},
			properties: {
				properties: {
					device: {
						description: 'Device type from where the event was triggered.',
						enum: ['APP-Android', 'WEB'],
						type: 'string',
					},
					platform: {
						description:
							'From what platform the user is managing Security events',
						enum: ['EXCHANGE', 'WALLET'],
						type: 'string',
					},
					two_step_option: {
						description: 'Authenticator App, Yubikey or Mobile Number',
						enum: ['AUTHENTICATOR_APP', 'MOBILE_NUMBER', 'YUBIKEY'],
						type: 'string',
					},
				},
				required: ['platform', 'two_step_option', 'device'],
				type: 'object',
			},
			traits: {
				type: 'object',
			},
		},
		required: ['properties'],
		title: 'Two Step Verification Option Clicked',
		type: 'object',
	}
	const message = {
		event: 'Two Step Verification Option Clicked',
		properties: props || {},
		options,
	}
	validateAgainstSchema(message, schema)

	const a = analytics()
	if (a) {
		a.track(
			'Two Step Verification Option Clicked',
			props || {},
			withTypewriterContext(options),
			callback
		)
	}
}
/**
 * The user clicks on a widget or CTA inviting the user to upgrade their tier status.
 *
 * @param {UpgradeVerificationClicked} [props] - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function upgradeVerificationClicked(
	props?: UpgradeVerificationClicked,
	options?: Segment.Options,
	callback?: Segment.Callback
): void {
	const schema = {
		$schema: 'http://json-schema.org/draft-07/schema#',
		description:
			'The user clicks on a widget or CTA inviting the user to upgrade their tier status.',
		labels: {
			flow: ['onboarding_v1', 'swap_v1', 'settings_v1', 'onboarding_e1'],
			source: 'client',
		},
		properties: {
			context: {},
			properties: {
				properties: {
					'': {
						description: '',
						type: 'object',
					},
					device: {
						description: 'Device type from where the event was triggered.',
						enum: ['APP-iOS', 'WEB', 'APP-Android'],
						type: 'string',
					},
					origin: {
						description:
							'From what screen or action the user started the verification. What button we are referring to. \nAIRDROP: . \nDASHBOARD_PROMO : announcement card or promo on dashboard. EDD : when an upgrade is required because an Enhanced Due Diligence required for a high risk user. DEPOSIT : when depositing funds requires upgrading.\nFIAT_FUNDS : when trying to deposit fiat. ONBOARDING : during a usual onboarding process.\nRESUBMISSION : navigation bar.\nSAVINGS (web only) : comes from interest savings product. \nSETTINGS: settings page. SIGN_UP : gold verification prompted at sign up upon account creation.  \nSIMPLEBUY : from buy or sell product. SIMPLETRADE : from Simple Trade product in exchange.\nSWAP: swap product. UNKNOWN : where origin could not be match to a product or other enums, or is hard to get',
						enum: [
							'AIRDROP',
							'DASHBOARD_PROMO',
							'DEPOSIT',
							'EDD',
							'FIAT_FUNDS',
							'INTEREST',
							'MARGIN',
							'ONBOARDING',
							'PEEKSHEET',
							'RESUBMISSION',
							'SAVINGS',
							'SETTINGS',
							'SIGN_UP',
							'SIMPLEBUY',
							'SIMPLETRADE',
							'SWAP',
							'UNKNOWN',
							'WITHDRAW',
						],
						type: 'string',
					},
					platform: {
						description:
							'What platform the Upgrade Verification was clicked from',
						enum: ['EXCHANGE', 'WALLET'],
						type: 'string',
					},
					tier: {
						description:
							'What tier the user is trying to update to. 1 = Silver, 2 = Gold, 3 = SDD + silver, 5 = Platinium',
						type: ['integer', 'null'],
					},
				},
				required: ['origin', 'tier', 'device', 'platform'],
				type: 'object',
			},
			traits: {
				type: 'object',
			},
		},
		title: 'Upgrade Verification Clicked',
		type: 'object',
	}
	const message = {
		event: 'Upgrade Verification Clicked',
		properties: props || {},
		options,
	}
	validateAgainstSchema(message, schema)

	const a = analytics()
	if (a) {
		a.track(
			'Upgrade Verification Clicked',
			props || {},
			withTypewriterContext(options),
			callback
		)
	}
}
/**
 * User eligible to use the product. More information on Simple Eligibility Nabu wiki
 *
 * @param {UserProductEligible} props - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function userProductEligible(
	props: UserProductEligible,
	options?: Segment.Options,
	callback?: Segment.Callback
): void {
	const schema = {
		$schema: 'http://json-schema.org/draft-07/schema#',
		description:
			'User eligible to use the product. More information on Simple Eligibility Nabu wiki',
		labels: {
			flow: ['simplebuy_v1', 'swap_v1'],
			source: 'backend',
		},
		properties: {
			context: {},
			properties: {
				properties: {
					currency: {
						description:
							'Used to check blocked regions and enabled currencies. (e.g. EUR)',
						pattern: '^[A-Z]{3,5}$',
						type: ['string', 'null'],
					},
					product: {
						description: 'Product name that the eligibility is checked for',
						enum: ['SAVINGS', 'SIMPLEBUY', 'SWAP'],
						type: 'string',
					},
				},
				required: ['product', 'currency'],
				type: 'object',
			},
			traits: {
				type: 'object',
			},
		},
		required: ['properties'],
		title: 'User Product Eligible',
		type: 'object',
	}
	const message = {
		event: 'User Product Eligible',
		properties: props || {},
		options,
	}
	validateAgainstSchema(message, schema)

	const a = analytics()
	if (a) {
		a.track(
			'User Product Eligible',
			props || {},
			withTypewriterContext(options),
			callback
		)
	}
}
/**
 * User not eligible to use the product. More information on Simple Eligibility Nabu wiki
 *
 * @param {UserProductNotEligible} props - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function userProductNotEligible(
	props: UserProductNotEligible,
	options?: Segment.Options,
	callback?: Segment.Callback
): void {
	const schema = {
		$schema: 'http://json-schema.org/draft-07/schema#',
		description:
			'User not eligible to use the product. More information on Simple Eligibility Nabu wiki',
		labels: {
			flow: ['simplebuy_v1', 'swap_v1'],
			source: 'backend',
		},
		properties: {
			context: {},
			properties: {
				properties: {
					currency: {
						description:
							'Used to check blocked regions and enabled currencies. (e.g. EUR)',
						pattern: '^[A-Z]{3,5}$',
						type: ['string', 'null'],
					},
					ineligibility_reason: {
						description: 'Reason for the inelegibility',
						enum: [
							'INVALID_ADDRESS',
							'INVALID_USER',
							'TIER_TOO_LOW',
							'UNSUPPORTED_CURRENCY',
							'UNSUPPORTED_REGION',
						],
						type: 'string',
					},
					platform: {
						description:
							'What platform the event was started from. (WALLET for wallet products nd EXCHANGE if product=MERCURY',
						enum: [' WALLET', 'EXCHANGE'],
						type: 'string',
					},
					product: {
						description: 'Product name that the eligibility is checked for',
						enum: ['SAVINGS', 'SIMPLEBUY', 'SWAP'],
						type: 'string',
					},
				},
				required: ['currency', 'platform', 'product', 'ineligibility_reason'],
				type: 'object',
			},
			traits: {
				type: 'object',
			},
		},
		required: ['properties'],
		title: 'User Product Not Eligible',
		type: 'object',
	}
	const message = {
		event: 'User Product Not Eligible',
		properties: props || {},
		options,
	}
	validateAgainstSchema(message, schema)

	const a = analytics()
	if (a) {
		a.track(
			'User Product Not Eligible',
			props || {},
			withTypewriterContext(options),
			callback
		)
	}
}
/**
 * User eligible to start the SDD (tier 3) verification process. More info on SDD-API Nabu wiki
 *
 * @param {Record<string, any>} [props] - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function userSddEligible(
	props?: Record<string, any>,
	options?: Segment.Options,
	callback?: Segment.Callback
): void {
	const schema = {
		$schema: 'http://json-schema.org/draft-07/schema#',
		description:
			'User eligible to start the SDD (tier 3) verification process. More info on SDD-API Nabu wiki',
		labels: {
			flow: 'simplebuy_v1',
			source: 'backend',
		},
		properties: {
			context: {},
			properties: {
				type: 'object',
			},
			traits: {
				type: 'object',
			},
		},
		title: 'User SDD Eligible',
		type: 'object',
	}
	const message = {
		event: 'User SDD Eligible',
		properties: props || {},
		options,
	}
	validateAgainstSchema(message, schema)

	const a = analytics()
	if (a) {
		a.track(
			'User SDD Eligible',
			props || {},
			withTypewriterContext(options),
			callback
		)
	}
}
/**
 * User not eligible to start the SDD (tier 3) verification process. User will be prompted for Gold verification instead in the wallet. More info on SDD-API Nabu wiki
 *
 * @param {UserSddNotEligible} props - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function userSddNotEligible(
	props: UserSddNotEligible,
	options?: Segment.Options,
	callback?: Segment.Callback
): void {
	const schema = {
		$schema: 'http://json-schema.org/draft-07/schema#',
		description:
			'User not eligible to start the SDD (tier 3) verification process. User will be prompted for Gold verification instead in the wallet. More info on SDD-API Nabu wiki',
		labels: {
			flow: 'simplebuy_v1',
			source: 'backend',
		},
		properties: {
			context: {},
			properties: {
				properties: {
					ineligibility_reason: {
						description: 'Reason for the inelegibility',
						enum: ['BLOCKED', 'KYC_TIER', 'REGION'],
						type: 'string',
					},
				},
				required: ['ineligibility_reason'],
				type: 'object',
			},
			traits: {
				type: 'object',
			},
		},
		required: ['properties'],
		title: 'User SDD Not Eligible',
		type: 'object',
	}
	const message = {
		event: 'User SDD Not Eligible',
		properties: props || {},
		options,
	}
	validateAgainstSchema(message, schema)

	const a = analytics()
	if (a) {
		a.track(
			'User SDD Not Eligible',
			props || {},
			withTypewriterContext(options),
			callback
		)
	}
}
/**
 * The user submits the Authenticator App code, Yubikey code or SMS code in order to finish set up their two step verification
 *
 * @param {VerificationCodeSubmitted} props - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function verificationCodeSubmitted(
	props: VerificationCodeSubmitted,
	options?: Segment.Options,
	callback?: Segment.Callback
): void {
	const schema = {
		$schema: 'http://json-schema.org/draft-07/schema#',
		description:
			'The user submits the Authenticator App code, Yubikey code or SMS code in order to finish set up their two step verification',
		labels: {
			flow: 'security_v1',
			source: 'client',
		},
		properties: {
			context: {},
			properties: {
				properties: {
					device: {
						description: 'Device type from where the event was triggered.',
						enum: ['APP-iOS', 'WEB', 'APP-Android'],
						type: 'string',
					},
					platform: {
						description:
							'From what platform the user is managing Security events',
						enum: ['EXCHANGE', 'WALLET'],
						type: 'string',
					},
					two_step_option: {
						description: 'Authenticator App, Yubikey or Mobile Number',
						enum: ['AUTHENTICATOR_APP', 'MOBILE_NUMBER', 'YUBIKEY'],
						type: 'string',
					},
				},
				required: ['two_step_option', 'device', 'platform'],
				type: 'object',
			},
			traits: {
				type: 'object',
			},
		},
		required: ['properties'],
		title: 'Verification Code Submitted',
		type: 'object',
	}
	const message = {
		event: 'Verification Code Submitted',
		properties: props || {},
		options,
	}
	validateAgainstSchema(message, schema)

	const a = analytics()
	if (a) {
		a.track(
			'Verification Code Submitted',
			props || {},
			withTypewriterContext(options),
			callback
		)
	}
}
/**
 * An identify verification has been performed, which typically means that some PII or documents have been submitted and validated by the provider.
 *
 * @param {VerificationCompleted} props - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function verificationCompleted(
	props: VerificationCompleted,
	options?: Segment.Options,
	callback?: Segment.Callback
): void {
	const schema = {
		$schema: 'http://json-schema.org/draft-07/schema#',
		description:
			'An identify verification has been performed, which typically means that some PII or documents have been submitted and validated by the provider.',
		labels: {
			flow: ['onboarding_v1', 'settings_v1', 'onboarding_e1'],
			source: 'backend',
		},
		properties: {
			context: {},
			properties: {
				properties: {
					platform: {
						description:
							'What platform the verification was started from. (WALLET if product=SWAP and EXCHANGE if product=MERCURY in the  kyc verification table from nabu gateway)',
						enum: ['EXCHANGE', 'WALLET'],
						type: 'string',
					},
					provider: {
						description:
							'what entity is performing the verification. Typically BLOCKCHAIN or VERIFF',
						enum: [
							'BLOCKCHAIN',
							'MANUAL',
							'ONFIDO',
							'RDC',
							'RDC_MEDIA',
							'RDC_PEP',
							'VERIFF',
						],
						type: 'string',
					},
					tier: {
						description:
							'The tier the verification is about. 1 (Silver) or 2 (Gold) or 3 (SDD)  ',
						type: 'integer',
					},
				},
				required: ['tier', 'platform', 'provider'],
				type: 'object',
			},
			traits: {
				type: 'object',
			},
		},
		required: ['properties'],
		title: 'Verification Completed',
		type: 'object',
	}
	const message = {
		event: 'Verification Completed',
		properties: props || {},
		options,
	}
	validateAgainstSchema(message, schema)

	const a = analytics()
	if (a) {
		a.track(
			'Verification Completed',
			props || {},
			withTypewriterContext(options),
			callback
		)
	}
}
/**
 * An identify verification has been rejected, which typically means that some PII or documents have been submitted but were not suitable.
 *
 * @param {VerificationRejected} props - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function verificationRejected(
	props: VerificationRejected,
	options?: Segment.Options,
	callback?: Segment.Callback
): void {
	const schema = {
		$schema: 'http://json-schema.org/draft-07/schema#',
		description:
			'An identify verification has been rejected, which typically means that some PII or documents have been submitted but were not suitable.',
		labels: {
			flow: ['onboarding_v1', 'settings_v1', 'onboarding_e1'],
			source: 'backend',
		},
		properties: {
			context: {},
			properties: {
				properties: {
					platform: {
						description:
							'What platform the verification was started from. (WALLET if product=SWAP and EXCHANGE if product=MERCURY in the  kyc verification table from nabu gateway)',
						enum: ['EXCHANGE', 'WALLET'],
						type: 'string',
					},
					provider: {
						description: 'The entity that verifies the identity',
						enum: [
							'BLOCKCHAIN',
							'MANUAL',
							'ONFIDO',
							'RDC',
							'RDC_MEDIA',
							'RDC_PEP',
							'VERIFF',
						],
						type: 'string',
					},
					tier: {
						description:
							'The tier the verification is about. 1 (Silver) or 2 (Gold) or 3 (SDD)  ',
						type: 'integer',
					},
				},
				required: ['tier', 'provider', 'platform'],
				type: 'object',
			},
			traits: {
				type: 'object',
			},
		},
		required: ['properties'],
		title: 'Verification Rejected',
		type: 'object',
	}
	const message = {
		event: 'Verification Rejected',
		properties: props || {},
		options,
	}
	validateAgainstSchema(message, schema)

	const a = analytics()
	if (a) {
		a.track(
			'Verification Rejected',
			props || {},
			withTypewriterContext(options),
			callback
		)
	}
}
/**
 * An identify verification has been started : only available for Tier 2 gold. A user is trying to upgrade their verification tier, and is about to send documents or informations. Tier 1 and Tier 3 verification are only in Verification Completed event
 *
 * @param {VerificationStarted} props - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function verificationStarted(
	props: VerificationStarted,
	options?: Segment.Options,
	callback?: Segment.Callback
): void {
	const schema = {
		$schema: 'http://json-schema.org/draft-07/schema#',
		description:
			'An identify verification has been started : only available for Tier 2 gold. A user is trying to upgrade their verification tier, and is about to send documents or informations. Tier 1 and Tier 3 verification are only in Verification Completed event',
		labels: {
			flow: ['onboarding_v1', 'settings_v1', 'onboarding_e1'],
			source: 'backend',
		},
		properties: {
			context: {},
			properties: {
				properties: {
					platform: {
						description:
							'What platform the verification was started from. (WALLET if product=SWAP and EXCHANGE if product=MERCURY in the  kyc verification table from nabu gateway)',
						enum: ['EXCHANGE', 'WALLET'],
						type: 'string',
					},
					provider: {
						description: 'The entity that verifies the identity',
						enum: [
							'BLOCKCHAIN',
							'ONFIDO',
							'RDC',
							'RDC_MANUAL',
							'RDC_MEDIA',
							'RDC_PEP',
							'VERIFF',
						],
						type: 'string',
					},
					tier: {
						description:
							'Only available for tier 2 (Gold). Missing for tier 1 (Silver) and 3 (SDD)',
						type: 'integer',
					},
				},
				required: ['platform', 'tier'],
				type: 'object',
			},
			traits: {
				type: 'object',
			},
		},
		required: ['properties'],
		title: 'Verification Started',
		type: 'object',
	}
	const message = {
		event: 'Verification Started',
		properties: props || {},
		options,
	}
	validateAgainstSchema(message, schema)

	const a = analytics()
	if (a) {
		a.track(
			'Verification Started',
			props || {},
			withTypewriterContext(options),
			callback
		)
	}
}
/**
 * An identify verification submission, like video upload, was attempted but a failure happened
 *
 * @param {VerificationSubmissionFailed} props - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function verificationSubmissionFailed(
	props: VerificationSubmissionFailed,
	options?: Segment.Options,
	callback?: Segment.Callback
): void {
	const schema = {
		$schema: 'http://json-schema.org/draft-07/schema#',
		description:
			'An identify verification submission, like video upload, was attempted but a failure happened',
		labels: {
			flow: 'onboarding_v1',
			source: 'client',
		},
		properties: {
			context: {},
			properties: {
				properties: {
					device: {
						description:
							'what device the verification submission was sent from',
						enum: ['APP-Android', 'APP-iOS', 'WEB'],
						type: 'string',
					},
					failure_reason: {
						description: 'why the verification submission failed',
						enum: [
							'LOCAL_ERROR',
							'NETWORK_ERROR',
							'SERVER_ERROR',
							'UNKNOWN',
							'UPLOAD_ERROR',
							'VIDEO_FAILED',
						],
						type: 'string',
					},
					platform: {
						description:
							'What platform the verification was started from. (WALLET if product=SWAP and EXCHANGE if product=MERCURY in the  kyc verification table from nabu gateway)',
						enum: ['EXCHANGE', 'WALLET'],
						type: 'string',
					},
					provider: {
						description: 'The entity that verifies the identity',
						enum: [
							'BLOCKCHAIN',
							'MANUAL',
							'ONFIDO',
							'RDC',
							'RDC_MEDIA',
							'RDC_PEP',
							'VERIFF',
						],
						type: 'string',
					},
					tier: {
						description:
							'The tier the verification is about. 1 (Silver) or 2 (Gold) or 3 (SDD)  ',
						type: 'integer',
					},
				},
				required: ['tier', 'provider', 'platform', 'device', 'failure_reason'],
				type: 'object',
			},
			traits: {
				type: 'object',
			},
		},
		required: ['properties'],
		title: 'Verification Submission Failed',
		type: 'object',
	}
	const message = {
		event: 'Verification Submission Failed',
		properties: props || {},
		options,
	}
	validateAgainstSchema(message, schema)

	const a = analytics()
	if (a) {
		a.track(
			'Verification Submission Failed',
			props || {},
			withTypewriterContext(options),
			callback
		)
	}
}
/**
 * Allowing the following option prevents IP addresses that are known to be part of the Tor anonymizing network from accessing your wallet.
 *
 * @param {WalletAccessViaTorUpdated} props - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function walletAccessViaTorUpdated(
	props: WalletAccessViaTorUpdated,
	options?: Segment.Options,
	callback?: Segment.Callback
): void {
	const schema = {
		$schema: 'http://json-schema.org/draft-07/schema#',
		description:
			'Allowing the following option prevents IP addresses that are known to be part of the Tor anonymizing network from accessing your wallet.',
		labels: {
			flow: 'security_v1',
			source: 'backend',
		},
		properties: {
			context: {},
			properties: {
				properties: {
					device: {
						description: 'Device type from where the event was triggered.',
						enum: ['APP-iOS', 'WEB', 'APP-Android'],
						type: 'string',
					},
					is_blocked: {
						description: 'True if user only allowed login from IP whitelist.',
						type: 'boolean',
					},
					platform: {
						description:
							'From what platform the user is managing Security events\n',
						enum: ['EXCHANGE', 'WALLET'],
						type: 'string',
					},
				},
				required: ['platform', 'is_blocked'],
				type: 'object',
			},
			traits: {
				type: 'object',
			},
		},
		required: ['properties'],
		title: 'Wallet Access Via Tor Updated',
		type: 'object',
	}
	const message = {
		event: 'Wallet Access Via Tor Updated',
		properties: props || {},
		options,
	}
	validateAgainstSchema(message, schema)

	const a = analytics()
	if (a) {
		a.track(
			'Wallet Access Via Tor Updated',
			props || {},
			withTypewriterContext(options),
			callback
		)
	}
}
/**
 * A button inviting the user to discover our Wallet product is clicked.  Note that this does not include the navigation part of the header.
 *
 * @param {WalletHyperlinkClicked} props - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function walletHyperlinkClicked(
	props: WalletHyperlinkClicked,
	options?: Segment.Options,
	callback?: Segment.Callback
): void {
	const schema = {
		$schema: 'http://json-schema.org/draft-07/schema#',
		description:
			'A button inviting the user to discover our Wallet product is clicked.  Note that this does not include the navigation part of the header.',
		labels: {
			flow: ['explorer', 'dot_com'],
			source: 'client',
		},
		properties: {
			context: {},
			properties: {
				properties: {
					'': {
						description: '',
						type: 'object',
					},
					device: {
						description: 'What device the event is tracked from',
						enum: ['WEB'],
						type: 'string',
					},
					origin: {
						description: 'From which part of the page was the button clicked',
						enum: ['BODY', 'LOWER_BANNER', 'BANNER'],
						type: 'string',
					},
					platform: {
						description: 'What platform the event is referring to.',
						enum: ['BLOCKCHAIN_COM', 'EXPLORER'],
						type: 'string',
					},
					platform_path: {
						description:
							'Path portion of the URL of the page from where the button is clicked.\n  PRICES: from the explorer general price page with all the coins listed. \n PRICES_CURRENCY : blockchain.com/prices/[currency] : from the explorer price page about a specific crypto. .COM_WALLET :\nblockchain.com/wallet. EXPLORER : https://www.blockchain.com/explorer',
						enum: [' PRICES_CURRENCY', '.COM_WALLET', 'EXPLORER', 'PRICES'],
						type: 'string',
					},
				},
				required: ['device', 'platform'],
				type: 'object',
			},
			traits: {
				type: 'object',
			},
		},
		required: ['properties'],
		title: 'Wallet Hyperlink Clicked',
		type: 'object',
	}
	const message = {
		event: 'Wallet Hyperlink Clicked',
		properties: props || {},
		options,
	}
	validateAgainstSchema(message, schema)

	const a = analytics()
	if (a) {
		a.track(
			'Wallet Hyperlink Clicked',
			props || {},
			withTypewriterContext(options),
			callback
		)
	}
}
/**
 * A user signs up for a Wallet account. Note that this is different from Signed Up which is triggered when a nabu user profile is created. A wallet without a nabu user will be seen as an Anonymous User
 *
 * @param {WalletSignedUp} props - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function walletSignedUp(
	props: WalletSignedUp,
	options?: Segment.Options,
	callback?: Segment.Callback
): void {
	const schema = {
		$schema: 'http://json-schema.org/draft-07/schema#',
		description:
			'A user signs up for a Wallet account. Note that this is different from Signed Up which is triggered when a nabu user profile is created. A wallet without a nabu user will be seen as an Anonymous User',
		labels: {
			flow: 'sign_up',
			source: 'client',
		},
		properties: {
			context: {},
			properties: {
				properties: {
					country: {
						description:
							'Country, as iso code alpha 2, provided by the user at sign up',
						pattern: '^[A-Z]{2,2}$',
						type: 'string',
					},
					country_state: {
						description:
							'If applicable, country state, as ISO 3166-2 (US-NY for example),  provided by the user at sign up',
						pattern: '^[A-Z]{2,2}-[A-Z]{2,2}$',
						type: 'string',
					},
					device: {
						description: 'What device the user created a wallet from',
						enum: ['APP-Android', 'APP-iOS', 'WEB'],
						type: 'string',
					},
					platform: {
						description:
							'What platform the user is creating his wallet account from.',
						enum: ['WALLET'],
						type: 'string',
					},
				},
				required: ['platform', 'device'],
				type: 'object',
			},
			traits: {
				type: 'object',
			},
		},
		required: ['properties'],
		title: 'Wallet Signed Up',
		type: 'object',
	}
	const message = {
		event: 'Wallet Signed Up',
		properties: props || {},
		options,
	}
	validateAgainstSchema(message, schema)

	const a = analytics()
	if (a) {
		a.track(
			'Wallet Signed Up',
			props || {},
			withTypewriterContext(options),
			callback
		)
	}
}
/**
 * The user selects and submits the amount to be withdrawn. Note: On the web wallet, this is the final step and the user does not have to confirm at a later stage. For the mobile app and web wallet, the user will still have to confirm at a later stage for the withdraw order to be created.
 *
 * @param {WithdrawalAmountEntered} props - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function withdrawalAmountEntered(
	props: WithdrawalAmountEntered,
	options?: Segment.Options,
	callback?: Segment.Callback
): void {
	const schema = {
		$schema: 'http://json-schema.org/draft-07/schema#',
		description:
			'The user selects and submits the amount to be withdrawn. Note: On the web wallet, this is the final step and the user does not have to confirm at a later stage. For the mobile app and web wallet, the user will still have to confirm at a later stage for the withdraw order to be created.',
		labels: {
			flow: ['withdraw_v1', 'trade_e1'],
			source: 'client',
		},
		properties: {
			context: {},
			properties: {
				properties: {
					amount: {
						description:
							'The amount the user will withdraw (before fee applies)',
						type: 'number',
					},
					currency: {
						description: 'the currency the user wants to withdraw',
						pattern: '^[A-Z]{3,5}$',
						type: 'string',
					},
					device: {
						description: 'Device type from where the event was triggered.',
						enum: ['APP-iOS', 'WEB', 'APP-Android'],
						type: 'string',
					},
					platform: {
						description: 'What platform the user is withdraw funds from',
						enum: ['EXCHANGE', 'WALLET'],
						type: 'string',
					},
					withdrawal_method: {
						description:
							'How the funds will be withdrawn : \nBANK_ACCOUNT: funds sent to a bank account. \nBANK_TRANSFER : Funds sent to Linked account via Open Banking or ACH. CRYPTO : withdrawing to a crypto address',
						enum: ['BANK_ACCOUNT', 'BANK_TRANSFER', 'CRYPTO'],
						type: 'string',
					},
				},
				required: [
					'device',
					'currency',
					'withdrawal_method',
					'amount',
					'platform',
				],
				type: 'object',
			},
			traits: {
				type: 'object',
			},
		},
		required: ['properties'],
		title: 'Withdrawal Amount Entered',
		type: 'object',
	}
	const message = {
		event: 'Withdrawal Amount Entered',
		properties: props || {},
		options,
	}
	validateAgainstSchema(message, schema)

	const a = analytics()
	if (a) {
		a.track(
			'Withdrawal Amount Entered',
			props || {},
			withTypewriterContext(options),
			callback
		)
	}
}
/**
 * The user clicked on the widget or button which sets pre selected amounts to the withdrawal. Not available on Exchange Web at the moment.
 *
 * @param {WithdrawalAmountHelperClicked} props - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function withdrawalAmountHelperClicked(
	props: WithdrawalAmountHelperClicked,
	options?: Segment.Options,
	callback?: Segment.Callback
): void {
	const schema = {
		$schema: 'http://json-schema.org/draft-07/schema#',
		description:
			'The user clicked on the widget or button which sets pre selected amounts to the withdrawal. Not available on Exchange Web at the moment.',
		labels: {
			flow: 'trade_e1',
			source: 'client',
		},
		properties: {
			context: {},
			properties: {
				properties: {
					amount_currency: {
						description:
							'If the button explicitly displays the amount in a specific currency, what is the currency being clicked on for the max amount',
						type: 'number',
					},
					amount_pct: {
						description:
							'What amount percentage the user clicks on (either amount or amount_pct should be specified) Enter 25 if 25% selected',
						type: 'integer',
					},
					currency: {
						description: 'the currency the user wants to withdraw',
						pattern: '^[A-Z]{3,5}-[A-Z]{3,5}$',
						type: 'string',
					},
					device: {
						description: 'Device type from where the event was triggered.',
						enum: ['APP-iOS', 'WEB', 'APP-Android'],
						type: 'string',
					},
					platform: {
						description: 'From what platform the amount is triggered',
						enum: ['EXCHANGE'],
						type: 'string',
					},
					withdrawal_method: {
						description:
							'How the funds will be withdrawn : \nBANK_ACCOUNT: funds sent to a bank account. \nBANK_TRANSFER : Funds sent to Linked account via Open Banking or ACH. CRYPTO : withdrawing to a crypto address',
						enum: ['BANK_ACCOUNT', 'BANK_TRANSFER', 'CRYPTO'],
						type: 'string',
					},
				},
				required: [
					'withdrawal_method',
					'amount_pct',
					'device',
					'platform',
					'currency',
				],
				type: 'object',
			},
			traits: {
				type: 'object',
			},
		},
		required: ['properties'],
		title: 'Withdrawal Amount Helper Clicked',
		type: 'object',
	}
	const message = {
		event: 'Withdrawal Amount Helper Clicked',
		properties: props || {},
		options,
	}
	validateAgainstSchema(message, schema)

	const a = analytics()
	if (a) {
		a.track(
			'Withdrawal Amount Helper Clicked',
			props || {},
			withTypewriterContext(options),
			callback
		)
	}
}
/**
 * The user clicked on the widget or button which sets the max amount allowed to withdraw
 *
 * @param {WithdrawalAmountMaxClicked} props - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function withdrawalAmountMaxClicked(
	props: WithdrawalAmountMaxClicked,
	options?: Segment.Options,
	callback?: Segment.Callback
): void {
	const schema = {
		$schema: 'http://json-schema.org/draft-07/schema#',
		description:
			'The user clicked on the widget or button which sets the max amount allowed to withdraw',
		labels: {
			flow: 'withdraw_v1',
			source: 'client',
		},
		properties: {
			context: {},
			properties: {
				properties: {
					amount_currency: {
						description:
							'If the button explicitly displays the amount in a specific currency, what is the currency being clicked on for the max amount',
						type: 'number',
					},
					currency: {
						description: 'the currency the user wants to withdraw',
						pattern: '^[A-Z]{3,5}$',
						type: 'string',
					},
					device: {
						description: 'Device type from where the event was triggered.',
						enum: ['APP-iOS', 'WEB', 'APP-Android'],
						type: 'string',
					},
					platform: {
						description: 'What platform the user is withdraw funds from',
						enum: ['EXCHANGE', 'WALLET'],
						type: 'string',
					},
					withdrawal_method: {
						description:
							'How the funds will be withdrawn : \nBANK_ACCOUNT: funds sent to a bank account. \nBANK_TRANSFER : Funds sent to Linked account via Open Banking or ACH. ',
						enum: ['BANK_ACCOUNT', 'BANK_TRANSFER'],
						type: 'string',
					},
				},
				required: ['currency', 'withdrawal_method', 'platform', 'device'],
				type: 'object',
			},
			traits: {
				type: 'object',
			},
		},
		required: ['properties'],
		title: 'Withdrawal Amount Max Clicked',
		type: 'object',
	}
	const message = {
		event: 'Withdrawal Amount Max Clicked',
		properties: props || {},
		options,
	}
	validateAgainstSchema(message, schema)

	const a = analytics()
	if (a) {
		a.track(
			'Withdrawal Amount Max Clicked',
			props || {},
			withTypewriterContext(options),
			callback
		)
	}
}
/**
 * The user clicked on the widget or button which sets the min amount allowed to withdraw
 *
 * @param {WithdrawalAmountMinClicked} props - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function withdrawalAmountMinClicked(
	props: WithdrawalAmountMinClicked,
	options?: Segment.Options,
	callback?: Segment.Callback
): void {
	const schema = {
		$schema: 'http://json-schema.org/draft-07/schema#',
		description:
			'The user clicked on the widget or button which sets the min amount allowed to withdraw',
		labels: {
			flow: 'withdraw_v1',
			source: 'client',
		},
		properties: {
			context: {},
			properties: {
				properties: {
					amount_currency: {
						description:
							'If the button explicitly displays the amount in a specific currency, what is the currency being clicked on for the max amount',
						pattern: '^[A-Z]{3,5}$',
						type: 'string',
					},
					currency: {
						description: 'the currency the user wants to withdraw',
						pattern: '^[A-Z]{3,5}$',
						type: 'string',
					},
					device: {
						description: 'Device type from where the event was triggered.',
						enum: ['APP-iOS', 'WEB', 'APP-Android'],
						type: 'string',
					},
					platform: {
						description: 'What platform the user is withdraw funds from',
						enum: ['EXCHANGE', 'WALLET'],
						type: 'string',
					},
					withdrawal_method: {
						description:
							'How the funds will be withdrawn : \nBANK_ACCOUNT: funds sent to a bank account. \nBANK_TRANSFER : Funds sent to Linked account via Open Banking or ACH. ',
						enum: ['BANK_ACCOUNT', 'BANK_TRANSFER'],
						type: 'string',
					},
				},
				required: ['platform', 'device', 'currency', 'withdrawal_method'],
				type: 'object',
			},
			traits: {
				type: 'object',
			},
		},
		required: ['properties'],
		title: 'Withdrawal Amount Min Clicked',
		type: 'object',
	}
	const message = {
		event: 'Withdrawal Amount Min Clicked',
		properties: props || {},
		options,
	}
	validateAgainstSchema(message, schema)

	const a = analytics()
	if (a) {
		a.track(
			'Withdrawal Amount Min Clicked',
			props || {},
			withTypewriterContext(options),
			callback
		)
	}
}
/**
 * Withdrawal button which brings the user to the Withdrawal modal or page is clicked.
 *
 * @param {WithdrawalClicked} props - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function withdrawalClicked(
	props: WithdrawalClicked,
	options?: Segment.Options,
	callback?: Segment.Callback
): void {
	const schema = {
		$schema: 'http://json-schema.org/draft-07/schema#',
		description:
			'Withdrawal button which brings the user to the Withdrawal modal or page is clicked.',
		labels: {
			flow: ['withdraw_v1', 'trade_e1'],
			source: 'client',
		},
		properties: {
			context: {},
			properties: {
				properties: {
					device: {
						description: 'Device type from where the event was triggered.',
						enum: ['APP-iOS', 'WEB', 'APP-Android'],
						type: 'string',
					},
					origin: {
						description:
							'What Withdrawal button we are referring to. BALANCE : for the exchange, next to the balance (total account value) info on the main trading page. CURRENCY_PAGE : CTA or menu on the coin page next to balance. LINK_BANK : link a bank flow. LINK_WALLET. PORTFOLIO (exchange) : deposit next to currency balance.\n',
						enum: [
							'BALANCE',
							'CURRENCY_PAGE',
							'LINK_BANK',
							'LINK_WALLET',
							'PORTFOLIO',
						],
						type: 'string',
					},
					platform: {
						description: 'What platform the user clicked on the withdrawal ',
						enum: ['EXCHANGE', 'WALLET'],
						type: 'string',
					},
				},
				required: ['device', 'origin', 'platform'],
				type: 'object',
			},
			traits: {
				type: 'object',
			},
		},
		required: ['properties'],
		title: 'Withdrawal Clicked',
		type: 'object',
	}
	const message = {
		event: 'Withdrawal Clicked',
		properties: props || {},
		options,
	}
	validateAgainstSchema(message, schema)

	const a = analytics()
	if (a) {
		a.track(
			'Withdrawal Clicked',
			props || {},
			withTypewriterContext(options),
			callback
		)
	}
}
/**
 * The user selects how the funds will be withdrawn, either linked bank or transfer
 *
 * @param {WithdrawalMethodSelected} props - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function withdrawalMethodSelected(
	props: WithdrawalMethodSelected,
	options?: Segment.Options,
	callback?: Segment.Callback
): void {
	const schema = {
		$schema: 'http://json-schema.org/draft-07/schema#',
		description:
			'The user selects how the funds will be withdrawn, either linked bank or transfer',
		labels: {
			flow: ['withdraw_v1', 'trade_e1'],
			source: 'client',
		},
		properties: {
			context: {},
			properties: {
				properties: {
					currency: {
						description: 'the currency the user wants to withdraw',
						pattern: '^[A-Z]{3,5}$',
						type: 'string',
					},
					device: {
						description: 'Device type from where the event was triggered.',
						enum: ['APP-iOS', 'WEB', 'APP-Android'],
						type: 'string',
					},
					platform: {
						description: 'What platform the user is withdraw funds from',
						enum: ['EXCHANGE', 'WALLET'],
						type: 'string',
					},
					to_account_type: {
						description:
							'To what type of account the user wants to withdraw funds to. Only makes sense for Exchange. Null otherwise. \nEXCHANGE : Blockchain Exchange wallet \nEXTERNAL : external address outside Blockchain.com. \nSAVINGS : interest saving account. \nTRADING : wallet custodial wallet. \nUSERKEY : Non Custodial, Private Key, wallet',
						enum: ['EXTERNAL', 'SAVINGS', 'TRADING', 'USERKEY', null],
						type: ['string', 'null'],
					},
					withdrawal_method: {
						description:
							'How the funds will be withdrawn : \nBANK_ACCOUNT: funds sent to a bank account. \nBANK_TRANSFER : Funds sent to Linked account via Open Banking or ACH. CRYPTO : withdrawing to a crypto address',
						enum: ['BANK_ACCOUNT', 'BANK_TRANSFER', 'CRYPTO'],
						type: 'string',
					},
				},
				required: ['withdrawal_method', 'platform', 'currency', 'device'],
				type: 'object',
			},
			traits: {
				type: 'object',
			},
		},
		required: ['properties'],
		title: 'Withdrawal Method Selected',
		type: 'object',
	}
	const message = {
		event: 'Withdrawal Method Selected',
		properties: props || {},
		options,
	}
	validateAgainstSchema(message, schema)

	const a = analytics()
	if (a) {
		a.track(
			'Withdrawal Method Selected',
			props || {},
			withTypewriterContext(options),
			callback
		)
	}
}
/**
 * Withdrawal flyover or screen viewed. This should be triggered anytime the page is showed coming from another part of the product
 *
 * @param {WithdrawalViewed} props - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function withdrawalViewed(
	props: WithdrawalViewed,
	options?: Segment.Options,
	callback?: Segment.Callback
): void {
	const schema = {
		$schema: 'http://json-schema.org/draft-07/schema#',
		description:
			'Withdrawal flyover or screen viewed. This should be triggered anytime the page is showed coming from another part of the product',
		labels: {
			flow: ['withdraw_v1', 'trade_e1'],
			source: 'client',
		},
		properties: {
			context: {},
			properties: {
				properties: {
					device: {
						description: 'Device type from where the event was triggered.',
						enum: ['APP-iOS', 'WEB', 'APP-Android'],
						type: 'string',
					},
					path: {
						description:
							'Path portion of the URL of the page. Equivalent to canonical path which defaults to location.pathname from the DOM API.',
						type: 'string',
					},
					platform: {
						description: 'What platform the user wants to withdraw from',
						enum: ['EXCHANGE', 'WALLET'],
						type: 'string',
					},
					referrer: {
						description:
							'Full URL of the previous page. Equivalent to document.referrer from the DOM API.',
						type: 'string',
					},
					search: {
						description:
							'Query string portion of the URL of the page. Equivalent to location.search from the DOM API.',
						type: 'string',
					},
					title: {
						description:
							'Title of the page. Equivalent to document.title from the DOM API.',
						type: 'string',
					},
					url: {
						description:
							'Full URL of the page. First we look for the canonical url. If the canonical url is not provided, we use location.href from the DOM API.',
						type: 'string',
					},
				},
				required: ['platform', 'device'],
				type: 'object',
			},
			traits: {
				type: 'object',
			},
		},
		required: ['properties'],
		title: 'Withdrawal Viewed',
		type: 'object',
	}
	const message = {
		event: 'Withdrawal Viewed',
		properties: props || {},
		options,
	}
	validateAgainstSchema(message, schema)

	const a = analytics()
	if (a) {
		a.track(
			'Withdrawal Viewed',
			props || {},
			withTypewriterContext(options),
			callback
		)
	}
}
/**
 * Wrong XPub change cache stored in the payload is seen.
 *
 * @param {Record<string, any>} [props] - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function wrongChangeCache(
	props?: Record<string, any>,
	options?: Segment.Options,
	callback?: Segment.Callback
): void {
	const schema = {
		$schema: 'http://json-schema.org/draft-07/schema#',
		description: 'Wrong XPub change cache stored in the payload is seen.',
		labels: {
			source: 'client',
		},
		properties: {
			context: {},
			properties: {
				type: 'object',
			},
			traits: {
				type: 'object',
			},
		},
		title: 'Wrong Change Cache',
		type: 'object',
	}
	const message = {
		event: 'Wrong Change Cache',
		properties: props || {},
		options,
	}
	validateAgainstSchema(message, schema)

	const a = analytics()
	if (a) {
		a.track(
			'Wrong Change Cache',
			props || {},
			withTypewriterContext(options),
			callback
		)
	}
}
/**
 * Wrong XPub receive cache stored in the payload is seen.
 *
 * @param {Record<string, any>} [props] - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function wrongReceiveCache(
	props?: Record<string, any>,
	options?: Segment.Options,
	callback?: Segment.Callback
): void {
	const schema = {
		$schema: 'http://json-schema.org/draft-07/schema#',
		description: 'Wrong XPub receive cache stored in the payload is seen.',
		labels: {
			source: 'client',
		},
		properties: {
			context: {},
			properties: {
				type: 'object',
			},
			traits: {
				type: 'object',
			},
		},
		title: 'Wrong Receive Cache',
		type: 'object',
	}
	const message = {
		event: 'Wrong Receive Cache',
		properties: props || {},
		options,
	}
	validateAgainstSchema(message, schema)

	const a = analytics()
	if (a) {
		a.track(
			'Wrong Receive Cache',
			props || {},
			withTypewriterContext(options),
			callback
		)
	}
}

const clientAPI = {
	/**
	 * Updates the run-time configuration of this Typewriter client.
	 *
	 * @param {TypewriterOptions} options - the options to upsert
	 *
	 * @typedef {Object} TypewriterOptions
	 * @property {Segment.AnalyticsJS} [analytics] - Underlying analytics instance where analytics
	 * 		calls are forwarded on to. Defaults to window.analytics.
	 * @property {Function} [onViolation] - Handler fired when if an event does not match its spec. This handler does not fire in
	 * 		production mode, because it requires inlining the full JSON Schema spec for each event in your Tracking Plan. By default,
	 * 		it will throw errors if NODE_ENV="test" so that tests will fail if a message does not match the spec. Otherwise, errors
	 * 		will be logged to stderr.
	 */
	setTypewriterOptions,
	/**
	 * the user's password was changed successfully.
	 *
	 * @param {AccountPasswordChanged} props - The analytics properties that will be sent to Segment.
	 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
	 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
	 * 		call is fired.
	 */
	accountPasswordChanged,
	/**
	 * The user reset their password during a recovery process. This is triggered when the user enters the new password. This is different to the Account Password Changed event which is when user updates it for security reason by providing the old password.
	 *
	 * @param {AccountPasswordReset} props - The analytics properties that will be sent to Segment.
	 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
	 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
	 * 		call is fired.
	 */
	accountPasswordReset,
	/**
	 * The user tried to recover his account by resetting his password but it failed for some reasons. The alternative when it is successful is Account Password Reset.
	 *
	 * @param {AccountRecoveryFailed} props - The analytics properties that will be sent to Segment.
	 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
	 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
	 * 		call is fired.
	 */
	accountRecoveryFailed,
	/**
	 * The user clicks on button which shows the widget to input the number.
	 *
	 * @param {AddMobileNumberClicked} props - The analytics properties that will be sent to Segment.
	 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
	 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
	 * 		call is fired.
	 */
	addMobileNumberClicked,
	/**
	 * A user has imported an address to the wallet by adding the PK
	 *
	 * @param {AddressImported} props - The analytics properties that will be sent to Segment.
	 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
	 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
	 * 		call is fired.
	 */
	addressImported,
	/**
	 * User enters and submits his address
	 *
	 * @param {AddressInformationEntered} props - The analytics properties that will be sent to Segment.
	 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
	 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
	 * 		call is fired.
	 */
	addressInformationEntered,
	/**
	 * Non custodial address Label was updated.
	 *
	 * @param {AddressLabelEdited} props - The analytics properties that will be sent to Segment.
	 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
	 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
	 * 		call is fired.
	 */
	addressLabelEdited,
	/**
	 * A messaged signed by address' owner was verified
	 *
	 * @param {AddressMessageVerified} props - The analytics properties that will be sent to Segment.
	 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
	 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
	 * 		call is fired.
	 */
	addressMessageVerified,
	/**
	 * Track each time the user opens the widget to verify a Bitcoin message.
	 *
	 * @param {AddressVerifyMessageClicked} props - The analytics properties that will be sent to Segment.
	 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
	 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
	 * 		call is fired.
	 */
	addressVerifyMessageClicked,
	/**
	 * Bitcoin address label edited from the addresses list.
	 *
	 * @param {AddressesRevealed} props - The analytics properties that will be sent to Segment.
	 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
	 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
	 * 		call is fired.
	 */
	addressesRevealed,
	/**
	 * The user clicks on the widget or button to switch between native fiat and currency amounts
	 *
	 * @param {AmountSwitched} props - The analytics properties that will be sent to Segment.
	 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
	 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
	 * 		call is fired.
	 */
	amountSwitched,
	/**
	 * User clicks to open site with information about Blockchain.com APIs.
	 *
	 * @param {ApiAccessLinkClicked} props - The analytics properties that will be sent to Segment.
	 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
	 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
	 * 		call is fired.
	 */
	apiAccessLinkClicked,
	/**
	 * user backgrounds the application
	 *
	 * @param {ApplicationBackgrounded} props - The analytics properties that will be sent to Segment.
	 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
	 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
	 * 		call is fired.
	 */
	applicationBackgrounded,
	/**
	 * receive a crash notification from your app, but is not meant to supplant traditional crash reporting tools.
	 *
	 * @param {ApplicationCrashed} props - The analytics properties that will be sent to Segment.
	 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
	 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
	 * 		call is fired.
	 */
	applicationCrashed,
	/**
	 * This event fires when a user first opens your mobile application. Note, if the user never opens your app after installing, we will not be able to collect this event.
	 *
	 * @param {ApplicationInstalled} props - The analytics properties that will be sent to Segment.
	 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
	 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
	 * 		call is fired.
	 */
	applicationInstalled,
	/**
	 * This event fires when a user first opens your mobile application. Note, if the user never opens your app after installing, we will not be able to collect this event.
	 *
	 * @param {ApplicationOpened} props - The analytics properties that will be sent to Segment.
	 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
	 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
	 * 		call is fired.
	 */
	applicationOpened,
	/**
	 * user backgrounds the application
	 *
	 * @param {ApplicationUninstalled} props - The analytics properties that will be sent to Segment.
	 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
	 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
	 * 		call is fired.
	 */
	applicationUninstalled,
	/**
	 * user updates the application.
	 *
	 * @param {ApplicationUpdated} props - The analytics properties that will be sent to Segment.
	 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
	 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
	 * 		call is fired.
	 */
	applicationUpdated,
	/**
	 * The user sets the time period for the auto log out feature : after n minutes, the user automatically logs out.
	 *
	 * @param {AutoLogoutPeriodSet} props - The analytics properties that will be sent to Segment.
	 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
	 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
	 * 		call is fired.
	 */
	autoLogoutPeriodSet,
	/**
	 * A user's bank account state is updated
	 *
	 * @param {BankAccountStateTriggered} props - The analytics properties that will be sent to Segment.
	 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
	 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
	 * 		call is fired.
	 */
	bankAccountStateTriggered,
	/**
	 * Fires a 'Beneficiary Updated' track call.
	 *
	 * @param {BeneficiaryUpdated} props - The analytics properties that will be sent to Segment.
	 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
	 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
	 * 		call is fired.
	 */
	beneficiaryUpdated,
	/**
	 * Face Id or fingerprint security layer for mobile app was enabled or disabled.
	 *
	 * @param {BiometricsUpdated} props - The analytics properties that will be sent to Segment.
	 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
	 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
	 * 		call is fired.
	 */
	biometricsUpdated,
	/**
	 * The user enters and submits the amount for a buy transaction
	 *
	 * @param {BuyAmountEntered} props - The analytics properties that will be sent to Segment.
	 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
	 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
	 * 		call is fired.
	 */
	buyAmountEntered,
	/**
	 * The user clicked on the widget or button which sets pre selected amounts to the order
	
	 *
	 * @param {BuyAmountHelperClicked} props - The analytics properties that will be sent to Segment.
	 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
	 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
	 * 		call is fired.
	 */
	buyAmountHelperClicked,
	/**
	 * The user clicked on the widget or button which sets the max amount allowed or possible to the order.
	 *
	 * @param {BuyAmountMaxClicked} props - The analytics properties that will be sent to Segment.
	 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
	 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
	 * 		call is fired.
	 */
	buyAmountMaxClicked,
	/**
	 * The user clicked on the widget or button which sets the min amount allowed or possible to the order.
	 *
	 * @param {BuyAmountMinClicked} props - The analytics properties that will be sent to Segment.
	 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
	 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
	 * 		call is fired.
	 */
	buyAmountMinClicked,
	/**
	 * Buy order submitted by the user was cancelled (when updating a simple transaction with final state CANCELED)
	 *
	 * @param {BuyCancelled} props - The analytics properties that will be sent to Segment.
	 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
	 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
	 * 		call is fired.
	 */
	buyCancelled,
	/**
	 * Buy order submitted by the user is completed (when updating a simple transaction with final state FINISHED)
	 *
	 * @param {BuyCompleted} props - The analytics properties that will be sent to Segment.
	 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
	 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
	 * 		call is fired.
	 */
	buyCompleted,
	/**
	 * User submits a buy order (when creating a simple transactions with state CREATED)
	 *
	 * @param {BuyCreated} props - The analytics properties that will be sent to Segment.
	 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
	 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
	 * 		call is fired.
	 */
	buyCreated,
	/**
	 * Buy order submitted by the user had failed (when updating a simple transaction with final state FAILED)
	 *
	 * @param {BuyExpired} props - The analytics properties that will be sent to Segment.
	 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
	 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
	 * 		call is fired.
	 */
	buyExpired,
	/**
	 * Buy order submitted by the user had expired (when updating a simple transaction with final state EXPIRED)
	 *
	 * @param {BuyFailed} props - The analytics properties that will be sent to Segment.
	 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
	 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
	 * 		call is fired.
	 */
	buyFailed,
	/**
	 * The user clicks and submits the frequency he wants to select for the buy order
	 *
	 * @param {BuyFrequencySelected} props - The analytics properties that will be sent to Segment.
	 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
	 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
	 * 		call is fired.
	 */
	buyFrequencySelected,
	/**
	 * The user clicked on a Learn More widget in the end of the buy flow
	 *
	 * @param {BuyLearnMoreClicked} props - The analytics properties that will be sent to Segment.
	 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
	 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
	 * 		call is fired.
	 */
	buyLearnMoreClicked,
	/**
	 * The user has selected the payment method he wants to use for buying crypto.
	 *
	 * @param {BuyPaymentMethodSelected} props - The analytics properties that will be sent to Segment.
	 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
	 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
	 * 		call is fired.
	 */
	buyPaymentMethodSelected,
	/**
	 * Buy order submitted by the user is rejected. it is not being created at all
	 *
	 * @param {BuyRejected} props - The analytics properties that will be sent to Segment.
	 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
	 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
	 * 		call is fired.
	 */
	buyRejected,
	/**
	 * Buy or Sell button which brings the user to the Buy Sell product (wallet) or SimpleTrade flow (exchange) is clicked.
	 *
	 * @param {BuySellClicked} props - The analytics properties that will be sent to Segment.
	 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
	 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
	 * 		call is fired.
	 */
	buySellClicked,
	/**
	 * Buy or Sell page or screen is viewed. This is the Buy Sell SimpleBuy (wallet) or SimpleTrade (exchange) product flow
	 *
	 * @param {BuySellViewed} props - The analytics properties that will be sent to Segment.
	 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
	 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
	 * 		call is fired.
	 */
	buySellViewed,
	/**
	 * The user enters and submits the amount he wants to buy on the Buy Widget from the Explorer or Blockchain.com
	 *
	 * @param {BuyWidgetAmountEntered} props - The analytics properties that will be sent to Segment.
	 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
	 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
	 * 		call is fired.
	 */
	buyWidgetAmountEntered,
	/**
	 * The user clicks on a button or cta which opens the buy widget modal.
	 *
	 * @param {BuyWidgetClicked} props - The analytics properties that will be sent to Segment.
	 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
	 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
	 * 		call is fired.
	 */
	buyWidgetClicked,
	/**
	 * The device checks whether the camera access is authorised by the user.
	 *
	 * @param {CameraPermissionChecked} props - The analytics properties that will be sent to Segment.
	 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
	 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
	 * 		call is fired.
	 */
	cameraPermissionChecked,
	/**
	 * The user answers the request to provide access to the camera or not
	 *
	 * @param {CameraPermissionRequestActioned} props - The analytics properties that will be sent to Segment.
	 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
	 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
	 * 		call is fired.
	 */
	cameraPermissionRequestActioned,
	/**
	 * The user shows intent to cancel the recurring buy order. it will  require further confirmation later
	 *
	 * @param {CancelRecurringBuyClicked} props - The analytics properties that will be sent to Segment.
	 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
	 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
	 * 		call is fired.
	 */
	cancelRecurringBuyClicked,
	/**
	 * A user's card is activated. (when adding an account state ACTIVE with extra_attributes ->> 'type'  = 'PAYMENT_CARD')
	 *
	 * @param {CardStateTriggered} props - The analytics properties that will be sent to Segment.
	 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
	 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
	 * 		call is fired.
	 */
	cardStateTriggered,
	/**
	 * The user clicks on button which shows the widget to input the NEW number. On mobile this event is also activated when entering a number for the first time.
	 *
	 * @param {ChangeMobileNumberClicked} props - The analytics properties that will be sent to Segment.
	 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
	 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
	 * 		call is fired.
	 */
	changeMobileNumberClicked,
	/**
	 * User opens numpad interface to enter new Pin Code.
	 *
	 * @param {ChangePinClicked} props - The analytics properties that will be sent to Segment.
	 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
	 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
	 * 		call is fired.
	 */
	changePinClicked,
	/**
	 * The user has scanned the QR code to recover the account from the cloud backup. The feature is available on web only. It is triggered on web when the client doing the recovery receives the confirmation, and on the mobile app when the app client scans the code.
	 *
	 * @param {CloudBackupCodeScanned} props - The analytics properties that will be sent to Segment.
	 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
	 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
	 * 		call is fired.
	 */
	cloudBackupCodeScanned,
	/**
	 * A user has submitted a search on the price page for a token or asset.
	 *
	 * @param {CoinSearchSubmitted} props - The analytics properties that will be sent to Segment.
	 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
	 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
	 * 		call is fired.
	 */
	coinSearchSubmitted,
	/**
	 * The user clicks on some actions that the user can take after clicking on an app
	 *
	 * @param {ConnectedDappActioned} props - The analytics properties that will be sent to Segment.
	 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
	 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
	 * 		call is fired.
	 */
	connectedDappActioned,
	/**
	 * A button to view a connected app is clicked.
	 *
	 * @param {ConnectedDappClicked} props - The analytics properties that will be sent to Segment.
	 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
	 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
	 * 		call is fired.
	 */
	connectedDappClicked,
	/**
	 * The list of connected Apps is clicked
	 *
	 * @param {ConnectedDappsListClicked} props - The analytics properties that will be sent to Segment.
	 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
	 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
	 * 		call is fired.
	 */
	connectedDappsListClicked,
	/**
	 * The list of connected Apps is viewed
	 *
	 * @param {ConnectedDappsListViewed} props - The analytics properties that will be sent to Segment.
	 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
	 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
	 * 		call is fired.
	 */
	connectedDappsListViewed,
	/**
	 * Allows user to handle crypto payment links in the web browser.
	 *
	 * @param {CryptoLinkHandlingClicked} props - The analytics properties that will be sent to Segment.
	 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
	 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
	 * 		call is fired.
	 */
	cryptoLinkHandlingClicked,
	/**
	 * Enables user Wallet to handle crypto payment links in the web browser.
	 *
	 * @param {CryptoLinkHandlingEnabled} props - The analytics properties that will be sent to Segment.
	 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
	 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
	 * 		call is fired.
	 */
	cryptoLinkHandlingEnabled,
	/**
	 * A custodial transfer is completed. (when adding an entry to custodial_transfers from nabu gateway). This is done when moving funds between custodial accounts.
	 *
	 * @param {CustodialTransferCompleted} props - The analytics properties that will be sent to Segment.
	 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
	 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
	 * 		call is fired.
	 */
	custodialTransferCompleted,
	/**
	 * The user takes some actions in the dapp connection promp.
	 *
	 * @param {DappConnectionActioned} props - The analytics properties that will be sent to Segment.
	 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
	 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
	 * 		call is fired.
	 */
	dappConnectionActioned,
	/**
	 * The app connection to a new app was confirmed. This means the app is now connected to the blockchain wallet
	 *
	 * @param {DappConnectionConfirmed} props - The analytics properties that will be sent to Segment.
	 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
	 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
	 * 		call is fired.
	 */
	dappConnectionConfirmed,
	/**
	 * The app connection to a new app was rejected
	 *
	 * @param {DappConnectionRejected} props - The analytics properties that will be sent to Segment.
	 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
	 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
	 * 		call is fired.
	 */
	dappConnectionRejected,
	/**
	 * The user actions on a request from a connected dapp. it could be for example for signing a transaction
	 *
	 * @param {DappRequestActioned} props - The analytics properties that will be sent to Segment.
	 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
	 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
	 * 		call is fired.
	 */
	dappRequestActioned,
	/**
	 * Button which brings the user to the general overview of the wallet or the Home page on the exchange mobile app. Logo will be recorded as separate event.
	 *
	 * @param {DashboardClicked} props - The analytics properties that will be sent to Segment.
	 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
	 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
	 * 		call is fired.
	 */
	dashboardClicked,
	/**
	 * Product Dashboard or Home is viewed. It is the general overview of the wallet or the Home page on the exchange mobile app
	 *
	 * @param {DashboardViewed} [props] - The analytics properties that will be sent to Segment.
	 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
	 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
	 * 		call is fired.
	 */
	dashboardViewed,
	/**
	 * When application is opened using a referring link, Segment or your packaged deep link partner can fire this event on our behalf
	 *
	 * @param {DeepLinkClicked} props - The analytics properties that will be sent to Segment.
	 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
	 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
	 * 		call is fired.
	 */
	deepLinkClicked,
	/**
	 * When application is opened using a referring link, Segment or your packaged deep link partner can fire this event on our behalf
	 *
	 * @param {DeepLinkOpened} props - The analytics properties that will be sent to Segment.
	 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
	 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
	 * 		call is fired.
	 */
	deepLinkOpened,
	/**
	 * Bitcoin address removed from the addresses list.
	 *
	 * @param {DeletedAddressLabel} props - The analytics properties that will be sent to Segment.
	 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
	 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
	 * 		call is fired.
	 */
	deletedAddressLabel,
	/**
	 * The user selects and submits the amount to be deposited. The user will still have to validate or do action at a later stage. (confirm transfer or send funds from bank)
	 *
	 * @param {DepositAmountEntered} props - The analytics properties that will be sent to Segment.
	 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
	 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
	 * 		call is fired.
	 */
	depositAmountEntered,
	/**
	 * Button which brings the user to the Deposit flyover or screen is clicked.
	 *
	 * @param {DepositClicked} props - The analytics properties that will be sent to Segment.
	 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
	 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
	 * 		call is fired.
	 */
	depositClicked,
	/**
	 * The user selects how the funds will be deposited, either linked bank or transfer
	 *
	 * @param {DepositMethodSelected} props - The analytics properties that will be sent to Segment.
	 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
	 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
	 * 		call is fired.
	 */
	depositMethodSelected,
	/**
	 * Deposit flyover or screen viewed
	 *
	 * @param {DepositViewed} [props] - The analytics properties that will be sent to Segment.
	 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
	 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
	 * 		call is fired.
	 */
	depositViewed,
	/**
	 * The user pressed the magic link in the email to verify a new device, and he got back to the sign in flow. We record here when the client receives the device verified confirmation.
	 *
	 * @param {DeviceVerified} props - The analytics properties that will be sent to Segment.
	 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
	 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
	 * 		call is fired.
	 */
	deviceVerified,
	/**
	 * User clicks change email button.
	 *
	 * @param {EmailChangeClicked} props - The analytics properties that will be sent to Segment.
	 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
	 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
	 * 		call is fired.
	 */
	emailChangeClicked,
	/**
	 * The user requested the verification link to be sent again to change the wallet’s email address.
	 *
	 * @param {EmailChangeVerificationLinkResent} props - The analytics properties that will be sent to Segment.
	 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
	 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
	 * 		call is fired.
	 */
	emailChangeVerificationLinkResent,
	/**
	 * An email verification is requested. This is triggered (with or without explicit consent of the user). Note that some email verification emails are sent without request from the client.
	 *
	 * @param {EmailVerificationRequested} [props] - The analytics properties that will be sent to Segment.
	 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
	 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
	 * 		call is fired.
	 */
	emailVerificationRequested,
	/**
	 * An email verification was skipped by the user. This could also lead to an entire onboarding or verification flow being skipped.
	 *
	 * @param {EmailVerificationSkipped} props - The analytics properties that will be sent to Segment.
	 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
	 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
	 * 		call is fired.
	 */
	emailVerificationSkipped,
	/**
	 * Email has been verified by the user
	 *
	 * @param {EmailVerified} [props] - The analytics properties that will be sent to Segment.
	 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
	 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
	 * 		call is fired.
	 */
	emailVerified,
	/**
	 * A button inviting the user to discover our exchange product is clicked. Note that this does not include the navigation part of the header.
	 *
	 * @param {ExchangeHyperlinkClicked} props - The analytics properties that will be sent to Segment.
	 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
	 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
	 * 		call is fired.
	 */
	exchangeHyperlinkClicked,
	/**
	 * A user signs up for n Exchange account. Note that this is different from Signed Up which is triggered when a nabu user profile is created. An Exchange without a nabu user will be seen as an Anonymous User.
	 *
	 * @param {ExchangeSignedUp} props - The analytics properties that will be sent to Segment.
	 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
	 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
	 * 		call is fired.
	 */
	exchangeSignedUp,
	/**
	 * A user has clicked on the search bar to look for address, transaction, block or any explorer related information
	 *
	 * @param {ExplorerSearchClicked} props - The analytics properties that will be sent to Segment.
	 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
	 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
	 * 		call is fired.
	 */
	explorerSearchClicked,
	/**
	 * A user has submitted a search on the search bar to look for address, transaction, block or any explorer related information.
	 *
	 * @param {ExplorerSearchSubmitted} props - The analytics properties that will be sent to Segment.
	 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
	 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
	 * 		call is fired.
	 */
	explorerSearchSubmitted,
	/**
	 * A user has submitted a search on the search bar which resulted in no results.
	 *
	 * @param {ExplorerSearchWithNoResults} props - The analytics properties that will be sent to Segment.
	 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
	 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
	 * 		call is fired.
	 */
	explorerSearchWithNoResults,
	/**
	 * user selects fiat currency for trade. https://www.figma.com/file/IXwonpgbc67ho6uvPX7O74/NUX---New-User-Experience?node-id=445%3A30141
	 *
	 * @param {FiatCurrencySelected} props - The analytics properties that will be sent to Segment.
	 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
	 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
	 * 		call is fired.
	 */
	fiatCurrencySelected,
	/**
	 * An item of the footer is clicked
	 *
	 * @param {FooterOptionClicked} props - The analytics properties that will be sent to Segment.
	 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
	 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
	 * 		call is fired.
	 */
	footerOptionClicked,
	/**
	 * Button which brings the user to the activity history page or screen is clicked
	 *
	 * @param {HistoryClicked} props - The analytics properties that will be sent to Segment.
	 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
	 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
	 * 		call is fired.
	 */
	historyClicked,
	/**
	 * Activity history page or screen is viewed
	 *
	 * @param {HistoryViewed} props - The analytics properties that will be sent to Segment.
	 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
	 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
	 * 		call is fired.
	 */
	historyViewed,
	/**
	 * Track each time the user opens the widget to input the address data.
	 *
	 * @param {ImportAddressClicked} props - The analytics properties that will be sent to Segment.
	 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
	 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
	 * 		call is fired.
	 */
	importAddressClicked,
	/**
	 * When the user gives up  to import or restore his wallet and create an account. This is after entering his wallet recovery phrase.
	 *
	 * @param {ImportWalletCancelled} props - The analytics properties that will be sent to Segment.
	 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
	 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
	 * 		call is fired.
	 */
	importWalletCancelled,
	/**
	 * When clicking on a button to go to the Restore Wallet flow (also Called Import Wallet) flow. At that stage, we have no information about the wallet or user.
	 *
	 * @param {ImportWalletClicked} props - The analytics properties that will be sent to Segment.
	 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
	 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
	 * 		call is fired.
	 */
	importWalletClicked,
	/**
	 * When confirming that the user wants to import or restore his wallet and create an account. This is after entering his wallet recovery phrase.
	 *
	 * @param {ImportWalletConfirmed} props - The analytics properties that will be sent to Segment.
	 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
	 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
	 * 		call is fired.
	 */
	importWalletConfirmed,
	/**
	 * the source of the install https://segment.com/docs/connections/spec/mobile/#install-attributed
	 *
	 * @param {InstallAttributed} props - The analytics properties that will be sent to Segment.
	 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
	 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
	 * 		call is fired.
	 */
	installAttributed,
	/**
	 * Button which brings the user to the general Interest page or screen is clicked. General Interest page possibly only available on web.
	 *
	 * @param {InterestClicked} props - The analytics properties that will be sent to Segment.
	 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
	 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
	 * 		call is fired.
	 */
	interestClicked,
	/**
	 * User enters and submits the amount for a deposit to their interest saving account. Unlike other amount screens, the client will send a transfer requests as soon as the amount is submitted.
	 *
	 * @param {InterestDepositAmountEntered} props - The analytics properties that will be sent to Segment.
	 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
	 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
	 * 		call is fired.
	 */
	interestDepositAmountEntered,
	/**
	 * Button which brings the user to the interest deposit flyover or screen is clicked. It is sometimes called Transfer and is where the user can add funds to their interest savings wallet
	 *
	 * @param {InterestDepositClicked} props - The analytics properties that will be sent to Segment.
	 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
	 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
	 * 		call is fired.
	 */
	interestDepositClicked,
	/**
	 * The user clicked on the widget or button which sets the max amount allowed to deposit to their interest savings account
	 *
	 * @param {InterestDepositMaxAmountClicked} props - The analytics properties that will be sent to Segment.
	 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
	 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
	 * 		call is fired.
	 */
	interestDepositMaxAmountClicked,
	/**
	 * The user clicked on the widget or button which sets the min amount allowed to deposit to their interest savings account
	 *
	 * @param {InterestDepositMinAmountClicked} props - The analytics properties that will be sent to Segment.
	 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
	 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
	 * 		call is fired.
	 */
	interestDepositMinAmountClicked,
	/**
	 * Interest deposit page viewed. It is also called transfer and is where the user can add funds to their interest saving wallet
	 *
	 * @param {InterestDepositViewed} [props] - The analytics properties that will be sent to Segment.
	 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
	 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
	 * 		call is fired.
	 */
	interestDepositViewed,
	/**
	 * User clicks on a button to submit information. Submitting these , are required by compliance after hitting a certain volume.
	 *
	 * @param {InterestSubmitInformationClicked} props - The analytics properties that will be sent to Segment.
	 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
	 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
	 * 		call is fired.
	 */
	interestSubmitInformationClicked,
	/**
	 * General Interest page viewed. It is usually the landing page with the list of savings accounts
	 *
	 * @param {InterestViewed} [props] - The analytics properties that will be sent to Segment.
	 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
	 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
	 * 		call is fired.
	 */
	interestViewed,
	/**
	 * Button which brings the user to the interest withdrawal flyover or screen is clicked. It is where the user can add withdraw funds from their interest savings wallet
	 *
	 * @param {InterestWithdrawalClicked} [props] - The analytics properties that will be sent to Segment.
	 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
	 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
	 * 		call is fired.
	 */
	interestWithdrawalClicked,
	/**
	 * Interest withdrawal page viewed. It is where the user can withdraw funds from their interest savings wallet
	 *
	 * @param {InterestWithdrawalViewed} [props] - The analytics properties that will be sent to Segment.
	 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
	 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
	 * 		call is fired.
	 */
	interestWithdrawalViewed,
	/**
	 * Allow login without email authentication from a list of IP addresses.
	 *
	 * @param {IpWhitelistUpdated} props - The analytics properties that will be sent to Segment.
	 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
	 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
	 * 		call is fired.
	 */
	ipWhitelistUpdated,
	/**
	 * User sets their preferred language from the displayed options.
	 *
	 * @param {LanguageSet} props - The analytics properties that will be sent to Segment.
	 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
	 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
	 * 		call is fired.
	 */
	languageSet,
	/**
	 * An item of the left menu is clicked
	 *
	 * @param {LeftMenuSelectionClicked} props - The analytics properties that will be sent to Segment.
	 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
	 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
	 * 		call is fired.
	 */
	leftMenuSelectionClicked,
	/**
	 * The legal entity of the user has been updated (different from an assigned legal entity, with is recorded in the "Signed Up" event)
	 *
	 * @param {LegalEntityUpdated} props - The analytics properties that will be sent to Segment.
	 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
	 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
	 * 		call is fired.
	 */
	legalEntityUpdated,
	/**
	 * The user clicks on a button to link a bank
	 *
	 * @param {LinkBankClicked} [props] - The analytics properties that will be sent to Segment.
	 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
	 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
	 * 		call is fired.
	 */
	linkBankClicked,
	/**
	 * The user approves the general conditions and approvals necessary to start the link process with the bank. The user selects what bank he wants to link (e.g. REVOLUT, BARCLAYS, etc.). NOTE : Only available for OB. Not available for Web because it's inside an iframe
	 *
	 * @param {LinkBankConditionsApproved} props - The analytics properties that will be sent to Segment.
	 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
	 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
	 * 		call is fired.
	 */
	linkBankConditionsApproved,
	/**
	 * The user selects what bank he wants to link (e.g. REVOLUT, BARCLAYS, etc.). NOTE : Only available for OB. Not available for Web because it's inside an iframe
	 *
	 * @param {LinkBankSelected} props - The analytics properties that will be sent to Segment.
	 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
	 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
	 * 		call is fired.
	 */
	linkBankSelected,
	/**
	 * The user clicks on the Add Card button to link a Card
	 *
	 * @param {LinkCardClicked} props - The analytics properties that will be sent to Segment.
	 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
	 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
	 * 		call is fired.
	 */
	linkCardClicked,
	/**
	 * User sets the local currency from the displayed options.
	 *
	 * @param {LocalCurrencySet} props - The analytics properties that will be sent to Segment.
	 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
	 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
	 * 		call is fired.
	 */
	localCurrencySet,
	/**
	 * Login or Sign in button which brings the user to the log in flow is clicked
	 *
	 * @param {LoginClicked} props - The analytics properties that will be sent to Segment.
	 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
	 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
	 * 		call is fired.
	 */
	loginClicked,
	/**
	 * User clicks on a button or link to get help when having trouble logging in. For example "Need Some Help" link
	 *
	 * @param {LoginHelpClicked} props - The analytics properties that will be sent to Segment.
	 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
	 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
	 * 		call is fired.
	 */
	loginHelpClicked,
	/**
	 * The user entered and submitted their Email or Wallet ID to log in
	 *
	 * @param {LoginIdentifierEntered} props - The analytics properties that will be sent to Segment.
	 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
	 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
	 * 		call is fired.
	 */
	loginIdentifierEntered,
	/**
	 * Allowing login from IP address in user's IP whitelist.
	 *
	 * @param {LoginIpRestrictionUpdated} props - The analytics properties that will be sent to Segment.
	 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
	 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
	 * 		call is fired.
	 */
	loginIpRestrictionUpdated,
	/**
	 * The user explicitly selects a login method, by clicking on Log In With Password, or Log In with device, etc.
	 *
	 * @param {LoginMethodSelected} props - The analytics properties that will be sent to Segment.
	 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
	 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
	 * 		call is fired.
	 */
	loginMethodSelected,
	/**
	 * The user approved the log in request (usually on mobile) sent from another client (usually from web). The request is  done via Secure Channel Opening Authentication, and approving will open the channel
	 *
	 * @param {LoginRequestApproved} props - The analytics properties that will be sent to Segment.
	 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
	 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
	 * 		call is fired.
	 */
	loginRequestApproved,
	/**
	 * The user denied the log in request (usually on mobile) sent from another client (usually from web). The request is usually done via Secure Channel Opening Authentication, and denying will close the channel
	 *
	 * @param {LoginRequestDenied} props - The analytics properties that will be sent to Segment.
	 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
	 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
	 * 		call is fired.
	 */
	loginRequestDenied,
	/**
	 * The user Two Factor Authentication verification code entered by the user to confirm log in is denied
	 *
	 * @param {LoginTwoStepVerificationDenied} props - The analytics properties that will be sent to Segment.
	 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
	 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
	 * 		call is fired.
	 */
	loginTwoStepVerificationDenied,
	/**
	 * The user enters and submits the Two Factor Authentication verification code to confirm log in
	 *
	 * @param {LoginTwoStepVerificationEntered} props - The analytics properties that will be sent to Segment.
	 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
	 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
	 * 		call is fired.
	 */
	loginTwoStepVerificationEntered,
	/**
	 * User clicks on the Blockchain.com logo
	 *
	 * @param {LogoClicked} [props] - The analytics properties that will be sent to Segment.
	 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
	 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
	 * 		call is fired.
	 */
	logoClicked,
	/**
	 * Option selected from the drop down menu From the Bitcoin or the Bitcoin Cash tab.
	 *
	 * @param {ManageTabSelectionClicked} props - The analytics properties that will be sent to Segment.
	 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
	 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
	 * 		call is fired.
	 */
	manageTabSelectionClicked,
	/**
	 * The Verification for the tier has been sent but requires further manual checks before the user can proceed
	 *
	 * @param {ManualVerificationRequired} props - The analytics properties that will be sent to Segment.
	 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
	 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
	 * 		call is fired.
	 */
	manualVerificationRequired,
	/**
	 * User clicks on a button to add or remove collateral. This button opens the form to start filling the margin collateral amount
	 *
	 * @param {MarginCollateralClicked} props - The analytics properties that will be sent to Segment.
	 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
	 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
	 * 		call is fired.
	 */
	marginCollateralClicked,
	/**
	 * User updated the collateral amount to of a margin position.
	 *
	 * @param {MarginCollateralUpdated} props - The analytics properties that will be sent to Segment.
	 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
	 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
	 * 		call is fired.
	 */
	marginCollateralUpdated,
	/**
	 * User canceled margin order
	 *
	 * @param {MarginOrderCancelled} props - The analytics properties that will be sent to Segment.
	 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
	 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
	 * 		call is fired.
	 */
	marginOrderCancelled,
	/**
	 * The user submits a margin order.
	 *
	 * @param {MarginOrderSubmitted} props - The analytics properties that will be sent to Segment.
	 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
	 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
	 * 		call is fired.
	 */
	marginOrderSubmitted,
	/**
	 * The user closes an open margin position.
	 *
	 * @param {MarginPositionClosed} props - The analytics properties that will be sent to Segment.
	 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
	 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
	 * 		call is fired.
	 */
	marginPositionClosed,
	/**
	 * The user performed an action after the margin waitlist invite is shown.
	 *
	 * @param {MarginWaitlistActioned} props - The analytics properties that will be sent to Segment.
	 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
	 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
	 * 		call is fired.
	 */
	marginWaitlistActioned,
	/**
	 * The user is shown an announcement to join the margin waitlist
	 *
	 * @param {MarginWaitlistShown} props - The analytics properties that will be sent to Segment.
	 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
	 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
	 * 		call is fired.
	 */
	marginWaitlistShown,
	/**
	 * The mobile app install screen is updated to display the instructions for another device. This is done via the toggle button
	 *
	 * @param {MobileAppInstallDeviceUpdated} props - The analytics properties that will be sent to Segment.
	 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
	 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
	 * 		call is fired.
	 */
	mobileAppInstallDeviceUpdated,
	/**
	 * The mobile app icon to install the app is clicked. This button can be found for example in the exchange header
	 *
	 * @param {MobileAppInstallIconClicked} props - The analytics properties that will be sent to Segment.
	 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
	 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
	 * 		call is fired.
	 */
	mobileAppInstallIconClicked,
	/**
	 * The mobile app icon to install the app is clicked. This button can be found for example in the exchange header
	 *
	 * @param {MobileAppInstallLinkCopied} props - The analytics properties that will be sent to Segment.
	 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
	 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
	 * 		call is fired.
	 */
	mobileAppInstallLinkCopied,
	/**
	 * The Mobile Number was succesfully verified.
	 *
	 * @param {MobileNumberVerified} props - The analytics properties that will be sent to Segment.
	 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
	 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
	 * 		call is fired.
	 */
	mobileNumberVerified,
	/**
	 * User changed the mobile pin code.
	 *
	 * @param {MobilePinCodeChanged} props - The analytics properties that will be sent to Segment.
	 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
	 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
	 * 		call is fired.
	 */
	mobilePinCodeChanged,
	/**
	 * More NFTs button clicked
	 *
	 * @param {MoreNftClicked} props - The analytics properties that will be sent to Segment.
	 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
	 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
	 * 		call is fired.
	 */
	moreNftClicked,
	/**
	 * button inside a NFT card which redirects the user to Opensea (CREATOR, OWNER OR COLLECTION). Opeansea LOGO redirects to opensea.  ASSET when the user clicks the nft card
	 *
	 * @param {NftHyperlinkClicked} props - The analytics properties that will be sent to Segment.
	 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
	 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
	 * 		call is fired.
	 */
	nftHyperlinkClicked,
	/**
	 * User has opened the buy NFT order form, showing intent to purchase NFT.
	 *
	 * @param {NftOrderCreated} props - The analytics properties that will be sent to Segment.
	 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
	 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
	 * 		call is fired.
	 */
	nftOrderCreated,
	/**
	 * An NFT buy order failed, either because of a wallet error, or an opensea api failure.
	 *
	 * @param {NftOrderFailed} props - The analytics properties that will be sent to Segment.
	 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
	 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
	 * 		call is fired.
	 */
	nftOrderFailed,
	/**
	 * An NFT order has been successfully sent
	 *
	 * @param {NftOrderSucceeded} props - The analytics properties that will be sent to Segment.
	 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
	 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
	 * 		call is fired.
	 */
	nftOrderSucceeded,
	/**
	 * An item of the navigation breadcrumbs is clicked
	 *
	 * @param {NavigationBreadcrumbsClicked} props - The analytics properties that will be sent to Segment.
	 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
	 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
	 * 		call is fired.
	 */
	navigationBreadcrumbsClicked,
	/**
	 * An item of the navigation header  is clicked
	 *
	 * @param {NavigationOptionClicked} props - The analytics properties that will be sent to Segment.
	 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
	 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
	 * 		call is fired.
	 */
	navigationOptionClicked,
	/**
	 * Bitcoin address added to the addresses list.
	 *
	 * @param {NextAddressAdded} props - The analytics properties that will be sent to Segment.
	 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
	 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
	 * 		call is fired.
	 */
	nextAddressAdded,
	/**
	 * User updates whether they prefer email, SMS or both for notifications
	 *
	 * @param {NotificationPreferencesUpdated} props - The analytics properties that will be sent to Segment.
	 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
	 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
	 * 		call is fired.
	 */
	notificationPreferencesUpdated,
	/**
	 * Generic event for tracking a web page
	 *
	 * @param {PageViewed} props - The analytics properties that will be sent to Segment.
	 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
	 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
	 * 		call is fired.
	 */
	pageViewed,
	/**
	 * increases the difficulty of discovering the password using a brute-force attack but slows down loading and saving your wallet. (PBKDF2)
	 *
	 * @param {PasswordStretchingChanged} props - The analytics properties that will be sent to Segment.
	 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
	 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
	 * 		call is fired.
	 */
	passwordStretchingChanged,
	/**
	 * A rule is being checked for a payment. This is from the rule_execution_report in Nabu Fraud DB
	 *
	 * @param {PaymentRuleExecuted} props - The analytics properties that will be sent to Segment.
	 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
	 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
	 * 		call is fired.
	 */
	paymentRuleExecuted,
	/**
	 * A user completed a payment. (when updating final state to "COMPLETE" of transaction from nabu payments)
	 *
	 * @param {PaymentStateTriggered} props - The analytics properties that will be sent to Segment.
	 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
	 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
	 * 		call is fired.
	 */
	paymentStateTriggered,
	/**
	 * peeksheet dismissed by user x
	 *
	 * @param {PeeksheetDismissed} props - The analytics properties that will be sent to Segment.
	 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
	 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
	 * 		call is fired.
	 */
	peeksheetDismissed,
	/**
	 * Peeksheet Process clicked from at the home dashboard. users in regions where trading is allowed will be presented with the new peek sheet. https://www.figma.com/file/IXwonpgbc67ho6uvPX7O74/NUX---New-User-Experience?node-id=572%3A36112
	 *
	 * @param {PeeksheetProcessClicked} props - The analytics properties that will be sent to Segment.
	 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
	 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
	 * 		call is fired.
	 */
	peeksheetProcessClicked,
	/**
	 * peeksheet selection was chosen
	 *
	 * @param {PeeksheetSelectionClicked} props - The analytics properties that will be sent to Segment.
	 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
	 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
	 * 		call is fired.
	 */
	peeksheetSelectionClicked,
	/**
	 * users in regions where trading is allowed will be presented with the new peek sheet.
	 *
	 * @param {PeeksheetViewed} props - The analytics properties that will be sent to Segment.
	 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
	 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
	 * 		call is fired.
	 */
	peeksheetViewed,
	/**
	 * User enters and submits his first name, last names, and date of birth
	 *
	 * @param {PersonalInformationEntered} props - The analytics properties that will be sent to Segment.
	 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
	 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
	 * 		call is fired.
	 */
	personalInformationEntered,
	/**
	 * Button which brings the user to the Portofolio page or screen is clicked
	 *
	 * @param {PortfolioClicked} props - The analytics properties that will be sent to Segment.
	 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
	 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
	 * 		call is fired.
	 */
	portfolioClicked,
	/**
	 * Portfolio screen or page in the exchange is viewed
	 *
	 * @param {PortfolioViewed} props - The analytics properties that will be sent to Segment.
	 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
	 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
	 * 		call is fired.
	 */
	portfolioViewed,
	/**
	 * The user clicks on the Show button which shows the QR Code and the written Private Key of the current cryptocurrency tab.   Note from frontend: The Event is triggered once even if user toggles it on and off.
	 *
	 * @param {PrivateKeysShown} props - The analytics properties that will be sent to Segment.
	 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
	 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
	 * 		call is fired.
	 */
	privateKeysShown,
	/**
	 * Push notification from a provider bounces. https://segment.com/docs/connections/spec/mobile/#push-notification-bounced
	 *
	 * @param {PushNotificationBounced} props - The analytics properties that will be sent to Segment.
	 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
	 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
	 * 		call is fired.
	 */
	pushNotificationBounced,
	/**
	 * This event can be sent when a push notification is received in the app
	 *
	 * @param {PushNotificationReceived} props - The analytics properties that will be sent to Segment.
	 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
	 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
	 * 		call is fired.
	 */
	pushNotificationReceived,
	/**
	 * Push Notification Sent
	 *
	 * @param {PushNotificationSent} props - The analytics properties that will be sent to Segment.
	 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
	 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
	 * 		call is fired.
	 */
	pushNotificationSent,
	/**
	 * user taps on a push notification associated with the app
	 *
	 * @param {PushNotificationTapped} props - The analytics properties that will be sent to Segment.
	 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
	 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
	 * 		call is fired.
	 */
	pushNotificationTapped,
	/**
	 * A Qr Code icon has been clicked on. This is typically going to trigger the camera or a menu first of things that could be scanned
	 *
	 * @param {QrCodeClicked} props - The analytics properties that will be sent to Segment.
	 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
	 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
	 * 		call is fired.
	 */
	qrCodeClicked,
	/**
	 * The user scanned a QR code using his camera from the device. It could be an external crypto address, a Dapp, or blockhain login
	 *
	 * @param {QrCodeScanned} props - The analytics properties that will be sent to Segment.
	 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
	 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
	 * 		call is fired.
	 */
	qrCodeScanned,
	/**
	 * A user selects the currency and accounts he wants to receive.
	 *
	 * @param {ReceiveCurrencySelected} props - The analytics properties that will be sent to Segment.
	 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
	 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
	 * 		call is fired.
	 */
	receiveCurrencySelected,
	/**
	 * A user copies to clipboard the information to receive the currency
	 *
	 * @param {ReceiveDetailsCopied} props - The analytics properties that will be sent to Segment.
	 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
	 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
	 * 		call is fired.
	 */
	receiveDetailsCopied,
	/**
	 * The user confirms the Recovery Phrase words to verify that the user saved the words offline.
	 *
	 * @param {RecoveryPhraseBackedUp} props - The analytics properties that will be sent to Segment.
	 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
	 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
	 * 		call is fired.
	 */
	recoveryPhraseBackedUp,
	/**
	 * The user has entered and submitted the recovery phrase to recover his account
	 *
	 * @param {RecoveryPhraseEntered} props - The analytics properties that will be sent to Segment.
	 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
	 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
	 * 		call is fired.
	 */
	recoveryPhraseEntered,
	/**
	 * The user request the Secret Recovery Phrase which shows the 12 words needed to recover the wallet in case of password loss.
	 *
	 * @param {RecoveryPhraseShown} props - The analytics properties that will be sent to Segment.
	 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
	 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
	 * 		call is fired.
	 */
	recoveryPhraseShown,
	/**
	 * The user sets up a recurring buy order. This is when the backend creates a new recurring buy with initial state ACTIVE, or if a former recurring buy is activated again.
	 *
	 * @param {RecurringBuyActivated} props - The analytics properties that will be sent to Segment.
	 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
	 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
	 * 		call is fired.
	 */
	recurringBuyActivated,
	/**
	 * The recurring buy order was cancelled either by the user or automatically, for example due to many failed attempts. This is when the backend sets to state INACTIVE the recurring buy.
	 *
	 * @param {RecurringBuyCancelled} props - The analytics properties that will be sent to Segment.
	 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
	 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
	 * 		call is fired.
	 */
	recurringBuyCancelled,
	/**
	 * The user clicks on a widget to start the Recurring Buy flow
	 *
	 * @param {RecurringBuyClicked} props - The analytics properties that will be sent to Segment.
	 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
	 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
	 * 		call is fired.
	 */
	recurringBuyClicked,
	/**
	 * The user clicks on a recurring buy to see the details of what is currently set up
	 *
	 * @param {RecurringBuyDetailsClicked} props - The analytics properties that will be sent to Segment.
	 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
	 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
	 * 		call is fired.
	 */
	recurringBuyDetailsClicked,
	/**
	 * The user views some further information or description about the Recurring buy feature
	 *
	 * @param {RecurringBuyInfoViewed} props - The analytics properties that will be sent to Segment.
	 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
	 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
	 * 		call is fired.
	 */
	recurringBuyInfoViewed,
	/**
	 * The user wants to learn more about the recurring buy feature. This could be bring the user either to an internal screen (Recurring Buy Info Viewed) or external link.
	 *
	 * @param {RecurringBuyLearnMoreClicked} props - The analytics properties that will be sent to Segment.
	 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
	 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
	 * 		call is fired.
	 */
	recurringBuyLearnMoreClicked,
	/**
	 * The user reacted negatively on a screen suggesting to set up recurring buy. This could be either closing the suggestion or clicking on the negative option (Maybe Later, Skip, Exit, etc..)
	 *
	 * @param {RecurringBuySuggestionSkipped} props - The analytics properties that will be sent to Segment.
	 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
	 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
	 * 		call is fired.
	 */
	recurringBuySuggestionSkipped,
	/**
	 * The user was shown a warning about recurring buy unavailable
	 *
	 * @param {RecurringBuyUnavailableShown} props - The analytics properties that will be sent to Segment.
	 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
	 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
	 * 		call is fired.
	 */
	recurringBuyUnavailableShown,
	/**
	 * Recurring Buy Flow page or screen is viewed. This is triggered whenever the user opens the recurring buy flow from another part of the wallet
	 *
	 * @param {RecurringBuyViewed} props - The analytics properties that will be sent to Segment.
	 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
	 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
	 * 		call is fired.
	 */
	recurringBuyViewed,
	/**
	 * The browser will be remembered for a short period of time, allowing user to login again without having to re-authenticate. If Disabled, authentication is needed for every login.
	 *
	 * @param {RememberTwoStepVerificationUpdated} props - The analytics properties that will be sent to Segment.
	 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
	 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
	 * 		call is fired.
	 */
	rememberTwoStepVerificationUpdated,
	/**
	 * The user clicks on the Add Card button to link a Card
	 *
	 * @param {RemoveLinkedCardClicked} props - The analytics properties that will be sent to Segment.
	 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
	 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
	 * 		call is fired.
	 */
	removeLinkedCardClicked,
	/**
	 * When clicking on a button to discard reset flow, such as "Go Back" on a reset final warning or at the first confirmation
	 *
	 * @param {ResetAccountCancelled} props - The analytics properties that will be sent to Segment.
	 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
	 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
	 * 		call is fired.
	 */
	resetAccountCancelled,
	/**
	 * When clicking on a button to go to the reset account flow, such as "Reset your account"
	 *
	 * @param {ResetAccountClicked} props - The analytics properties that will be sent to Segment.
	 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
	 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
	 * 		call is fired.
	 */
	resetAccountClicked,
	/**
	 * Generic event when a user completes a revenue generating event
	 *
	 * @param {RevenueGenerated} props - The analytics properties that will be sent to Segment.
	 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
	 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
	 * 		call is fired.
	 */
	revenueGenerated,
	/**
	 * A user opens the search bar to search for a coin.
	 *
	 * @param {SearchCoinOpened} props - The analytics properties that will be sent to Segment.
	 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
	 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
	 * 		call is fired.
	 */
	searchCoinOpened,
	/**
	 * The user clicks the security section in the header (top right)
	
	 *
	 * @param {SecurityTabClicked} props - The analytics properties that will be sent to Segment.
	 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
	 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
	 * 		call is fired.
	 */
	securityTabClicked,
	/**
	 * The user enters and submits the amount for a sell transaction
	 *
	 * @param {SellAmountEntered} props - The analytics properties that will be sent to Segment.
	 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
	 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
	 * 		call is fired.
	 */
	sellAmountEntered,
	/**
	 * The user clicks on the widget or button which sets the max amount allowed or possible to sell from the account
	 *
	 * @param {SellAmountMaxClicked} props - The analytics properties that will be sent to Segment.
	 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
	 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
	 * 		call is fired.
	 */
	sellAmountMaxClicked,
	/**
	 * The user clicks on the widget or button which sets the min amount allowed or possible to sell from the account
	 *
	 * @param {SellAmountMinClicked} props - The analytics properties that will be sent to Segment.
	 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
	 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
	 * 		call is fired.
	 */
	sellAmountMinClicked,
	/**
	 * Sell order submitted by the user was cancelled (when updating to final state CANCELED either the simple or custodial transaction from nabu gateway )
	 *
	 * @param {SellCancelled} props - The analytics properties that will be sent to Segment.
	 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
	 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
	 * 		call is fired.
	 */
	sellCancelled,
	/**
	 * Sell order is completed (when updating to final state FINISHED either the simple or custodial transaction from nabu gateway )
	 *
	 * @param {SellCompleted} props - The analytics properties that will be sent to Segment.
	 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
	 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
	 * 		call is fired.
	 */
	sellCompleted,
	/**
	 * User submits a sell order (when creating a simple transactions with state CREATED, or custodial transactions from crypto to fiat with state CREATED)
	 *
	 * @param {SellCreated} props - The analytics properties that will be sent to Segment.
	 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
	 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
	 * 		call is fired.
	 */
	sellCreated,
	/**
	 * Sell order has expired (when updating to final state EXPIRED either the simple or custodial transaction from nabu gateway )
	 *
	 * @param {SellExpired} props - The analytics properties that will be sent to Segment.
	 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
	 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
	 * 		call is fired.
	 */
	sellExpired,
	/**
	 * Sell order has failed (when updating to final state FAILED either the simple or custodial transaction from nabu gateway )
	 *
	 * @param {SellFailed} props - The analytics properties that will be sent to Segment.
	 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
	 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
	 * 		call is fired.
	 */
	sellFailed,
	/**
	 * The user selects what currency and from what account he wants to sell. Event is triggered when a specific account and currency are selected from a dropdown or list of potential accounts. If it comes from two dropdown, it should be triggered once both have been selected.
	 *
	 * @param {SellFromSelected} props - The analytics properties that will be sent to Segment.
	 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
	 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
	 * 		call is fired.
	 */
	sellFromSelected,
	/**
	 * Sell order submitted by the user is rejected. it is not being created at all
	 *
	 * @param {SellRejected} props - The analytics properties that will be sent to Segment.
	 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
	 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
	 * 		call is fired.
	 */
	sellRejected,
	/**
	 * A user enters and submits the amount that he wants to send. The user will typically have to confirm the send order in the next step.
	 *
	 * @param {SendAmountEntered} props - The analytics properties that will be sent to Segment.
	 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
	 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
	 * 		call is fired.
	 */
	sendAmountEntered,
	/**
	 * A user the maximum amount he can send
	 *
	 * @param {SendAmountMaxClicked} props - The analytics properties that will be sent to Segment.
	 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
	 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
	 * 		call is fired.
	 */
	sendAmountMaxClicked,
	/**
	 * A user sets the fee rate he wants to use to send the transaction
	 *
	 * @param {SendFeeRateSelected} props - The analytics properties that will be sent to Segment.
	 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
	 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
	 * 		call is fired.
	 */
	sendFeeRateSelected,
	/**
	 * A user selects the currency he wants to send and from what account he wants to send funds from. If currency and account are selected separately, trigger this event when the second one is selected.
	 *
	 * @param {SendFromSelected} props - The analytics properties that will be sent to Segment.
	 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
	 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
	 * 		call is fired.
	 */
	sendFromSelected,
	/**
	 * Button to access send/receive modal/tab is clicked.
	 *
	 * @param {SendReceiveClicked} props - The analytics properties that will be sent to Segment.
	 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
	 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
	 * 		call is fired.
	 */
	sendReceiveClicked,
	/**
	 * Send or Receive modal is viewed.
	 *
	 * @param {SendReceiveViewed} [props] - The analytics properties that will be sent to Segment.
	 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
	 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
	 * 		call is fired.
	 */
	sendReceiveViewed,
	/**
	 * A user selects and submits the transaction that needs to be sent. The client requests the transaction to the sent to the backend or the network directly
	 *
	 * @param {SendSubmitted} props - The analytics properties that will be sent to Segment.
	 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
	 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
	 * 		call is fired.
	 */
	sendSubmitted,
	/**
	 * The user clicks the {cryptocurrency} tab to manage the addresses/wallets'
	 *
	 * @param {SettingsCurrencyClicked} props - The analytics properties that will be sent to Segment.
	 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
	 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
	 * 		call is fired.
	 */
	settingsCurrencyClicked,
	/**
	 * User clicks to open site about Privacy Policy, About or Term of Service.
	 *
	 * @param {SettingsHyperlinkClicked} props - The analytics properties that will be sent to Segment.
	 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
	 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
	 * 		call is fired.
	 */
	settingsHyperlinkClicked,
	/**
	 * The users click to select the setting section
	 *
	 * @param {SettingsTabClicked} props - The analytics properties that will be sent to Segment.
	 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
	 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
	 * 		call is fired.
	 */
	settingsTabClicked,
	/**
	 * Button to skip log in and continue as guest
	 *
	 * @param {SignInSkipped} props - The analytics properties that will be sent to Segment.
	 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
	 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
	 * 		call is fired.
	 */
	signInSkipped,
	/**
	 * A user selects the country and state in the sign up form of a product that is not supported locally.
	 *
	 * @param {SignUpAddressUnsupported} props - The analytics properties that will be sent to Segment.
	 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
	 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
	 * 		call is fired.
	 */
	signUpAddressUnsupported,
	/**
	 * User clicks on a widget or button to go to the sign up screen. Not what this is different from the Wallet Signed Up and Exchange Signed Up events which is when the client submits the user creation request
	 *
	 * @param {SignUpClicked} props - The analytics properties that will be sent to Segment.
	 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
	 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
	 * 		call is fired.
	 */
	signUpClicked,
	/**
	 * A user selects the country in the sign up form. It could be an exchange or wallet sign up. This should be triggered as soon as the user selects the country, even if the user hasn't submitted the sign up form yet.
	 *
	 * @param {SignUpCountrySelected} props - The analytics properties that will be sent to Segment.
	 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
	 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
	 * 		call is fired.
	 */
	signUpCountrySelected,
	/**
	 * The user succesfully logs in. On mobile, it is triggered every time the user unlocks the app from the pin code.
	 *
	 * @param {SignedIn} props - The analytics properties that will be sent to Segment.
	 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
	 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
	 * 		call is fired.
	 */
	signedIn,
	/**
	 * The user logs out, by explicitly clicking on a Log Out or Sign Out button
	 *
	 * @param {SignedOut} props - The analytics properties that will be sent to Segment.
	 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
	 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
	 * 		call is fired.
	 */
	signedOut,
	/**
	 * A user signs up for a user profile (custodial) with us. For the wallet, this is when a nabu user is created. For the exchange, this is when exchange user credentials are created, slightly before the nabu profile. Note that this is different from Wallet Signed Up or Exchange Signed Up. The user is signed up automatically in the wallet or exchange when we need to record information about the user.
	 *
	 * @param {SignedUp} props - The analytics properties that will be sent to Segment.
	 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
	 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
	 * 		call is fired.
	 */
	signedUp,
	/**
	 * Button which brings the user to the Simple Trade general page or. screen, with all the available assets, is clicked. Next step of Simple Trade will be a Buy Sell flow. Note : SimpleTrade  uses the brokerage product under the hood
	 *
	 * @param {SimpleTradeClicked} props - The analytics properties that will be sent to Segment.
	 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
	 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
	 * 		call is fired.
	 */
	simpleTradeClicked,
	/**
	 * Simple Trade general page, with ll the available assets is viewed. Next step of Simple Trade will be a Buy Sell flow. Note : Simple Trade uses the brokerage product under the hood
	 *
	 * @param {SimpleTradeViewed} [props] - The analytics properties that will be sent to Segment.
	 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
	 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
	 * 		call is fired.
	 */
	simpleTradeViewed,
	/**
	 * The system sends an SMS message with the code after the user inputs a valid mobile number.
	 *
	 * @param {SmsMessageSent} props - The analytics properties that will be sent to Segment.
	 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
	 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
	 * 		call is fired.
	 */
	smsMessageSent,
	/**
	 * The user selects and submits from what account and currency the swap funds should come from and be received to. Event is triggered when both accounts and currencies are confirmed (click on Next or a Suggested Pair is clicked or when receive info is selected and it confirms both directly like in iOS)
	 *
	 * @param {SwapAccountsSelected} props - The analytics properties that will be sent to Segment.
	 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
	 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
	 * 		call is fired.
	 */
	swapAccountsSelected,
	/**
	 * The user enters and submits the amount for a swap transaction. (Preview swap click on Web)
	 *
	 * @param {SwapAmountEntered} props - The analytics properties that will be sent to Segment.
	 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
	 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
	 * 		call is fired.
	 */
	swapAmountEntered,
	/**
	 * The user clicks on the widget or button which sets the max amount allowed.
	 *
	 * @param {SwapAmountMaxClicked} props - The analytics properties that will be sent to Segment.
	 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
	 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
	 * 		call is fired.
	 */
	swapAmountMaxClicked,
	/**
	 * The user clicks on the widget or button which sets the min amount allowed.
	 *
	 * @param {SwapAmountMinClicked} props - The analytics properties that will be sent to Segment.
	 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
	 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
	 * 		call is fired.
	 */
	swapAmountMinClicked,
	/**
	 * Swap Crypto to Crypto (ONLY!) order is cancelled (when updating a custodial transaction with final state CANCELED from custodial_transactions from nabu gateway, with input and output currencies between crypto
	 *
	 * @param {SwapCancelled} props - The analytics properties that will be sent to Segment.
	 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
	 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
	 * 		call is fired.
	 */
	swapCancelled,
	/**
	 * Button which brings the user to the Swap product clicked
	 *
	 * @param {SwapClicked} props - The analytics properties that will be sent to Segment.
	 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
	 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
	 * 		call is fired.
	 */
	swapClicked,
	/**
	 * Swap Crypto to Crypto (ONLY!) order is completed (when updating a custodial transaction with final state FINISHED from custodial_transactions from nabu gateway, with input and output currencies between crypto
	 *
	 * @param {SwapCompleted} props - The analytics properties that will be sent to Segment.
	 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
	 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
	 * 		call is fired.
	 */
	swapCompleted,
	/**
	 * User submits a Crypto to Crypto (ONLY!) swap order (when creating a custodial transaction with state CREATED from custodial_transactions from nabu gateway, with input and output currencies between crypto
	 *
	 * @param {SwapCreated} props - The analytics properties that will be sent to Segment.
	 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
	 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
	 * 		call is fired.
	 */
	swapCreated,
	/**
	 * Swap Crypto to Crypto (ONLY!) order is expired (when updating a custodial transaction with final state EXPIRED from custodial_transactions from nabu gateway, with input and output currencies between crypto
	 *
	 * @param {SwapExpired} props - The analytics properties that will be sent to Segment.
	 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
	 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
	 * 		call is fired.
	 */
	swapExpired,
	/**
	 * Swap Crypto to Crypto (ONLY!) order is failed (when updating a custodial transaction with final state FAILED from custodial_transactions from nabu gateway, with input and output currencies between crypto
	 *
	 * @param {SwapFailed} props - The analytics properties that will be sent to Segment.
	 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
	 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
	 * 		call is fired.
	 */
	swapFailed,
	/**
	 * The user selects and submits from what account and currency the swap funds should come from.  Event is triggered when a specific account and currency are selected from a dropdown or list of potential accounts
	 *
	 * @param {SwapFromSelected} props - The analytics properties that will be sent to Segment.
	 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
	 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
	 * 		call is fired.
	 */
	swapFromSelected,
	/**
	 * The user selects and submits to what account the swapped funds and currency should be received to. Event is triggered when a specific account and currency are selected from a dropdown or list of potential accounts
	 *
	 * @param {SwapReceiveSelected} props - The analytics properties that will be sent to Segment.
	 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
	 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
	 * 		call is fired.
	 */
	swapReceiveSelected,
	/**
	 * Swap Crypto to Crypto (ONLY!) order is rejected. It is not being created at all
	 *
	 * @param {SwapRejected} props - The analytics properties that will be sent to Segment.
	 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
	 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
	 * 		call is fired.
	 */
	swapRejected,
	/**
	 * User confirms and submits a Crypto to Crypto (ONLY!) swap order and the client requests the swap to be created to the backend. We record this in the client because the backend doesn't have the fee information.
	 *
	 * @param {SwapRequested} props - The analytics properties that will be sent to Segment.
	 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
	 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
	 * 		call is fired.
	 */
	swapRequested,
	/**
	 * Swap modal or screen viewed. (SWAP_MODAL for web, Swap tab screens for mobile)
	 *
	 * @param {SwapViewed} [props] - The analytics properties that will be sent to Segment.
	 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
	 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
	 * 		call is fired.
	 */
	swapViewed,
	/**
	 * User swipes to turn on or turn off the receiving feature.
	 *
	 * @param {SwipeToReceiveOptionUpdated} props - The analytics properties that will be sent to Segment.
	 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
	 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
	 * 		call is fired.
	 */
	swipeToReceiveOptionUpdated,
	/**
	 * Portfolio Widget Sync was turned on or turned off
	 *
	 * @param {SyncMyWidgetPortfolioUpdated} props - The analytics properties that will be sent to Segment.
	 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
	 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
	 * 		call is fired.
	 */
	syncMyWidgetPortfolioUpdated,
	/**
	 * User sets their preferred theme from the displayed options.
	 *
	 * @param {ThemeSet} props - The analytics properties that will be sent to Segment.
	 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
	 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
	 * 		call is fired.
	 */
	themeSet,
	/**
	 * The user enters and submits the amount for an exchange trade order. The user will typically confirms the trade in the next screen
	 *
	 * @param {TradeAmountEntered} props - The analytics properties that will be sent to Segment.
	 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
	 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
	 * 		call is fired.
	 */
	tradeAmountEntered,
	/**
	 * The user clicked on the widget or button which sets pre selected amounts to the order
	 *
	 * @param {TradeAmountHelperClicked} props - The analytics properties that will be sent to Segment.
	 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
	 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
	 * 		call is fired.
	 */
	tradeAmountHelperClicked,
	/**
	 * The client sends a requests to the backend to cancel a trade, for example after clicking on "cancel order" or similar buttons
	 *
	 * @param {TradeCancellationRequested} props - The analytics properties that will be sent to Segment.
	 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
	 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
	 * 		call is fired.
	 */
	tradeCancellationRequested,
	/**
	 * A Trade has been created. This event was not implemented due to the fact the market makers will trigger the event constantly. consider using Trade Preview Submitted as an alternative
	 *
	 * @param {TradeCreated} props - The analytics properties that will be sent to Segment.
	 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
	 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
	 * 		call is fired.
	 */
	tradeCreated,
	/**
	 * A Trade has been filled or partially filled. If a trade is fully filled in two parts, this event will be triggered twice and the sum of the input_amount should match the trade amount
	 *
	 * @param {TradeFilled} props - The analytics properties that will be sent to Segment.
	 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
	 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
	 * 		call is fired.
	 */
	tradeFilled,
	/**
	 * The user clicks to cancel the trade being previewed. The preview is typically the final screen before the trade is actually placed, just after the amount is entered.
	 *
	 * @param {TradePreviewCancelled} props - The analytics properties that will be sent to Segment.
	 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
	 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
	 * 		call is fired.
	 */
	tradePreviewCancelled,
	/**
	 * The user clicks to retry the trade being previewed. (mobile only) This happens for example when the previous submission failed few seconds earlier. The preview is typically the final screen before the trade is actually placed, just after the amount is entered.
	 *
	 * @param {TradePreviewRetried} props - The analytics properties that will be sent to Segment.
	 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
	 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
	 * 		call is fired.
	 */
	tradePreviewRetried,
	/**
	 * The user submits the trade being previewed. The preview is typically the final screen before the trade is actually placed, just after the amount is entered.
	 *
	 * @param {TradePreviewSubmitted} props - The analytics properties that will be sent to Segment.
	 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
	 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
	 * 		call is fired.
	 */
	tradePreviewSubmitted,
	/**
	 * Button which brings the user to the Trading page or screen is clicked
	 *
	 * @param {TradingClicked} props - The analytics properties that will be sent to Segment.
	 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
	 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
	 * 		call is fired.
	 */
	tradingClicked,
	/**
	 * Main Trading screen or page in the exchange is viewed. This is the Exchange page with the orderbook, price chart and buy sell screen
	 *
	 * @param {TradingViewed} props - The analytics properties that will be sent to Segment.
	 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
	 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
	 * 		call is fired.
	 */
	tradingViewed,
	/**
	 * Two-Step Verification turned off by user request.
	 *
	 * @param {TwoStepVerificationDisabled} props - The analytics properties that will be sent to Segment.
	 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
	 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
	 * 		call is fired.
	 */
	twoStepVerificationDisabled,
	/**
	 * Two-Step Verification succesfully activated.
	 *
	 * @param {TwoStepVerificationEnabled} props - The analytics properties that will be sent to Segment.
	 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
	 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
	 * 		call is fired.
	 */
	twoStepVerificationEnabled,
	/**
	 * The user clicks the preferred Two-Step security option
	 *
	 * @param {TwoStepVerificationOptionClicked} props - The analytics properties that will be sent to Segment.
	 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
	 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
	 * 		call is fired.
	 */
	twoStepVerificationOptionClicked,
	/**
	 * The user clicks on a widget or CTA inviting the user to upgrade their tier status.
	 *
	 * @param {UpgradeVerificationClicked} [props] - The analytics properties that will be sent to Segment.
	 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
	 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
	 * 		call is fired.
	 */
	upgradeVerificationClicked,
	/**
	 * User eligible to use the product. More information on Simple Eligibility Nabu wiki
	 *
	 * @param {UserProductEligible} props - The analytics properties that will be sent to Segment.
	 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
	 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
	 * 		call is fired.
	 */
	userProductEligible,
	/**
	 * User not eligible to use the product. More information on Simple Eligibility Nabu wiki
	 *
	 * @param {UserProductNotEligible} props - The analytics properties that will be sent to Segment.
	 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
	 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
	 * 		call is fired.
	 */
	userProductNotEligible,
	/**
	 * User eligible to start the SDD (tier 3) verification process. More info on SDD-API Nabu wiki
	 *
	 * @param {Record<string, any>} [props] - The analytics properties that will be sent to Segment.
	 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
	 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
	 * 		call is fired.
	 */
	userSddEligible,
	/**
	 * User not eligible to start the SDD (tier 3) verification process. User will be prompted for Gold verification instead in the wallet. More info on SDD-API Nabu wiki
	 *
	 * @param {UserSddNotEligible} props - The analytics properties that will be sent to Segment.
	 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
	 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
	 * 		call is fired.
	 */
	userSddNotEligible,
	/**
	 * The user submits the Authenticator App code, Yubikey code or SMS code in order to finish set up their two step verification
	 *
	 * @param {VerificationCodeSubmitted} props - The analytics properties that will be sent to Segment.
	 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
	 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
	 * 		call is fired.
	 */
	verificationCodeSubmitted,
	/**
	 * An identify verification has been performed, which typically means that some PII or documents have been submitted and validated by the provider.
	 *
	 * @param {VerificationCompleted} props - The analytics properties that will be sent to Segment.
	 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
	 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
	 * 		call is fired.
	 */
	verificationCompleted,
	/**
	 * An identify verification has been rejected, which typically means that some PII or documents have been submitted but were not suitable.
	 *
	 * @param {VerificationRejected} props - The analytics properties that will be sent to Segment.
	 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
	 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
	 * 		call is fired.
	 */
	verificationRejected,
	/**
	 * An identify verification has been started : only available for Tier 2 gold. A user is trying to upgrade their verification tier, and is about to send documents or informations. Tier 1 and Tier 3 verification are only in Verification Completed event
	 *
	 * @param {VerificationStarted} props - The analytics properties that will be sent to Segment.
	 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
	 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
	 * 		call is fired.
	 */
	verificationStarted,
	/**
	 * An identify verification submission, like video upload, was attempted but a failure happened
	 *
	 * @param {VerificationSubmissionFailed} props - The analytics properties that will be sent to Segment.
	 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
	 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
	 * 		call is fired.
	 */
	verificationSubmissionFailed,
	/**
	 * Allowing the following option prevents IP addresses that are known to be part of the Tor anonymizing network from accessing your wallet.
	 *
	 * @param {WalletAccessViaTorUpdated} props - The analytics properties that will be sent to Segment.
	 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
	 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
	 * 		call is fired.
	 */
	walletAccessViaTorUpdated,
	/**
	 * A button inviting the user to discover our Wallet product is clicked.  Note that this does not include the navigation part of the header.
	 *
	 * @param {WalletHyperlinkClicked} props - The analytics properties that will be sent to Segment.
	 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
	 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
	 * 		call is fired.
	 */
	walletHyperlinkClicked,
	/**
	 * A user signs up for a Wallet account. Note that this is different from Signed Up which is triggered when a nabu user profile is created. A wallet without a nabu user will be seen as an Anonymous User
	 *
	 * @param {WalletSignedUp} props - The analytics properties that will be sent to Segment.
	 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
	 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
	 * 		call is fired.
	 */
	walletSignedUp,
	/**
	 * The user selects and submits the amount to be withdrawn. Note: On the web wallet, this is the final step and the user does not have to confirm at a later stage. For the mobile app and web wallet, the user will still have to confirm at a later stage for the withdraw order to be created.
	 *
	 * @param {WithdrawalAmountEntered} props - The analytics properties that will be sent to Segment.
	 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
	 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
	 * 		call is fired.
	 */
	withdrawalAmountEntered,
	/**
	 * The user clicked on the widget or button which sets pre selected amounts to the withdrawal. Not available on Exchange Web at the moment.
	 *
	 * @param {WithdrawalAmountHelperClicked} props - The analytics properties that will be sent to Segment.
	 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
	 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
	 * 		call is fired.
	 */
	withdrawalAmountHelperClicked,
	/**
	 * The user clicked on the widget or button which sets the max amount allowed to withdraw
	 *
	 * @param {WithdrawalAmountMaxClicked} props - The analytics properties that will be sent to Segment.
	 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
	 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
	 * 		call is fired.
	 */
	withdrawalAmountMaxClicked,
	/**
	 * The user clicked on the widget or button which sets the min amount allowed to withdraw
	 *
	 * @param {WithdrawalAmountMinClicked} props - The analytics properties that will be sent to Segment.
	 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
	 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
	 * 		call is fired.
	 */
	withdrawalAmountMinClicked,
	/**
	 * Withdrawal button which brings the user to the Withdrawal modal or page is clicked.
	 *
	 * @param {WithdrawalClicked} props - The analytics properties that will be sent to Segment.
	 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
	 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
	 * 		call is fired.
	 */
	withdrawalClicked,
	/**
	 * The user selects how the funds will be withdrawn, either linked bank or transfer
	 *
	 * @param {WithdrawalMethodSelected} props - The analytics properties that will be sent to Segment.
	 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
	 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
	 * 		call is fired.
	 */
	withdrawalMethodSelected,
	/**
	 * Withdrawal flyover or screen viewed. This should be triggered anytime the page is showed coming from another part of the product
	 *
	 * @param {WithdrawalViewed} props - The analytics properties that will be sent to Segment.
	 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
	 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
	 * 		call is fired.
	 */
	withdrawalViewed,
	/**
	 * Wrong XPub change cache stored in the payload is seen.
	 *
	 * @param {Record<string, any>} [props] - The analytics properties that will be sent to Segment.
	 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
	 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
	 * 		call is fired.
	 */
	wrongChangeCache,
	/**
	 * Wrong XPub receive cache stored in the payload is seen.
	 *
	 * @param {Record<string, any>} [props] - The analytics properties that will be sent to Segment.
	 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
	 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
	 * 		call is fired.
	 */
	wrongReceiveCache,
}

export default new Proxy<typeof clientAPI>(clientAPI, {
	get(target, method) {
		if (typeof method === 'string' && target.hasOwnProperty(method)) {
			return target[method as keyof typeof clientAPI]
		}

		return () => {
			console.warn(`⚠️  You made an analytics call (${String(
				method
			)}) that can't be found. Either:
    a) Re-generate your typewriter client: \`npx typewriter\`
    b) Add it to your Tracking Plan: https://app.segment.com/blockchain/protocols/tracking-plans/rs_1rTQPq3YJO50gUMOeV9FoPd5eY2`)
			const a = analytics()
			if (a) {
				a.track(
					'Unknown Analytics Call Fired',
					{
						method,
					},
					withTypewriterContext()
				)
			}
		}
	},
})
